<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\admin_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { CommentService } from '#services/comment_service'\nimport SellerService from '#services/seller_service'\nimport { SellerVerificationStatus, PayoutRequestStatus } from '@prisma/client'\nimport { ReviewService } from '#services/review_service'\n\n/**\n * Controller class for handling Admin operations on Seller Profiles.\n */\n@inject()\nexport default class AdminController {\n  constructor(\n    protected commentService: CommentService,\n    protected sellerService: SellerService,\n    protected reviewService: ReviewService\n  ) {}\n  /**\n   * Retrieve a Seller Profile by user ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   */\n  public async getSellerProfile({ params, response }: HttpContext) {\n    const { id } = params\n\n    try {\n      const sellerProfile = await prisma.sellerProfile.findUnique({\n        where: { userId: id },\n        include: { bankAccount: true, user: true },\n      })\n\n      if (!sellerProfile) {\n        return response.status(404).json({ message: 'Seller profile not found' })\n      }\n\n      return response.status(200).json(sellerProfile)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a Seller Profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam data - The data to update the Seller Profile.\n   */\n  public async updateSellerProfile({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only([\n      'businessName',\n      'businessAddress',\n      'businessPhone',\n      'businessEmail',\n      'accountHolderName',\n      'accountNumber',\n      'bankName',\n      'swiftCode',\n      'iban',\n      'routingNumber',\n      'verificationStatus',\n    ])\n\n    if (data.verificationStatus) {\n      if (!Object.values(SellerVerificationStatus).includes(data.verificationStatus)) {\n        return response.status(400).json({ message: 'Invalid status' })\n      }\n    }\n\n    const user = await prisma.user.findUnique({ where: { email } })\n    if (!user) {\n      return response.status(404).json({ message: 'User not found' })\n    }\n\n    try {\n      await this.sellerService.updateSellerProfile(user.id, data)\n      //const updatedProfile = await prisma.sellerProfile.update({\n      //  where: { userId: user.id },\n      //  data: {\n      //    businessName: data.businessName,\n      //    businessAddress: data.businessAddress,\n      //    businessPhone: data.businessPhone,\n      //    businessEmail: data.businessEmail,\n      //    bankAccount: {\n      //      upsert: {\n      //        create: {\n      //          accountHolderName: data.accountHolderName,\n      //          accountNumber: data.accountNumber,\n      //          bankName: data.bankName,\n      //          swiftCode: data.swiftCode,\n      //          iban: data.iban,\n      //          routingNumber: data.routingNumber,\n      //        },\n      //        update: {\n      //          accountHolderName: data.accountHolderName,\n      //          accountNumber: data.accountNumber,\n      //          bankName: data.bankName,\n      //          swiftCode: data.swiftCode,\n      //          iban: data.iban,\n      //          routingNumber: data.routingNumber,\n      //        },\n      //      },\n      //    },\n      //  },\n      //  include: { bankAccount: true },\n      //})\n\n      return response.status(200).json({ message: 'Seller profile updated successfully' })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * List all Seller Profiles with pagination.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam page - The page number for pagination.\n   * @queryParam limit - The number of items per page.\n   */\n  public async listSellerProfiles({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n    const skip = (page - 1) * limit\n\n    try {\n      const [sellerProfiles, total] = await prisma.$transaction([\n        prisma.sellerProfile.findMany({\n          skip,\n          take: limit,\n          include: { user: true, bankAccount: true },\n        }),\n        prisma.sellerProfile.count(),\n      ])\n\n      return response.status(200).json({\n        data: sellerProfiles,\n        meta: {\n          total,\n          page,\n          limit,\n        },\n      })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Verify a Seller Profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam status - The verification status to set.\n   */\n  public async verifySellerProfile({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { status } = request.only(['status'])\n\n    try {\n      const updatedProfile = await prisma.sellerProfile.update({\n        where: { userId: id },\n        data: {\n          verificationStatus: status,\n          verificationDate: new Date(),\n        },\n      })\n\n      return response.status(200).json(updatedProfile)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Ban a user.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam banUntil - The date until which the user is banned.\n   */\n  public async banUser({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { banUntil } = request.only(['banUntil'])\n\n    try {\n      const bannedUser = await prisma.user.update({\n        where: { id },\n        data: {\n          bannedUntil: new Date(banUntil),\n        },\n      })\n\n      return response.status(200).json(bannedUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async unbanUser({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const unbanUser = await prisma.user.update({\n        where: { id },\n        data: {\n          bannedUntil: null,\n        },\n      })\n      return response.status(200).json(unbanUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async deleteUser({ params, response }: HttpContext) {\n    const { email } = params\n    try {\n      const deletedUser = await prisma.user.update({\n        where: { email },\n        data: {\n          deletedAt: new Date(),\n        },\n      })\n      return response.status(200).json(deletedUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async getAllFlaggedReviews({ response }: HttpContext) {\n    try {\n      const comments = await this.reviewService.getAllFlaggedReviews()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  public async getAllFlaggedComments({ response }: HttpContext) {\n    try {\n      const comments = await this.commentService.getAllFlaggedComments()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getSellerApplications\n   * @description Get all seller applications\n   * @queryParam status - Optional filter for verification status\n   * @responseBody 200 - { \"applications\": SellerProfile[] }\n   */\n  public async getSellerApplications({ request, response }: HttpContext) {\n    const status = request.input('status') as SellerVerificationStatus | undefined\n    try {\n      const applications = await this.sellerService.getSellerApplications(status)\n      return response.status(200).json({ applications })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateSellerApplicationStatus\n   * @description Update the status of a seller application\n   * @paramParam id - The ID of the seller profile\n   * @requestBody {\n   *   \"status\": \"APPROVED\" | \"REJECTED\"\n   * }\n   * @responseBody 200 - { \"message\": \"Application status updated\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid status\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async updateSellerApplicationStatus({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { verificationStatus } = request.body()\n\n    if (!Object.values(SellerVerificationStatus).includes(verificationStatus)) {\n      return response.status(400).json({ message: 'Invalid status' })\n    }\n\n    try {\n      const profile = await this.sellerService.updateSellerApplicationStatus(id, verificationStatus)\n      return response.status(200).json({ message: 'Application status updated', profile })\n    } catch (error) {\n      return response.status(404).json({ message: 'Seller profile not found' })\n    }\n  }\n\n  /**\n   * @getPayoutRequests\n   * @description Get all payout requests\n   * @queryParam status - Optional filter for payout request status\n   * @responseBody 200 - { \"requests\": PayoutRequest[] }\n   */\n  public async getPayoutRequests({ request, response }: HttpContext) {\n    const status = request.input('status') as PayoutRequestStatus | undefined\n    try {\n      const requests = await this.sellerService.getPayoutRequests(status)\n      return response.status(200).json({ requests })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updatePayoutRequestStatus\n   * @description Update the status of a payout request\n   * @paramParam id - The ID of the payout request\n   * @requestBody {\n   *   \"status\": \"APPROVED\" | \"REJECTED\" | \"PROCESSED\"\n   * }\n   * @responseBody 200 - { \"message\": \"Payout request status updated\", \"request\": PayoutRequest }\n   * @responseBody 400 - { \"message\": \"Invalid status\" }\n   * @responseBody 404 - { \"message\": \"Payout request not found\" }\n   */\n  public async updatePayoutRequestStatus({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { status } = request.body()\n\n    if (!Object.values(PayoutRequestStatus).includes(status)) {\n      return response.status(400).json({ message: 'Invalid status' })\n    }\n\n    try {\n      const payoutRequest = await this.sellerService.updatePayoutRequestStatus(id, status)\n      return response\n        .status(200)\n        .json({ message: 'Payout request status updated', request: payoutRequest })\n    } catch (error) {\n      return response.status(404).json({ message: 'Payout request not found' })\n    }\n  }\n\n  /**\n   * @verifySellerDocument\n   * @description Verify a seller's identity document\n   * @paramParam id - The ID of the seller profile\n   * @requestBody {\n   *   \"isVerified\": boolean\n   * }\n   * @responseBody 200 - { \"message\": \"Document verification status updated\", \"profile\": SellerProfile }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async verifySellerDocument({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { isVerified } = request.body()\n\n    try {\n      const profile = await this.sellerService.verifySellerDocument(id, isVerified)\n      return response.status(200).json({ message: 'Document verification status updated', profile })\n    } catch (error) {\n      return response.status(404).json({ message: 'Seller profile not found' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\auth_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport AuthService from '#services/auth_service'\nimport {\n  AuthValidator,\n  ZodLoginAuthStrategy,\n  PrismaEmailExistsAuthStrategy,\n  ZodRegistrationAuthStrategy,\n  PrismaEmailUniqueAuthStrategy,\n  EmptyFieldAuthStrategy,\n} from '#validators/auth'\nimport { inject } from '@adonisjs/core'\nimport lucia from '#services/lucia_service'\nimport { Exception } from '@adonisjs/core/exceptions'\nimport type { Cookie } from 'lucia'\nimport { UserService } from '#services/user_service'\nimport { prisma } from '#services/prisma_service'\nimport InvalidSessionIdException from '#exceptions/invalid_session_id_exception'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport logger from '@adonisjs/core/services/logger'\n\n/**\n * Controller class for handling user authentication operations.\n */\n@inject()\nexport default class AuthController {\n  /**\n   * Creates an instance of AuthController.\n   *\n   * @param authService - The authentication service.\n   */\n  constructor(\n    protected authService: AuthService,\n    protected userService: UserService\n  ) {}\n\n  /**\n   * @login\n   * @description Handle user login.\n   * @requestBody { \"email\": \"user@example.com\", \"password\": \"123123123\"}\n   * @responseBody 200 - { \"message\": \"Login successful\" }\n   * @responseBody 400 - { \"message\": \"Invalid credentials\" }\n   */\n  async login({ request, response }: HttpContext) {\n    const { email, password } = request.only(['email', 'password'])\n\n    const loginValidator = new AuthValidator()\n    //loginValidator.addStrategy(new ZodLoginAuthStrategy())\n    loginValidator.addStrategy(new PrismaEmailExistsAuthStrategy())\n    loginValidator.addStrategy(new EmptyFieldAuthStrategy())\n\n    try {\n      await loginValidator.validate({ email, password })\n    } catch (e: Error | any) {\n      console.log(e)\n      return response.abort({ message: e.message }, 400)\n    }\n\n    try {\n      const sessionCookie: Cookie | Response = await this.authService.handleLogin(email, password)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Invalid credentials')\n      }\n\n      const c = sessionCookie.serialize()\n      const sid = lucia.readSessionCookie(c)\n      const { user } = await lucia.validateSession(sid ?? '')\n      if (!user) throw new InvalidSessionIdException()\n\n      return response.header('Set-Cookie', c).status(200).json({ message: 'Login successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n\n  /**\n   * @register\n   * @description Handle user registration.\n   * @bodyParam email - The user's email address.\n   * @requestBody { \"email\": \"user@example.com\", \"password\": \"123123123\", \"fullname\": \"John Doe\"}\n   * @bodyParam password - The user's password.\n   * @bodyParam fullname - The user's full name.\n   * @responseBody 201 - { \"message\": \"Registration successful\" }\n   * @responseBody 400 - { \"message\": \"Registration failed\" }\n   */\n  async register({ request, response }: HttpContext) {\n    const { email, password, fullname } = request.only(['email', 'password', 'fullname'])\n    const registrationValidator = new AuthValidator()\n    registrationValidator.addStrategy(new ZodRegistrationAuthStrategy())\n    registrationValidator.addStrategy(new PrismaEmailUniqueAuthStrategy())\n\n    try {\n      await registrationValidator.validate({ email, password, fullname })\n    } catch (e: Error | any) {\n      if (Array.isArray(e)) {\n        return response.abort({ message: e }, 400)\n      } else {\n        return response.abort({ message: e.message }, 400)\n      }\n    }\n\n    try {\n      const sessionCookie = await this.authService.handleRegistration(email, password, fullname)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Registration failed')\n      }\n      return response\n        .cookie('session', sessionCookie)\n        .status(201)\n        .json({ message: 'Registration successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @logout\n   * @description Handle user logout.\n   * @responseBody 200 - { \"message\": \"Logout successful\" }\n   * @responseBody 400 - { \"message\": \"Logout failed\" }\n   */\n  async logout({ request, response }: HttpContext) {\n    const sessionId = request.cookie('auth_session')\n    try {\n      await this.authService.handleLogout(sessionId)\n      return response.clearCookie('auth_session').status(200).json({ message: 'Logout successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @verifyEmail\n   * @description Handle email verification.\n   * @requestBody { \"code\": \"123456\" }\n   * @responseBody 200 - { \"message\": \"Email verification successful\" }\n   * @responseBody 400 - { \"message\": \"Email verification failed\" }\n   */\n  async verifyEmail({ request, response }: HttpContext) {\n    const { code } = request.only(['code'])\n    logger.info(request.headers())\n    try {\n      const sessionId = lucia.readSessionCookie(request.headers().cookie ?? '')\n      if (!sessionId) {\n        throw new InvalidSessionIdException()\n      }\n      const sessionCookie = await this.authService.handleVerifyEmail(sessionId, code)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Email verification failed')\n      }\n      return response\n        .cookie('session', sessionCookie)\n        .status(200)\n        .json({ message: 'Email verification successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @createPasswordResetToken\n   * @description Handle password reset token creation.\n   * @requestBody { \"userId\": \"123456\" }\n   * @responseBody 200 - { \"token\": \"generated_token\" }\n   * @responseBody 400 - { \"message\": \"Password reset token creation failed\" }\n   */\n  async createPasswordResetToken({ request, response }: HttpContext) {\n    const { userId } = request.only(['userId'])\n    try {\n      const token = await this.authService.handleCreatePasswordResetToken(userId)\n      if (token instanceof Response) {\n        throw new Error('Password reset token creation failed')\n      }\n      return response.status(200).json({ token })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @resetPassword\n   * @description Handle password reset.\n   * @requestBody { \"token\": \"generated_token\", \"password\": \"123456\" }\n   * @responseBody 200 - { \"message\": \"Password reset successful\" }\n   * @responseBody 400 - { \"message\": \"Password reset failed\" }\n   */\n  async resetPassword({ request, response }: HttpContext) {\n    const { token, password } = request.only(['token', 'password'])\n    try {\n      const sessionCookie = await this.authService.handlePasswordReset(token, password)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Password reset failed')\n      }\n      return response\n        .cookie('session', sessionCookie)\n        .status(200)\n        .json({ message: 'Password reset successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @verifyUserExistAndEmailVerified\n   * @description Verify if user exists and their email is verified.\n   * @bodyParam email - The user's email address.\n   * @responseBody 200 - { \"exists\": true }\n   * @responseBody 400 - { \"message\": \"Verification failed\" }\n   */\n  async verifyUserExistAndEmailVerified({ request, response }: HttpContext) {\n    const { email } = request.only(['email'])\n    try {\n      const exists = await this.authService.handleVerifyUserExistAndEmailVerified(email)\n      return response.status(200).json({ exists })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @sendVerifyEmailCodeFromUser\n   * @description Send verification email code to the user.\n   * @responseBody 401 - { \"message\": \"User not found in request object\" }\n   * @responseBody 400 - { \"message\": \"Sending verification email failed\" }\n   */\n  async sendVerifyEmailCodeFromUser({ request, response }: HttpContext) {\n    if (request.user === null) throw new UnAuthorizedException('User not found in request object')\n    try {\n      await this.authService.sendVerifyEmailCode(request.user)\n      return response.status(200).json({ message: 'Verification email sent' })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n\n  /**\n   * @me\n   * @description Get the user profile.\n   * @responseBody 200 - { \"user\": { \"email\": \"wOwYg@example.com\", \"role\": \"USER\" }, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\" } }\n   * @responseBody 400 - { \"message\": \"Profile retrieval failed\" }\n   */\n  async me({ request, response }: HttpContext) {\n    try {\n      if (request.user === null) throw new Exception('No cookie session found', { status: 204 })\n      const [user, profile, sellerProfile] = await Promise.all([\n        prisma.user.findUnique({ where: { id: request.user.id } }),\n        prisma.profile.findUnique({ where: { userId: request.user.id } }),\n        prisma.sellerProfile.findUnique({ where: { userId: request.user.id } }),\n      ])\n      return response.status(200).json({ user, profile, sellerProfile })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\checkout_controller.ts</source>
<document_content>import { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport CheckoutService from '#services/checkout_service'\nimport { prisma } from '#services/prisma_service'\nimport logger from '@adonisjs/core/services/logger'\n\nconst initCheckoutSchema = z.object({\n  repoId: z.string(),\n})\n\nconst processPaymentSchema = z.object({\n  paymentIntentId: z.string(),\n})\n\n@inject()\nexport default class CheckoutController {\n  constructor(protected checkoutService: CheckoutService) {}\n\n  /**\n   * @initCheckout\n   * @description Initiate the checkout process for a repo\n   * @requestBody {\n   *   \"repoId\": \"clxxxxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 200 - {\n   *   \"clientSecret\": \"pi_xxxxxxxxxxxxx_secret_xxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Repo not found\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while initiating checkout\" }\n   */\n  public async initCheckout({ request, response }: HttpContext) {\n    try {\n      const user = request.user\n      if (!user) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n      const { repoId } = initCheckoutSchema.parse(request.body())\n\n      const result = await this.checkoutService.initCheckout(repoId, user.id)\n      return response.ok(result)\n    } catch (error) {\n      logger.error({ err: error }, 'Error in initCheckout')\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      if (\n        error instanceof Error &&\n        error.message === 'Repo not found or seller profile not available'\n      ) {\n        return response.notFound({ message: error.message })\n      }\n      return response.internalServerError({\n        message: 'An error occurred while initiating checkout',\n      })\n    }\n  }\n\n  /**\n   * @processPayment\n   * @description Process the payment for a checkout\n   * @requestBody {\n   *   \"paymentIntentId\": \"pi_xxxxxxxxxxxxx\"\n   * }\n   * @responseBody 200 - {\n   *   \"success\": true,\n   *   \"orderId\": \"clxxxxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Payment intent not found\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while processing payment\" }\n   */\n  public async processPayment({ request, response }: HttpContext) {\n    const user = request.user\n    if (!user) return response.unauthorized({ message: 'User not authenticated' })\n    const trx = await prisma.$transaction(async (tx) => {\n      try {\n        const { paymentIntentId } = processPaymentSchema.parse(request.body())\n        const result = await this.checkoutService.processPayment(user.id, paymentIntentId, tx)\n        return response.ok(result)\n      } catch (error) {\n        logger.error({ err: error }, 'Error in processPayment')\n        if (error instanceof z.ZodError) {\n          return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n        }\n        if (error instanceof Error && error.message === 'Payment intent not found') {\n          return response.notFound({ message: error.message })\n        }\n        throw error // Re-throw to trigger transaction rollback\n      }\n    })\n\n    return trx\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\code_checks_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport CodeCheckService from '#services/code_check_service'\nimport { codeCheckRequestSchema, type CodeCheckRequest } from '#validators/code_check'\nimport { prisma } from '#services/prisma_service'\n\n@inject()\nexport default class CodeCheckController {\n  constructor(protected codeCheckService: CodeCheckService) {}\n\n  public async publicCheckCode({ request, response }: HttpContext) {\n    try {\n      const data = request.only(['code', 'language'])\n      const validatedData = codeCheckRequestSchema.parse(data) as CodeCheckRequest\n      const result = await this.codeCheckService.performCodeCheck(\n        validatedData.code,\n        validatedData.language\n      )\n\n      return response.status(200).json(result)\n    } catch (error) {\n      if (error.code === 'P2002') {\n        return response.status(400).json({ message: 'Invalid input', errors: error.message })\n      }\n\n      console.error('Code check error:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while processing the request.' })\n    }\n  }\n\n  public async checkAndStoreCode({ request, response }: HttpContext) {\n    try {\n      const data = request.only(['code', 'language', 'repoId'])\n      const validatedData = codeCheckRequestSchema.parse(data) as CodeCheckRequest & {\n        repoId: string\n      }\n\n      const repoExists = await prisma.codeRepo.findUnique({\n        where: { id: validatedData.repoId },\n      })\n      if (!repoExists) {\n        return response.status(404).json({ message: 'Repository not found.' })\n      }\n\n      const result = await this.codeCheckService.performAndStoreCodeCheck(\n        validatedData.repoId,\n        validatedData.code,\n        validatedData.language\n      )\n\n      return response.status(200).json(result)\n    } catch (error) {\n      if (error.code === 'P2002') {\n        return response.status(400).json({ message: 'Invalid input', errors: error.message })\n      }\n\n      console.error('Code check error:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while processing the request.' })\n    }\n  }\n\n  public async getCodeCheck({ params, response }: HttpContext) {\n    try {\n      const { repoId } = params\n\n      const repoExists = await prisma.codeRepo.findUnique({\n        where: { id: repoId },\n      })\n      if (!repoExists) {\n        return response.status(404).json({ message: 'Repository not found.' })\n      }\n\n      const result = await this.codeCheckService.getLatestCodeCheck(repoId)\n\n      if (!result) {\n        return response\n          .status(404)\n          .json({ message: 'No code check result found for this repository.' })\n      }\n\n      return response.status(200).json(result)\n    } catch (error) {\n      console.error('Error retrieving code check result:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while retrieving the code check result.' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\comments_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { CommentService } from '#services/comment_service'\nimport { z } from 'zod'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { VoteType } from '@prisma/client'\n\nconst createCommentSchema = z.object({\n  content: z.string().min(1).max(1000),\n  reviewId: z.string(),\n})\n\nconst updateCommentSchema = z.object({\n  content: z.string().max(1000).optional(),\n  flag: z.enum(['NONE']).optional(),\n})\n\nconst paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  perPage: z.coerce.number().int().positive().max(100).default(10),\n  //reviewId: z.string().cuid(),\n})\n\nconst voteSchema = z.object({\n  type: z.enum(['UPVOTE', 'DOWNVOTE']),\n})\n\n@inject()\nexport default class CommentController {\n  constructor(protected commentService: CommentService) {}\n\n  /**\n   * @createComment\n   * @description Create a new comment for a review.\n   * @route POST /comments\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"This is a comment\",\n   *   \"reviewId\": \"cuid1234567890\"\n   * }\n   * @responseBody 201 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\"\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const data = request.all()\n      const validatedData = createCommentSchema.parse(data)\n      const comment = await this.commentService.createComment({\n        ...validatedData,\n        userId,\n      })\n      return response.status(201).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getCommentsByReview\n   * @description Get paginated comments for a specific review.\n   * @route GET /repo/:repoId/reviews/:reviewId\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} page - Page number for pagination.\n   * @queryParam {number} perPage - Number of items per page.\n   * @responseBody 200 - {\n   *   \"data\": [\n   *     {\n   *       \"id\": \"cuid1234567890\",\n   *       \"content\": \"This is a comment\",\n   *       \"userId\": \"user123\",\n   *       \"reviewId\": \"review456\",\n   *       \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *       \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *       \"upvotes\": 5,\n   *       \"downvotes\": 2\n   *     },\n   *     ...\n   *   ],\n   *   \"meta\": {\n   *     \"total\": 100,\n   *     \"page\": 1,\n   *     \"perPage\": 10,\n   *     \"lastPage\": 10\n   *   }\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async getCommentsByReview({ params, request, response }: HttpContext) {\n    try {\n      const { reviewId } = params\n      const { page, perPage } = paginationSchema.parse(request.qs())\n      const comments = await this.commentService.getPaginatedCommentsByReview(\n        reviewId,\n        page,\n        perPage\n      )\n      return response.status(200).json(comments)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getCommentById\n   * @description Get a specific comment by its ID.\n   * @route GET /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async getById({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.getCommentById(id)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateComment\n   * @description Update a specific comment.\n   * @route PUT /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"Updated comment content\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"Updated comment content\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      const data = updateCommentSchema.parse(request.all())\n      const comment = await this.commentService.updateComment(id, data)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @revertCommentFlag\n   * @description Revert the flag on a comment to NONE.\n   * @route PUT /comments/:id/revert\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"flag\": \"NONE\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async revertFlag({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.revertFlag(id)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @deleteComment\n   * @description Soft delete a specific comment.\n   * @route DELETE /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { \"message\": \"Comment deleted successfully\", \"comment\": {...} }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async delete({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.deleteComment(id)\n      return response.status(200).json({ message: 'Comment deleted successfully', comment })\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getAllFlaggedComments\n   * @description Get all flagged comments.\n   * @route GET /comments/flagged\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - [\n   *   {\n   *     \"id\": \"cuid1234567890\",\n   *     \"content\": \"This is a flagged comment\",\n   *     \"userId\": \"user123\",\n   *     \"reviewId\": \"review456\",\n   *     \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *     \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *     \"flag\": \"INAPPROPRIATE_LANGUAGE\"\n   *   },\n   *   ...\n   * ]\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const comments = await this.commentService.getAllFlaggedComments()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @handleVote\n   * @description Handle upvote or downvote for a comment.\n   * @route POST /comments/:id/vote\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"type\": \"UPVOTE\" | \"DOWNVOTE\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 6,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async handleVote({ params, request, response }: HttpContext) {\n    try {\n      const { id, vote } = params\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      // process the types into the enum\n      const voteType = vote === 'upvote' ? VoteType.UPVOTE : VoteType.DOWNVOTE\n\n      const comment = await this.commentService.handleVote(id, userId, voteType)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\dashboard_controller.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport AdminDashboardService from '#services/admin_dashboard_service'\nimport UserDashboardService from '#services/user_dashboard_service'\nimport ModeratorDashboardService from '#services/moderator_dashboard_service'\n\n@inject()\nexport default class DashboardController {\n  constructor(\n    private adminDashboardService: AdminDashboardService,\n    private moderatorDashboardService: ModeratorDashboardService,\n    private userDashboardService: UserDashboardService\n  ) {}\n\n  /**\n   * @getAdminDashboardData\n   * @description Get admin dashboard data\n   * @responseBody 200 - { salesOverview: {...}, userStatistics: {...}, ... }\n   * @responseBody 403 - { error: \"Unauthorized access\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getAdminDashboardData({ request, response }: HttpContext) {\n    try {\n      if (request.user?.role !== 'ADMIN') {\n        return response.forbidden({ error: 'Unauthorized access' })\n      }\n\n      const dashboardData = await this.adminDashboardService.getDashboardData()\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching admin dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n\n  /**\n   * @getModeratorDashboardData\n   * @description Get moderator dashboard data\n   * @responseBody 200 - { contentModerationOverview: {...}, moderationActivity: {...}, ... }\n   * @responseBody 403 - { error: \"Unauthorized access\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getModeratorDashboardData({ request, response }: HttpContext) {\n    try {\n      if (request.user?.role !== 'MODERATOR') {\n        return response.forbidden({ error: 'Unauthorized access' })\n      }\n\n      const dashboardData = await this.moderatorDashboardService.getDashboardData(request.user.id)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching moderator dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n\n  /**\n   * @getUserDashboardData\n   * @description Get user dashboard data\n   * @responseBody 200 - { purchaseHistory: {...}, accessedRepos: [...], ... }\n   * @responseBody 401 - { error: \"Unauthorized\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getUserDashboardData({ request, response }: HttpContext) {\n    try {\n      if (!request.user) {\n        return response.unauthorized({ error: 'Unauthorized' })\n      }\n\n      const dashboardData = await this.userDashboardService.getDashboardData(request.user.id)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching user dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\health_checks_controller.ts</source>
<document_content>import { healthChecks } from '#start/health'\nimport type { HttpContext } from '@adonisjs/core/http'\n\nexport default class HealthChecksController {\n  async handle({ response }: HttpContext) {\n    const report = await healthChecks.run()\n\n    if (report.isHealthy) {\n      return response.ok(report)\n    }\n\n    return response.serviceUnavailable(report)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\orders_controller.ts</source>
<document_content>import { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport OrderService from '#services/order_service'\nimport { prisma } from '#services/prisma_service'\nimport { OrderStatus } from '@prisma/client'\n\nconst createOrderSchema = z.object({\n  repoId: z.string(),\n  amount: z.number().positive(),\n  stripePaymentIntentId: z.string(),\n})\n\nconst updateOrderSchema = z.object({\n  status: z.nativeEnum(OrderStatus),\n})\n\n@inject()\nexport default class OrderController {\n  constructor(protected orderService: OrderService) {}\n\n  /**\n   * @createOrder\n   * @description Create a new order\n   * @requestBody {\n   *   \"repoId\": \"clxxxxxxxxxxxxxxxx\",\n   *   \"amount\": 1000,\n   *   \"stripePaymentIntentId\": \"pi_xxxxxxxxxxxxx\"\n   * }\n   * @responseBody 201 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Failed to create order\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const data = createOrderSchema.parse(request.body())\n      const userId = request.user?.id\n\n      if (!userId) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n\n      const order = await this.orderService.createOrder({\n        userId,\n        repoId: data.repoId,\n        amount: data.amount,\n        status: OrderStatus.SUCCEEDED, // Assuming default status, adjust as needed\n        stripePaymentIntentId: data.stripePaymentIntentId,\n      })\n      return response.created(order)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      return response.internalServerError({ message: 'Failed to create order' })\n    }\n  }\n\n  /**\n   * @getOrder\n   * @description Get an order by ID\n   * @paramParam id - The ID of the order\n   * @responseBody 200 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 404 - { \"message\": \"Order not found\" }\n   */\n  public async show({ params, response, request }: HttpContext) {\n    const userId = request.user?.id\n\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    const order = await this.orderService.getOrderById(params.id)\n    if (!order) {\n      return response.notFound({ message: 'Order not found' })\n    }\n\n    // Check if the order belongs to the authenticated user\n    if (order.userId !== userId) {\n      return response.forbidden({ message: 'Access denied' })\n    }\n\n    return response.ok(order)\n  }\n\n  /**\n   * @listOrders\n   * @description List orders for the authenticated user\n   * @queryParam page - Page number\n   * @queryParam limit - Number of items per page\n   * @responseBody 200 - { \"data\": [...], \"meta\": { ... } }\n   */\n  public async index({ request, response }: HttpContext) {\n    const userId = request.user?.id\n\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    // Since getOrdersByUser is not implemented in the service, we'll use prisma directly here\n    // In a real-world scenario, you should implement this method in the OrderService\n    const orders = await prisma.order.findMany({\n      where: { userId },\n      orderBy: { createdAt: 'desc' },\n      include: {\n        codeRepo: {\n          select: {\n            name: true,\n          },\n        },\n        user: {\n          select: {\n            email: true,\n          },\n        },\n      },\n    })\n\n    const total = await prisma.order.count({ where: { userId } })\n\n    return response.ok({\n      data: orders,\n      meta: {\n        total,\n      },\n    })\n  }\n\n  /**\n   * @updateOrder\n   * @description Update an order's status\n   * @paramParam id - The ID of the order\n   * @requestBody {\n   *   \"status\": \"CANCELLED\"\n   * }\n   * @responseBody 200 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Order not found\" }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { status } = updateOrderSchema.parse(request.body())\n      const userId = request.user?.id\n\n      if (!userId) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n\n      const order = await this.orderService.getOrderById(params.id)\n      if (!order) {\n        return response.notFound({ message: 'Order not found' })\n      }\n\n      if (order.userId !== userId) {\n        return response.forbidden({ message: 'Access denied' })\n      }\n\n      const updatedOrder = await this.orderService.updateOrderStatus(params.id, status)\n      return response.ok(updatedOrder)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      return response.internalServerError({ message: 'Failed to update order' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\payout_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport PayoutService from '#services/payout_service'\nimport { createPayoutSchema } from '#validators/payout'\n\n@inject()\nexport default class PayoutController {\n  constructor(protected payoutService: PayoutService) {}\n\n  /**\n   * @createPayout\n   * @description Create a new payout for a seller.\n   * @requestBody {\n   *   \"sellerProfileId\": \"seller123\",\n   *   \"amount\": 1000,\n   *   \"currency\": \"USD\"\n   *   \"payoutRequestId\": \"payout123\n   * }\n   * @responseBody 201 - {\n   *   \"id\": \"payout123\",\n   *   \"sellerProfileId\": \"seller123\",\n   *   \"amount\": 1000,\n   *   \"currency\": \"USD\",\n   *   \"status\": \"PENDING\"\n   * }\n   * @responseBody 400 - { \"error\": \"Invalid input data\" }\n   * @responseBody 404 - { \"error\": \"Seller profile not found\" }\n   * @responseBody 500 - { \"error\": \"Error creating payout\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const data = createPayoutSchema.parse(request.body())\n      const payout = await this.payoutService.createPayout(data)\n      return response.status(201).json(payout)\n    } catch (error) {\n      return response.status(400).json({ error: error.message })\n    }\n  }\n\n  /**\n   * @getPayoutById\n   * @description Retrieve a payout by its ID.\n   * @paramParam id - The ID of the payout to retrieve.\n   * @responseBody 200 - {\n   *   \"id\": \"payout123\",\n   *   \"sellerProfileId\": \"seller123\",\n   *   \"amount\": 1000,\n   *   \"currency\": \"USD\",\n   *   \"status\": \"PENDING\"\n   * }\n   * @responseBody 404 - { \"error\": \"Payout not found\" }\n   * @responseBody 500 - { \"error\": \"Error retrieving payout\" }\n   */\n  public async getById({ params, response }: HttpContext) {\n    try {\n      const payout = await this.payoutService.getPayoutById(params.id)\n      return response.json(payout)\n    } catch (error) {\n      return response.status(404).json({ error: error.message })\n    }\n  }\n\n  /**\n   * @getPayoutsBySellerProfile\n   * @description Retrieve all payouts for a specific seller profile.\n   * @paramParam sellerProfileId - The ID of the seller profile.\n   * @responseBody 200 - [\n   *   {\n   *     \"id\": \"payout123\",\n   *     \"sellerProfileId\": \"seller123\",\n   *     \"amount\": 1000,\n   *     \"currency\": \"USD\",\n   *     \"status\": \"PENDING\"\n   *   },\n   *   {\n   *     \"id\": \"payout124\",\n   *     \"sellerProfileId\": \"seller123\",\n   *     \"amount\": 2000,\n   *     \"currency\": \"USD\",\n   *     \"status\": \"COMPLETED\"\n   *   }\n   * ]\n   * @responseBody 404 - { \"error\": \"Seller profile not found\" }\n   * @responseBody 500 - { \"error\": \"Error retrieving payouts\" }\n   */\n  public async getBySellerProfile({ params, response }: HttpContext) {\n    try {\n      const payouts = await this.payoutService.getPayoutsBySellerProfile(params.sellerProfileId)\n      return response.json(payouts)\n    } catch (error) {\n      return response.status(404).json({ error: error.message })\n    }\n  }\n\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\payout_request_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport PayoutRequestService from '#services/payout_request_service'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { createPayoutRequestSchema, updatePayoutRequestSchema } from '#validators/payout_request'\nimport { PayoutRequestStatus } from '@prisma/client'\n\n@inject()\nexport default class PayoutRequestController {\n  constructor(protected payoutRequestService: PayoutRequestService) {}\n\n  public async create({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const data = createPayoutRequestSchema.parse(request.body())\n      const payoutRequest = await this.payoutRequestService.createPayoutRequest(\n        request.user.id,\n        data\n      )\n      return response.status(201).json(payoutRequest)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.abort({ message: 'Validation error', errors: error.errors }, 400)\n      }\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getSellerBalance({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const balance = await this.payoutRequestService.getSellerBalance(request.user.id)\n      return response.status(200).json(balance)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getById({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const payoutRequest = await this.payoutRequestService.getPayoutRequestById(id)\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async update({ params, request, response }: HttpContext) {\n    const { id } = params\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const data = updatePayoutRequestSchema.parse(request.body()) as {\n        status: PayoutRequestStatus\n      }\n      const payoutRequest = await this.payoutRequestService.updatePayoutRequest(id, data.status)\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.abort({ message: 'Validation error', errors: error.errors }, 400)\n      }\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async delete({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      await this.payoutRequestService.deletePayoutRequest(id)\n      return response.status(200).json({ message: 'PayoutRequest deleted successfully' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getPaginated({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n    try {\n      const payoutRequests = await this.payoutRequestService.getPaginatedPayoutRequests(page, limit)\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getAll({ response }: HttpContext) {\n    try {\n      const payoutRequests = await this.payoutRequestService.getAllPayoutRequests()\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getCurrentUserPayoutRequests({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n    try {\n      const payoutRequests = await this.payoutRequestService.getPayoutRequestsByUser(\n        request.user.id\n      )\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async processPayoutRequest({ params, request, response }: HttpContext) {\n    const { id } = params\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const { action } = request.body()\n      const payoutRequest = await this.payoutRequestService.processPayoutRequest(\n        id,\n        action,\n        request.user.id\n      )\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\profile_controller.ts</source>
<document_content>// controllers/ProfileController.ts\nimport { HttpContext } from '@adonisjs/core/http'\nimport { ProfileService } from '#services/profile_service'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { S3Facade } from '#integrations/s3/s3_facade'\nimport { updateProfileSchema, updateSellerProfileSchema } from '#validators/profile'\nimport { Multipart } from '@adonisjs/core/bodyparser'\nimport { ZodError } from 'zod'\nimport InvalidImageException from '#exceptions/invalid_image_exception'\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class ProfileController {\n  constructor(\n    protected profileService: ProfileService,\n    protected s3Facade: S3Facade\n  ) {}\n\n  /**\n   * @createProfile\n   * @description Create a new user profile\n   * @requestBody {\n   *   \"profileImg\": <file>,\n   *   \"name\": \"John Doe\",\n   *   \"phoneNumber\": \"+1234567890\"\n   * }\n   * @responseBody 201 - { \"profile\": { \"id\": \"...\", \"name\": \"...\", \"phoneNumber\": \"...\", \"userId\": \"...\" }, \"signedUrl\": \"...\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 409 - { \"message\": \"Profile already exists for this user\" }\n   */\n  async createProfile({ request, response }: HttpContext) {\n    try {\n      const userId = request.user!.id\n      const { name, phoneNumber } = request.only(['name', 'phoneNumber'])\n\n      let profileData: { name?: string; phoneNumber?: string } = { name, phoneNumber }\n      const result = await this.profileService.createProfile(userId, profileData)\n      return response.created(result)\n    } catch (error) {\n      if (error instanceof Error) {\n        return response.status(400).json({ message: error.message })\n      }\n      return response.status(500).json({ message: 'An error occurred while creating the profile' })\n    }\n  }\n\n  /**\n   * @getProfile\n   * @description Get the authenticated user's profile\n   * @responseBody 200 - { \"id\": \"...\", \"name\": \"...\", \"phoneNumber\": \"...\", \"userId\": \"...\", \"profileImgUrl\": \"...\" }\n   * @responseBody 404 - { \"message\": \"Profile not found\" }\n   */\n  async getProfile({ request, response }: HttpContext) {\n    const userId = request.user!.id\n    const profile = await this.profileService.getProfile(userId)\n    if (!profile) {\n      return response.notFound({ message: 'Profile not found' })\n    }\n    return response.ok(profile)\n  }\n\n  /**\n   * @updateSellerProfile\n   * @description Update seller profile information including bank account details\n   * @requestBody {\n   *   \"businessName\": \"My Business\",\n   *   \"businessAddress\": \"123 Business St\",\n   *   \"businessPhone\": \"+1234567890\",\n   *   \"businessEmail\": \"business@example.com\",\n   *   \"accountHolderName\": \"John Doe\",\n   *   \"accountNumber\": \"1234567890\",\n   *   \"bankName\": \"Example Bank\",\n   *   \"swiftCode\": \"EXAMPLECODE\",\n   *   \"iban\": \"GB29NWBK60161331926819\",\n   *   \"routingNumber\": \"11122233\"\n   * }\n   * @responseBody 200 - { \"message\": \"Seller profile updated successfully\", \"status\": \"success\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Seller profile update failed\" }\n   */\n  async updateSellerProfile({ request, response }: HttpContext) {\n    const user = request.user!\n\n    try {\n      const sellerProfileData = request.only([\n        'businessName',\n        'businessAddress',\n        'businessPhone',\n        'businessEmail',\n        'accountHolderName',\n        'accountNumber',\n        'bankName',\n        'swiftCode',\n        'iban',\n        'routingNumber',\n      ])\n\n      const validatedData = updateSellerProfileSchema.parse(sellerProfileData)\n\n      await prisma.$transaction(async (tx) => {\n        // Update or create SellerProfile\n        const updatedSellerProfile = await tx.sellerProfile.upsert({\n          where: { userId: user.id },\n          update: {\n            businessName: validatedData.businessName,\n            businessAddress: validatedData.businessAddress,\n            businessPhone: validatedData.businessPhone,\n            businessEmail: validatedData.businessEmail,\n          },\n          create: {\n            userId: user.id,\n            businessName: validatedData.businessName,\n            businessAddress: validatedData.businessAddress,\n            businessPhone: validatedData.businessPhone,\n            businessEmail: validatedData.businessEmail,\n          },\n        })\n\n        // Update or create BankAccount\n        await tx.bankAccount.upsert({\n          where: { sellerProfileId: updatedSellerProfile.id },\n          update: {\n            accountHolderName: validatedData.accountHolderName,\n            accountNumber: validatedData.accountNumber,\n            bankName: validatedData.bankName,\n            swiftCode: validatedData.swiftCode,\n            iban: validatedData.iban,\n            routingNumber: validatedData.routingNumber,\n          },\n          create: {\n            sellerProfileId: updatedSellerProfile.id,\n            accountHolderName: validatedData.accountHolderName,\n            accountNumber: validatedData.accountNumber,\n            bankName: validatedData.bankName,\n            swiftCode: validatedData.swiftCode,\n            iban: validatedData.iban,\n            routingNumber: validatedData.routingNumber,\n          },\n        })\n      })\n\n      return response.status(200).json({\n        message: 'Seller profile updated successfully',\n        status: 'success',\n      })\n    } catch (error) {\n      if (error instanceof ZodError) {\n        return response.status(400).json({\n          message: 'Validation failed',\n          errors: error.errors,\n        })\n      } else {\n        logger.error('Seller profile update failed:', error)\n        return response.status(500).json({ message: 'Seller profile update failed' })\n      }\n    }\n  }\n\n  /*  /**\n   * @updateProfile\n   * @description Update user profile information and optionally upload a profile image\n   * @requestBody {\n   *   \"name\": \"John Doe\",\n   *   \"phoneNumber\": \"+1234567890\",\n   *   \"profileImg\": File (optional)\n   * }\n   * @responseBody 200 - { \"message\": \"Profile updated successfully\", \"status\": \"success\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Profile update failed\" }\n   */\n  async updateProfile({ request, response }: HttpContext) {\n    const user = request.user!\n    console.log(request.headers())\n\n    try {\n      const { name, phoneNumber } = request.only(['name', 'phoneNumber'])\n      updateProfileSchema.parse({ name, phoneNumber })\n\n      if (!request.multipart) {\n        await this.updateProfileWithoutImage(user.id, name, phoneNumber)\n      } else {\n        await this.updateProfileWithImage(user.id, name, phoneNumber, request.multipart)\n      }\n\n      return response.status(200).json({\n        message: 'Profile updated successfully',\n        status: 'success',\n      })\n    } catch (error) {\n      if (error instanceof ZodError) {\n        return response.status(400).json({\n          message: 'Validation failed',\n        })\n      }\n      if (error instanceof InvalidImageException) {\n        return response.status(400).json({ message: 'Invalid image format' })\n      } else {\n        logger.error('Profile update failed:', error)\n      }\n      return response.status(500).json({ message: 'Profile update failed' })\n    }\n  }\n\n  private async updateProfileWithoutImage(userId: string, name: string, phoneNumber: string) {\n    await prisma.profile.upsert({\n      where: { userId },\n      update: { name, phoneNumber },\n      create: { name, phoneNumber, userId },\n    })\n  }\n\n  private updateProfileWithImage(\n    userId: string,\n    name: string,\n    phoneNumber: string,\n    multipart: Multipart\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      multipart.onFile('profileImg', {}, async (part) => {\n        try {\n          // validate if it is an image\n          if (!part.headers['content-type']?.startsWith('image/')) {\n            return reject(new InvalidImageException())\n          }\n          const buffer = await this.readFileBuffer(part)\n          const fileType = part.headers['content-type']\n\n          await prisma.$transaction(async (tx) => {\n            const { media } = await this.s3Facade.uploadFile(buffer, fileType, tx, 'profile-images')\n            await tx.profile.upsert({\n              where: { userId },\n              update: { name, phoneNumber, profileImg: media.url },\n              create: { userId, name, phoneNumber, profileImg: media.url },\n            })\n          })\n\n          resolve()\n        } catch (error) {\n          console.error('Profile image upload error:', error)\n          reject(error)\n        }\n      })\n\n      multipart.process()\n    })\n  }\n\n  private async readFileBuffer(part: any): Promise<Buffer> {\n    part.pause()\n    const chunks: Buffer[] = []\n    for await (const chunk of part) {\n      chunks.push(chunk)\n    }\n    return Buffer.concat(chunks)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\repos_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { z } from 'zod'\nimport { createRepoSchema, updateRepoSchema } from '#validators/repo'\nimport { Language, Visibility } from '@prisma/client'\nimport RepoService from '#services/repo_service'\nimport CodeCheckService from '#services/code_check_service'\nimport CodeRepoSearchService, { SearchCriteria } from '#services/repo_search_service'\nimport logger from '@adonisjs/core/services/logger'\nimport RepoAccessService from '#services/repo_access_service'\n\nconst searchSchema = z.object({\n  query: z.string().optional(),\n  tags: z\n    .union([z.string(), z.array(z.string())])\n    .optional()\n    .transform((val) => (Array.isArray(val) ? val : val ? [val] : undefined)),\n  minPrice: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(0).optional()),\n  maxPrice: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(0).optional()),\n  language: z.nativeEnum(Language).optional(),\n  page: z\n    .string()\n    .default('1')\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(1).optional()),\n  pageSize: z\n    .string()\n    .default('10')\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(1).optional()),\n})\n\n@inject()\nexport default class RepoController {\n  constructor(\n    protected repoService: RepoService,\n    protected codeRepoSearchService: CodeRepoSearchService,\n    protected repoAccessService: RepoAccessService,\n    protected codeCheckService: CodeCheckService\n  ) {}\n\n  /**\n   * Create a new Repo.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam {Object} data - The data for the new Repo.\n   * @responseBody 201 - { id: string, name: string, ... } - The created repo\n   * @responseBody 400 - { message: string, errors?: Object[] } - Validation error details\n   * @responseBody 401 - { message: string } - Unauthorized error\n   */\n  public async create({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n\n    try {\n      const data = createRepoSchema.parse(request.body())\n\n      const repo = await this.repoService.createRepo({\n        userId: request.user.id,\n        ...data,\n        sourceJs: '',\n        sourceCss: '',\n        status: 'pending',\n      })\n      return response.created(repo)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Validation error', errors: error.errors })\n      }\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve a Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @responseBody 200 - { repo: Object, repoCodeCheck: Object|null, hasAccess: boolean }\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getById({ params, request, response }: HttpContext) {\n    const user = request.user\n    if (!user) throw new UnAuthorizedException('User not found in request object')\n    const { id } = params\n    try {\n      return await prisma.$transaction(async (tx) => {\n        const repo = await this.repoService.getRepoById(id)\n        if (!repo) {\n          return response.notFound({ message: 'Repo not found' })\n        }\n        \n        const hasAccess = await this.repoAccessService.hasAccess(user.id, id, tx)\n        const isOwner = repo.userId === user.id\n        const isAdmin = user.role === 'ADMIN'\n\n        if (!hasAccess && !isOwner && !isAdmin) {\n          return response.forbidden({ message: 'You do not have access to this repository' })\n        }\n\n        const repoCodeCheck = await tx.codeCheck.findFirst({\n          where: {\n            repoId: id,\n          },\n          orderBy: {\n            createdAt: 'desc',\n          },\n        })\n\n        return response.ok({\n          repo,\n          repoCodeCheck: repoCodeCheck ?? null,\n        })\n      })\n    } catch (error) {\n      console.error('Error retrieving repo:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving the repo',\n      })\n    }\n  }\n\n  /**\n   * Retrieve a public Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @responseBody 200 - { repo: Object, repoCodeCheck: Object|null }\n   * @responseBody 404 - { message: string } - Not found error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getByIdPublic({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const repo = await this.repoService.getRepoByIdPublic(id)\n      if (!repo) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n\n      const repoCodeCheck = await prisma.codeCheck.findFirst({\n        where: {\n          repoId: id,\n        },\n        orderBy: {\n          createdAt: 'desc',\n        },\n      })\n\n      // Transform the repo object to match the expected format\n      const transformedRepo = {\n        ...repo,\n        tags: repo.tags?.map(t => ({ tag: { name: t.tag.name } }))\n      }\n\n      return response.ok({\n        repo: transformedRepo,\n        repoCodeCheck: repoCodeCheck ?? null,\n      })\n    } catch (error) {\n      console.error('Error retrieving public repo:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving the repo',\n      })\n    }\n  }\n\n  /**\n   * Update a Repo.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @bodyParam {Object} data - The data to update the Repo.\n   * @responseBody 200 - { id: string, name: string, ... } - The updated repo\n   * @responseBody 400 - { message: string, errors?: Object[] } - Validation error details\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   */\n  public async update({ params, request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { id } = params\n\n    try {\n      const data = updateRepoSchema.parse(request.body())\n\n      const repo = await this.repoService.getRepoById(id, request.user.id)\n      if (!repo || repo.deletedAt) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n      if (repo.userId !== request.user.id) {\n        return response.forbidden({ message: 'You do not have permission to update this repo' })\n      }\n\n      const updatedRepo = await this.repoService.updateRepo(id, data)\n      return response.ok(updatedRepo)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Validation error', errors: error.errors })\n      }\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Delete a Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo to delete.\n   * @responseBody 200 - { message: string } - Success message\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   */\n  public async delete({ request, params, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { id } = params\n    try {\n      const repo = await this.repoService.getRepoById(id, request.user.id)\n      if (!repo) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n      \n      // For admin users, we'll allow deletion regardless of ownership\n      if (request.user.role !== 'ADMIN' && repo.userId !== request.user.id) {\n        return response.forbidden({ message: 'You do not have permission to delete this repo' })\n      }\n      await this.repoService.softDeleteRepo(id)\n      return response.ok({ message: 'Repo deleted successfully' })\n    } catch (error) {\n      console.error('Error in delete method:', error)\n      if (error instanceof Error && error.message === 'Repo not found') {\n        return response.notFound({ message: 'Repo not found' })\n      }\n      return response.internalServerError({ message: 'An unexpected error occurred' })\n    }\n  }\n\n  /**\n   * Retrieve Repos by user ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} userId - The user ID to filter by.\n   * @responseBody 200 - Array of repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   */\n  public async getByUser({ params, request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { userId } = params\n\n    if (userId !== request.user.id && request.user.role !== 'ADMIN') {\n      return response.forbidden({ message: 'You do not have permission to view these repos' })\n    }\n\n    try {\n      const repos = await this.repoService.getReposByUser(userId)\n      return response.ok(repos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve Repos for the authenticated user.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - Array of repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   * @responseBody 401 - { message: string } - Unauthorized error\n   */\n  public async getByUserSession({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n\n    try {\n      const repos = await this.repoService.getReposByUser(request.user.id)\n      return response.ok(repos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve repos that the authenticated user has access to, including repo data.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { accessibleRepos: Object[] }\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getByUserAccessed({ request, response }: HttpContext) {\n    if (!request.user) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const accessibleRepos = await prisma.$transaction(async (tx) => {\n        const accessibleRepoIds = await this.repoAccessService.getUserAccessibleRepos(request.user!.id, tx)\n        \n        return tx.codeRepo.findMany({\n          where: {\n            id: { in: accessibleRepoIds }\n          },\n          select: {\n            id: true,\n            name: true,\n            description: true,\n            language: true,\n            price: true,\n            createdAt: true,\n            updatedAt: true,\n            sourceCss: true,\n            sourceJs: true,\n          }\n        })\n      })\n\n      return response.ok({ accessibleRepos })\n    } catch (error) {\n      logger.error('Error retrieving accessible repos:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving accessible repos',\n      })\n    }\n  }\n\n  /**\n   * Retrieve featured repos.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} [limit=5] - The number of featured repos to return.\n   * @responseBody 200 - Array of featured repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   */\n  public async getFeatured({ request, response }: HttpContext) {\n    const limit = request.input('limit', 5)\n\n    try {\n      const featuredRepos = await this.repoService.getFeaturedRepos(limit)\n      return response.ok(featuredRepos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Search for code repositories based on various criteria.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {string} [query] - Search query for name and description\n   * @queryParam {string|string[]} [tags] - Array of tag names to filter by\n   * @queryParam {number} [minPrice] - Minimum price\n   * @queryParam {number} [maxPrice] - Maximum price\n   * @queryParam {Language} [language] - Filter by programming language\n   * @queryParam {number} [page=1] - Page number for pagination\n   * @queryParam {number} [pageSize=10] - Number of items per page\n   * @responseBody 200 - { data: Array<Object>, meta: { total: number, page: number, pageSize: number, lastPage: number } }\n   * @responseBody 400 - { message: string, errors?: Object[] } - Bad request or validation error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async search({ request, response }: HttpContext) {\n    try {\n      const validatedData = searchSchema.parse(request.qs())\n\n      const searchCriteria: SearchCriteria = {\n        query: validatedData.query,\n        tags: validatedData.tags,\n        minPrice: validatedData.minPrice,\n        maxPrice: validatedData.maxPrice,\n        language: validatedData.language,\n      }\n\n      const userId = request.user?.id\n\n      const result = await this.codeRepoSearchService.search(\n        searchCriteria,\n        userId,\n        validatedData.page,\n        validatedData.pageSize\n      )\n\n      return response.ok(result)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid search criteria', errors: error.errors })\n      }\n      return response.internalServerError({\n        message: 'An error occurred while processing the search',\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\reviews_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { ReviewService } from '#services/review_service'\nimport { z } from 'zod'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { VoteType } from '@prisma/client'\n\nconst createReviewSchema = z.object({\n  content: z.string().min(1).max(1000),\n  repoId: z.string(),\n  rating: z.number().int().min(1).max(5),\n})\n\nconst updateReviewSchema = z.object({\n  content: z.string().min(1).max(1000).optional(),\n  rating: z.number().int().min(1).max(5).optional(),\n})\n\nconst paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  perPage: z.coerce.number().int().positive().max(100).default(10),\n})\n\n//const voteSchema = z.object({\n//  type: z.nativeEnum(VoteType),\n//})\n\n/**\n * Controller class for handling Review operations.\n */\n@inject()\nexport default class ReviewController {\n  constructor(protected reviewService: ReviewService) {}\n\n  /**\n   * @createReview\n   * @description Create a new review for a repository.\n   * @route POST /reviews\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"This is a great repository!\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5\n   * }\n   * @responseBody 201 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a great repository!\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\"\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const data = createReviewSchema.parse(request.all())\n      const review = await this.reviewService.createReview({ ...data, userId })\n      return response.status(201).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getReviewById\n   * @description Retrieve a review by its ID.\n   * @route GET /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a great repository!\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async getById({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.getReviewById(id)\n      return response.status(200).json(review)\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @getPaginatedReviewsByRepo\n   * @description Get paginated reviews for a specific repository.\n   * @route GET /repo/:repoId/reviews\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} page - Page number for pagination.\n   * @queryParam {number} perPage - Number of items per page.\n   * @responseBody 200 - {\n   *   \"data\": [\n   *     {\n   *       \"id\": \"cuid0987654321\",\n   *       \"content\": \"This is a great repository!\",\n   *       \"userId\": \"user123\",\n   *       \"repoId\": \"cuid1234567890\",\n   *       \"rating\": 5,\n   *       \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *       \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *       \"upvotes\": 10,\n   *       \"downvotes\": 2\n   *     },\n   *     ...\n   *   ],\n   *   \"meta\": {\n   *     \"total\": 100,\n   *     \"page\": 1,\n   *     \"perPage\": 10,\n   *     \"lastPage\": 10\n   *   }\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async getPaginatedReviewsByRepo({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      if (!id) throw new Error('Invalid repo ID')\n      const { page, perPage } = paginationSchema.parse(request.qs())\n      const reviews = await this.reviewService.getPaginatedReviewsByRepo(id, page, perPage)\n      return response.status(200).json(reviews)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateReview\n   * @description Update a specific review.\n   * @route PUT /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"Updated review content\",\n   *   \"rating\": 4\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"Updated review content\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 4,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      const data = updateReviewSchema.parse(request.all())\n      const review = await this.reviewService.updateReview(id, data)\n      return response.status(200).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @revertReviewFlag\n   * @description Revert the flag on a review to NONE.\n   * @route PUT /reviews/:id/revert\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a review\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"flag\": \"NONE\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async revertFlag({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.revertFlag(id)\n      return response.status(200).json(review)\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @deleteReview\n   * @description Soft delete a specific review.\n   * @route DELETE /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { \"message\": \"Review deleted successfully\", \"review\": {...} }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async delete({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.deleteReview(id)\n      return response.status(200).json({ message: 'Review deleted successfully', review })\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @getAllFlaggedReviews\n   * @description Get all flagged reviews.\n   * @route GET /reviews/flagged\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - [\n   *   {\n   *     \"id\": \"cuid0987654321\",\n   *     \"content\": \"This is a flagged review\",\n   *     \"userId\": \"user123\",\n   *     \"repoId\": \"cuid1234567890\",\n   *     \"rating\": 5,\n   *     \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *     \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *     \"flag\": \"INAPPROPRIATE_LANGUAGE\"\n   *   },\n   *   ...\n   * ]\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const reviews = await this.reviewService.getAllFlaggedReviews()\n      return response.status(200).json(reviews)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @handleVote\n   * @description Handle upvote or downvote for a review.\n   * @route POST /reviews/:id/vote\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"type\": \"UPVOTE\" | \"DOWNVOTE\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a review\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 11,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async handleVote({ params, request, response }: HttpContext) {\n    try {\n      const { id, vote } = params\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const voteType = vote === 'upvote' ? VoteType.UPVOTE : VoteType.DOWNVOTE\n      const review = await this.reviewService.handleVote(id, userId, voteType)\n      return response.status(200).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      if (error instanceof UnAuthorizedException) {\n        return response.status(401).json({ message: error.message })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\seller_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport SellerService from '#services/seller_service'\nimport {\n  createSellerProfileSchema,\n  updateSellerProfileSchema,\n  createPayoutRequestSchema,\n} from '#validators/seller'\n\n@inject()\nexport default class SellerController {\n  constructor(protected sellerService: SellerService) {}\n\n  /**\n   * @applyForSellerAccount\n   * @description Apply for a seller account including bank account details\n   * @requestBody {\n   *   \"businessName\": \"string\",\n   *   \"businessAddress\": \"string\",\n   *   \"businessPhone\": \"string\",\n   *   \"businessEmail\": \"string\",\n   *   \"accountHolderName\": \"string\",\n   *   \"accountNumber\": \"string\",\n   *   \"bankName\": \"string\",\n   *   \"swiftCode\": \"string\",\n   *   \"iban\": \"string\",\n   *   \"routingNumber\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Application submitted successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 401 - { \"message\": \"User not authenticated\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while processing the request\" }\n   */\n  public async applyForSellerAccount({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const data = createSellerProfileSchema.parse(request.body())\n\n      const profile = await this.sellerService.applyForSellerAccount(userId, data)\n\n      return response.ok({\n        message: 'Application submitted successfully',\n        profile,\n      })\n    } catch (error) {\n      if (error.name === 'ZodError') {\n        return response.badRequest({\n          message: 'Invalid input data',\n          errors: error.errors,\n        })\n      }\n\n      console.error('Error in applyForSellerAccount:', error)\n      return response.internalServerError({\n        message: 'An error occurred while processing the request',\n      })\n    }\n  }\n\n  /**\n   * @updateProfile\n   * @description Update the current seller's profile\n   * @requestBody {\n   *   \"businessName\": \"string\",\n   *   \"businessAddress\": \"string\",\n   *   \"businessPhone\": \"string\",\n   *   \"businessEmail\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Profile updated successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async updateProfile({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const data = updateSellerProfileSchema.parse(request.body())\n      const profile = await this.sellerService.updateSellerProfile(userId, data)\n      return response.ok({ message: 'Profile updated successfully', profile })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * @getBalance\n   * @description Get the current seller's balance\n   * @responseBody 200 - { \"balance\": number }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async getBalance({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized('User not authenticated')\n    }\n\n    const balance = await this.sellerService.getSellerBalance(userId)\n    return response.ok({ balance })\n  }\n\n  /**\n   * @requestPayout\n   * @description Request a payout for the current seller\n   * @requestBody {\n   *   \"amount\": number\n   * }\n   * @responseBody 201 - { \"message\": \"Payout request submitted\", \"request\": PayoutRequest }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" or \"Insufficient balance\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async requestPayout({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const { amount } = createPayoutRequestSchema.parse(request.body())\n      const payoutRequest = await this.sellerService.requestPayout(userId, amount)\n      return response.created({ message: 'Payout request submitted', request: payoutRequest })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * @getPayoutHistory\n   * @description Get the payout history for the current seller\n   * @responseBody 200 - { \"payouts\": PayoutRequest[] }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async getPayoutHistory({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized('User not authenticated')\n    }\n\n    const payouts = await this.sellerService.getPayoutHistory(userId)\n    return response.ok({ payouts })\n  }\n\n  /**\n   * @uploadIdentityDocument\n   * @description Upload or update the identity document for the current seller\n   * @requestBody {\n   *   \"documentUrl\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Document uploaded successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async uploadIdentityDocument({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const { documentUrl } = request.body()\n      if (!documentUrl) {\n        return response.badRequest({ message: 'Document URL is required' })\n      }\n\n      const profile = await this.sellerService.uploadIdentityDocument(userId, documentUrl)\n      return response.ok({ message: 'Document uploaded successfully', profile })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  public async getDashboardData({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const days = request.input('days', 30) // Allow specifying days, default to 30\n      const dashboardData = await this.sellerService.getDashboardData(userId, days)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching dashboard data:', error)\n      return response.internalServerError({\n        message: 'An error occurred while fetching dashboard data',\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\supports_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport SupportTicketService from '#services/support_service'\nimport { inject } from '@adonisjs/core'\nimport { SupportTicketStatus } from '@prisma/client'\n\n@inject()\nexport default class SupportController {\n  constructor(protected supportTicketService: SupportTicketService) {}\n\n  /**\n   * @createTicket\n   * @description Create a new support ticket.\n   * @bodyParam email string - The user's email address.\n   * @bodyParam title string - The title of the support ticket.\n   * @bodyParam content string - The content of the support ticket.\n   * @bodyParam type string - The type of the support ticket.\n   * @responseBody 201 - { \"message\": \"Support ticket created successfully\", \"ticket\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async createTicket({ request, response }: HttpContext) {\n    try {\n      const { email, title, content, type } = request.only(['email', 'title', 'content', 'type'])\n      const ticket = await this.supportTicketService.createTicket(email, title, content, type)\n      return response.status(201).json({ message: 'Support ticket created successfully', ticket })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getPaginatedTickets\n   * @description Get paginated support tickets.\n   * @queryParam page number - The page number for pagination.\n   * @queryParam limit number - The number of tickets per page.\n   * @responseBody 200 - { \"data\": [...], \"meta\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  //async getPaginatedTickets({ request, response }: HttpContext) {\n  //  try {\n  //    const page = request.input('page', 1)\n  //    const limit = request.input('limit', 10)\n  //    const { data, meta } = await this.supportTicketService.getPaginatedTickets(Number(page), Number(limit))\n  //    return response.ok({ data, meta })\n  //  } catch (error) {\n  //    return response.status(400).json({ message: error.message })\n  //  }\n  //}\n\n  /**\n   * @getAllTickets\n   * @description Get all support tickets.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getAllTickets({ response }: HttpContext) {\n    try {\n      const tickets = await this.supportTicketService.getAllTickets()\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketById\n   * @description Get a support ticket by ID.\n   * @paramParam id string - The ID of the support ticket.\n   * @responseBody 200 - { \"ticket\": {...} }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketById({ params, response }: HttpContext) {\n    try {\n      const ticket = await this.supportTicketService.getTicketById(params.id)\n      if (!ticket) {\n        return response.notFound({ message: 'Ticket not found' })\n      }\n      return response.ok(ticket)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByTitle\n   * @description Get support tickets by title.\n   * @queryParam title string - The title to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByTitle({ request, response }: HttpContext) {\n    try {\n      const title = request.input('title')\n      const tickets = await this.supportTicketService.getTicketsByTitle(title)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByEmail\n   * @description Get support tickets by email.\n   * @queryParam email string - The email to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByEmail({ request, response }: HttpContext) {\n    try {\n      const email = request.input('email')\n      const tickets = await this.supportTicketService.getTicketsByEmail(email)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByStatus\n   * @description Get support tickets by status.\n   * @queryParam status string - The status to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByStatus({ request, response }: HttpContext) {\n    try {\n      const status = request.input('status')\n      const tickets = await this.supportTicketService.getTicketsByStatus(status)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateTicket\n   * @description Update a support ticket status.\n   * @paramParam id string - The ID of the support ticket.\n   * @bodyParam status string - The new status of the support ticket.\n   * @responseBody 200 - { \"ticket\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   */\n  async updateTicket({ params, request, response }: HttpContext) {\n    try {\n      const { status } = request.only(['status'])\n      if (!Object.values(SupportTicketStatus).includes(status)) {\n        return response.badRequest({ message: 'Invalid status provided' })\n      }\n      const ticket = await this.supportTicketService.updateTicket(params.id, status)\n      if (!ticket) {\n        return response.notFound({ message: 'Ticket not found' })\n      }\n      return response.ok({ ticket })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @deleteTicket\n   * @description Delete a support ticket.\n   * @paramParam id string - The ID of the support ticket.\n   * @responseBody 200 - { \"message\": \"Ticket deleted successfully\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   */\n  //async deleteTicket({ params, response }: HttpContext) {\n  //  try {\n  //    const result = await this.supportTicketService.deleteTicket(params.id)\n  //    if (!result) {\n  //      return response.notFound({ message: 'Ticket not found' })\n  //    }\n  //    return response.ok({ message: 'Ticket deleted successfully' })\n  //  } catch (error) {\n  //    return response.status(400).json({ message: error.message })\n  //  }\n  //}\n\n  /**\n   * @sendDefaultEmail\n   * @description Send a default email notification.\n   * @bodyParam email string - The email address to send the notification to.\n   * @responseBody 200 - { \"message\": \"Email sent successfully\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async sendDefaultEmail({ request, response }: HttpContext) {\n    try {\n      const { email } = request.only(['email'])\n      await this.supportTicketService.sendDefaultEmail(email)\n      return response.ok({ message: 'Email sent successfully' })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\users_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\n// import UserService from '#services/user_service';\nimport { inject } from '@adonisjs/core'\n// import { Exception } from '@adonisjs/core/exceptions';\nimport { UserService } from '#services/user_service'\n\n/**\n * Controller class for handling User operations.\n */\n@inject()\nexport default class UserController {\n  constructor(protected userService: UserService) {}\n\n  /**\n   * Create a new User.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam data - The data for the new User.\n   */\n  public async create({ request, response }: HttpContext) {\n    const data = request.only(['email', 'password', 'fullname', 'role'])\n\n    try {\n      const user = await this.userService.createUser(data)\n      return response.status(201).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve a User by email.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   */\n  public async getByEmail({ params, response }: HttpContext) {\n    const { email } = params\n\n    try {\n      const user = await this.userService.getUserByEmail(email)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a User.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   * @bodyParam data - The data to update the User.\n   */\n  public async update({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only(['email', 'password', 'fullname', 'role'])\n\n    try {\n      const user = await this.userService.updateUser(email, data)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Delete a User by email (soft delete).\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   */\n  public async delete({ params, response }: HttpContext) {\n    const { email } = params\n\n    try {\n      const user = await this.userService.deleteUser(email)\n      return response.status(200).json({ message: 'User deleted successfully', user })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve all Users.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const users = await this.userService.getAllUsers()\n      return response.status(200).json(users)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve paginated Users.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam page - The page number for pagination.\n   * @queryParam limit - The number of items per page.\n   */\n  public async getPaginated({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n\n    try {\n      const { users, total } = await this.userService.getPaginatedUsers(page, limit)\n      return response.status(200).json({ users, total })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a User's profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   * @bodyParam data - The profile data to update.\n   */\n  public async updateProfile({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only([\n      'fullname',\n      'businessName',\n      'businessAddress',\n      'businessPhone',\n      'businessEmail',\n    ])\n\n    try {\n      const user = await this.userService.updateUserProfile(email, data)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Ban a user by email.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam email - The email of the user to ban.\n   */\n  public async ban({ request, response }: HttpContext) {\n    const { email } = request.only(['email'])\n\n    try {\n      const user = await this.userService.banUser(email)\n      return response.status(200).json({ message: 'User banned successfully', user })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\handler.ts</source>
<document_content>import app from '@adonisjs/core/services/app'\nimport { HttpContext, ExceptionHandler } from '@adonisjs/core/http'\n\nexport default class HttpExceptionHandler extends ExceptionHandler {\n  /**\n   * In debug mode, the exception handler will display verbose errors\n   * with pretty printed stack traces.\n   */\n  protected debug = !app.inProduction\n\n  /**\n   * The method is used for handling errors and returning\n   * response to the client\n   */\n  async handle(error: unknown, ctx: HttpContext) {\n    return super.handle(error, ctx)\n  }\n\n  /**\n   * The method is used to report error to the logging service or\n   * the third party error monitoring service.\n   *\n   * @note You should not attempt to send a response from this method.\n   */\n  async report(error: unknown, ctx: HttpContext) {\n    return super.report(error, ctx)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\invalid_image_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class InvalidImageException extends Exception {\n  static status = 400\n  static code = 'E_INVALID_IMAGE'\n  static message = 'Invalid image format'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\invalid_session_id_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class InvalidSessionIdException extends Exception {\n  static status = 500\n  static code = 'E_INVALID_SESSION_ID'\n  static message = 'Invalid session ID'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\media_not_found_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class MediaNotFoundException extends Exception {\n  static status = 404\n  static code = 'E_MEDIA_NOT_FOUND'\n  static message = 'The requested media file was not found'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\un_authorized_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class UnAuthorizedException extends Exception {\n  static status = 401\n  static code = 'E_UNAUTHORIZED'\n  static message = 'Unauthorized access'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\user_not_verified_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class UserNotVerifiedException extends Exception {\n  static status = 403\n  static code = 'E_USER_NOT_VERIFIED'\n  static message = 'The user account is not verified'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\factories\user_factory.ts</source>
<document_content>import { hash } from '@node-rs/argon2'\nimport { PrismaTransactionalClient, prisma } from '#services/prisma_service'\nimport { generateIdFromEntropySize } from 'lucia'\nimport {\n  BankAccount,\n  Role,\n  SellerVerificationStatus,\n  User,\n  Profile,\n  SellerProfile,\n  Prisma,\n  PrismaClient,\n} from '@prisma/client'\nimport { z } from 'zod'\n//import logger from '@adonisjs/core/services/logger'\nimport { PrismaPromise } from '@prisma/client/runtime/library'\n//import { logger } from '#services/logger_service'\n\n// Zod schemas for input validation\nconst userSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  fullname: z.string().min(2),\n})\n\nconst sellerSchema = userSchema.extend({\n  businessName: z.string().optional(),\n  businessAddress: z.string().optional(),\n  businessPhone: z.string().optional(),\n  identityDoc: z.string().optional(),\n})\n\nconst bankAccountSchema = z.object({\n  accountHolderName: z.string().min(1),\n  accountNumber: z.string().min(1),\n  bankName: z.string().min(1),\n  swiftCode: z.string().min(1),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n})\n\ntype UserFactoryData = z.infer<typeof userSchema>\ntype SellerFactoryData = z.infer<typeof sellerSchema>\ntype BankAccountData = z.infer<typeof bankAccountSchema>\n\nexport class UserFactory {\n  /**\n   * Create a regular user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createUser(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.USER }, tx)\n    } catch (error) {\n      console.error('Error creating user', error)\n      throw new Error('Failed to create user')\n    }\n  }\n\n  /**\n   * Create a seller user with associated regular profile and seller profile\n   * @param {SellerFactoryData} data - Seller data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile, sellerProfile: SellerProfile}>} Created user, regular profile, and seller profile\n   */\n  static async createSeller(\n    data: SellerFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile; sellerProfile: SellerProfile }> {\n    try {\n      const validatedData = sellerSchema.parse(data)\n\n      const createSellerOperation = async (ptx: PrismaTransactionalClient) => {\n        const { user, profile } = await this.createBaseUser(\n          { ...validatedData, role: Role.SELLER },\n          ptx\n        )\n        const sellerProfile = await ptx.sellerProfile.create({\n          data: {\n            userId: user.id,\n            businessName: validatedData.businessName ?? '',\n            businessAddress: validatedData.businessAddress ?? '',\n            businessPhone: validatedData.businessPhone ?? '',\n            businessEmail: validatedData.email ?? '',\n            identityDoc: validatedData.identityDoc,\n            verificationStatus: SellerVerificationStatus.IDLE,\n          },\n        })\n        return { user, profile, sellerProfile }\n      }\n\n      return tx ? createSellerOperation(tx) : prisma.$transaction(createSellerOperation)\n    } catch (error) {\n      console.error('Error creating seller', error)\n      throw new Error('Failed to create seller')\n    }\n  }\n\n  /**\n   * Add a bank account to a seller profile\n   * @param {string} sellerId - ID of the seller\n   * @param {BankAccountData} bankAccountData - Bank account data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<BankAccount>} Created bank account\n   */\n  static async addBankAccount(\n    sellerId: string,\n    bankAccountData: BankAccountData,\n    tx?: PrismaTransactionalClient\n  ): Promise<BankAccount> {\n    try {\n      const validatedData = bankAccountSchema.parse(bankAccountData)\n\n      const addBankAccountOperation = async (ptx: PrismaTransactionalClient) => {\n        const sellerProfile = await ptx.sellerProfile.findUnique({ where: { userId: sellerId } })\n        if (!sellerProfile) {\n          throw new Error('Seller profile not found')\n        }\n        return ptx.bankAccount.create({\n          data: {\n            ...validatedData,\n            sellerProfileId: sellerProfile.id,\n          },\n        })\n      }\n\n      return tx ? addBankAccountOperation(tx) : prisma.$transaction(addBankAccountOperation)\n    } catch (error) {\n      console.error('Error adding bank account', error, sellerId)\n      throw new Error('Failed to add bank account')\n    }\n  }\n\n  /**\n   * Create a moderator user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createModerator(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.MODERATOR }, tx)\n    } catch (error) {\n      console.error('Error creating moderator', error)\n      throw new Error('Failed to create moderator')\n    }\n  }\n\n  /**\n   * Create an admin user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createAdmin(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.ADMIN }, tx)\n    } catch (error) {\n      console.error('Error creating admin', error)\n      throw new Error('Failed to create admin')\n    }\n  }\n\n  /**\n   * Private method to create a base user with a profile\n   * @param {UserFactoryData & { role: Role }} data - User data with role\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  private static async createBaseUser(\n    data: UserFactoryData & { role: Role },\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    const createUserOperation = async (ptx: PrismaTransactionalClient) => {\n      const existingUser = await ptx.user.findUnique({\n        where: { email: data.email },\n      })\n\n      if (existingUser) {\n        throw new Error(`User with email ${data.email} already exists`)\n      }\n\n      const passwordHash = await this.hashPassword(data.password)\n      const id = generateIdFromEntropySize(32)\n\n      const user = await ptx.user.create({\n        data: { id, email: data.email, passwordHash, role: data.role },\n      })\n      const profile = await ptx.profile.create({\n        data: { userId: id, name: data.fullname },\n      })\n\n      return { user, profile }\n    }\n\n    return tx ? createUserOperation(tx) : prisma.$transaction(createUserOperation)\n  }\n\n  /**\n   * Private method to hash a password\n   * @param {string} password - Plain text password\n   * @returns {Promise<string>} Hashed password\n   */\n  private static async hashPassword(password: string): Promise<string> {\n    return hash(password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\document_reader.ts</source>
<document_content>// import { TextLoader } from \"langchain/document_loaders/fs/text\";\n// import { PDFLoader } from \"langchain/document_loaders/fs/pdf\";\nimport { PDFLoader } from '@langchain/community/document_loaders/fs/pdf'\n\nconst doc = 'code-guideline.pdf'\nconst loader = new PDFLoader(`./public/assets/${doc}`, {\n  splitPages: false,\n})\n\nexport const pdfDocReader = await loader.load()\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\openai.ts</source>
<document_content>import { ChatOpenAI } from '@langchain/openai'\nimport env from '#start/env'\n\nexport const openaiModel = new ChatOpenAI({\n  apiKey: env.get('OPENAI_API_KEY'),\n  model: 'gpt-4o',\n  temperature: 0.3,\n  maxTokens: 1000,\n  topP: 0.9,\n  frequencyPenalty: 0.2,\n  presencePenalty: 0.2,\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\text_splitters.ts</source>
<document_content>import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter'\nimport { Document } from 'langchain/document'\n\nconst recursiveSplitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 10,\n  chunkOverlap: 1,\n})\n\nexport const recursiveSplitterOutput = async (text: any) => {\n  return await recursiveSplitter.splitDocuments([new Document({ pageContent: text })])\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\rabbitmq\rabbitmq_service.ts</source>
<document_content>//import { inject } from '@adonisjs/core'\nimport amqp, { Connection, Channel, ConsumeMessage } from 'amqplib'\nimport env from '#start/env'\n\n//@inject()\nexport default class RabbitMQService {\n  private connection: Connection | null = null\n  private channel: Channel | null = null\n\n  constructor() {}\n\n  /**\n   * Initialize the RabbitMQ connection and channel\n   */\n  public async init() {\n    try {\n      this.connection = await amqp.connect(env.get('RABBITMQ_URL'))\n      this.channel = await this.connection.createChannel()\n      console.log('Connected to RabbitMQ')\n    } catch (error) {\n      console.error('Failed to connect to RabbitMQ:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Publish a message to a queue\n   * @param {string} queue - The name of the queue\n   * @param {object} message - The message to publish\n   */\n  public async publishMessage(queue: string, message: object) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    await this.channel.assertQueue(queue, { durable: true })\n    this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true })\n  }\n\n  /**\n   * Consume messages from a queue\n   * @param {string} queue - The name of the queue\n   * @param {function} callback - The callback function to process messages\n   */\n  public async consume(queue: string, callback: (msg: ConsumeMessage | null) => void) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    await this.channel.assertQueue(queue, { durable: true })\n    await this.channel.consume(queue, callback, { noAck: false })\n  }\n\n  /**\n   * Acknowledge a message\n   * @param {ConsumeMessage} message - The message to acknowledge\n   */\n  public ack(message: ConsumeMessage) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    this.channel.ack(message)\n  }\n\n  /**\n   * Negatively acknowledge a message (requeue)\n   * @param {ConsumeMessage} message - The message to negatively acknowledge\n   */\n  public nack(message: ConsumeMessage) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    this.channel.nack(message, false, true)\n  }\n\n  /**\n   * Close the RabbitMQ connection\n   */\n  public async close() {\n    if (this.channel) {\n      await this.channel.close()\n    }\n    if (this.connection) {\n      await this.connection.close()\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\rabbitmq\rabbitmq.ts</source>
<document_content>//import { inject } from '@adonisjs/core'\nimport amqp, { Connection, Channel, ConsumeMessage } from 'amqplib'\nimport env from '#start/env'\n\n//@inject()\nexport default class RabbitMQService {\n  private connection: Connection | null = null\n  private channel: Channel | null = null\n\n  constructor() {}\n\n  /**\n   * Initialize the RabbitMQ connection and channel\n   */\n  public async init() {\n    try {\n      this.connection = await amqp.connect(env.get('RABBITMQ_URL'))\n      this.channel = await this.connection.createChannel()\n      console.log('Connected to RabbitMQ')\n    } catch (error) {\n      console.error('Failed to connect to RabbitMQ:', error)\n      throw error\n    }\n  }\n\n  // ... (rest of the methods remain the same)\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\s3\s3_facade.ts</source>
<document_content>import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { randomUUID } from 'crypto'\nimport env from '#start/env'\n\nexport class S3Facade {\n  private s3Client: S3Client\n  private bucketName: string\n\n  constructor() {\n    this.s3Client = new S3Client({\n      region: env.get('AWS_REGION'),\n      credentials: {\n        accessKeyId: env.get('AWS_ACCESS_KEY_ID')!,\n        secretAccessKey: env.get('AWS_SECRET_ACCESS_KEY')!,\n        sessionToken: env.get('AWS_SESSION_TOKEN'),\n      },\n    })\n    this.bucketName = env.get('AWS_S3_BUCKET_NAME')!\n  }\n\n  /**\n   * @uploadFile\n   * @description Uploads a file to S3 and creates a Media record in the database.\n   * @param file The file to upload\n   * @param fileType The MIME type of the file\n   * @param tx The Prisma transaction object\n   * @returns The created Media object\n   */\n  async uploadFile(\n    file: Buffer,\n    fileType: string,\n    tx: any,\n    path?: string\n  ): Promise<{ media: any; signedUrl: string }> {\n    const fileKey = `${randomUUID()}-${Date.now()}`\n    const putObjectCommand = new PutObjectCommand({\n      Bucket: this.bucketName,\n      Key: `${path ? path + '/' : ''}${fileKey}`,\n      Body: file,\n      ContentType: fileType,\n    })\n\n    await this.s3Client.send(putObjectCommand)\n\n    const signedUrl = await getSignedUrl(this.s3Client, putObjectCommand, {\n      expiresIn: 3600,\n    })\n\n    const media = await tx.media.create({\n      data: {\n        url: `https://${this.bucketName}.s3.amazonaws.com/${path ? path + '/' : ''}${fileKey}`,\n        type: fileType,\n      },\n    })\n\n    return { media, signedUrl }\n  }\n\n  /**\n   * @getSignedUrl\n   * @description Generates a signed URL for accessing a file in S3.\n   * @param fileKey The key of the file in S3\n   * @returns The signed URL\n   */\n  async getSignedUrl(fileKey: string): Promise<string> {\n    const getObjectCommand = new PutObjectCommand({\n      Bucket: this.bucketName,\n      Key: fileKey,\n    })\n\n    return getSignedUrl(this.s3Client, getObjectCommand, { expiresIn: 3600 })\n  }\n}\n\nexport const s3Facade = new S3Facade()\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\stripe\stripe_facade.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport Stripe from 'stripe'\nimport env from '#start/env'\nimport { Exception } from '@adonisjs/core/exceptions'\n\n@inject()\nexport default class StripeFacade {\n  private stripe: Stripe\n\n  constructor() {\n    this.stripe = new Stripe(env.get('STRIPE_SECRET_KEY'), {\n      apiVersion: '2024-04-10', // Use the latest API version\n    })\n  }\n\n  /**\n   * Create a payment intent for a purchase\n   * @param amount The amount to charge (in cents)\n   * @param currency The currency to use (e.g., 'usd')\n   * @param customerId The Stripe Customer ID\n   * @param accountId The Stripe Connect account ID to receive the funds\n   * @returns The PaymentIntent object\n   */\n  async createPaymentIntent(amount: number, currency: string): Promise<Stripe.PaymentIntent> {\n    try {\n      const paymentIntent = await this.stripe.paymentIntents.create({\n        amount,\n        currency,\n      })\n      return paymentIntent\n    } catch (error) {\n      console.error('Stripe payment intent creation error:', error)\n      throw new Exception('Failed to create payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CREATION',\n        status: 500,\n      })\n    }\n  }\n\n  async createPaymentIntentForRepo(\n    amount: number,\n    currency: string,\n    sellerId: string,\n    repoId: string\n  ) {\n    try {\n      const paymentIntent = await this.createPaymentIntent(amount, currency)\n\n      // Update the payment intent with metadata\n      const updatedPaymentIntent = await this.stripe.paymentIntents.update(paymentIntent.id, {\n        metadata: { repoId, sellerId },\n      })\n\n      return updatedPaymentIntent\n    } catch (error) {\n      console.error('Error creating payment intent for repo:', error)\n      throw new Exception('Failed to create payment intent for repo', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CREATION',\n        status: 500,\n      })\n    }\n  }\n\n  async retrievePaymentIntent(paymentIntentId: string) {\n    try {\n      return await this.stripe.paymentIntents.retrieve(paymentIntentId)\n    } catch (error) {\n      console.error('Error retrieving payment intent:', error)\n      throw new Exception('Failed to retrieve payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_RETRIEVAL',\n        status: 500,\n      })\n    }\n  }\n\n  async confirmPaymentIntent(paymentIntentId: string) {\n    try {\n      return await this.stripe.paymentIntents.confirm(paymentIntentId)\n    } catch (error) {\n      console.error('Error confirming payment intent:', error)\n      throw new Exception('Failed to confirm payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CONFIRMATION',\n        status: 500,\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\auth_guard_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n//import lucia from '#services/lucia_service';\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { Role } from '@prisma/client'\nimport UserNotVerifiedException from '#exceptions/user_not_verified_exception'\n\nexport default class AuthGuardMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { role: Role }) {\n    const user = ctx.request.user\n    if (!user) {\n      throw new UnAuthorizedException('User not authenticated')\n    }\n\n    const userRole = user.role\n    const requiredRole = options.role\n\n    if (!this.hasAccess(userRole, requiredRole)) {\n      throw new UnAuthorizedException('Insufficient permissions')\n    }\n\n    if (!user.emailVerified) {\n      throw new UserNotVerifiedException()\n    }\n\n    if (user?.bannedUntil && user?.bannedUntil > new Date()) {\n      throw new UnAuthorizedException('User is banned')\n    }\n\n    if (user?.deletedAt) {\n      throw new UnAuthorizedException('User account is deleted')\n    }\n\n    // If the user has the required role or higher, allow access\n    await next()\n  }\n\n  private hasAccess(userRole: Role, requiredRole: Role): boolean {\n    const roleHierarchy = {\n      [Role.USER]: 1,\n      [Role.SELLER]: 2,\n      [Role.MODERATOR]: 3,\n      [Role.ADMIN]: 4,\n    }\n\n    return roleHierarchy[userRole] >= roleHierarchy[requiredRole]\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\check_database_connection_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\nimport { prisma } from '#services/prisma_service'\n\nexport default class CheckDatabaseConnection  {\n  async handle(ctx: HttpContext, next: NextFn) {\n    try {\n      await prisma.$connect()\n      await next()\n    }\n    catch (e) {\n      ctx.response.abort({\n        message: \"Unable to connect to database\"\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\container_bindings_middleware.ts</source>
<document_content>import { Logger } from '@adonisjs/core/logger'\nimport { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\n/**\n * The container bindings middleware binds classes to their request\n * specific value using the container resolver.\n *\n * - We bind \"HttpContext\" class to the \"ctx\" object\n * - And bind \"Logger\" class to the \"ctx.logger\" object\n */\nexport default class ContainerBindingsMiddleware {\n  handle(ctx: HttpContext, next: NextFn) {\n    ctx.containerResolver.bindValue(HttpContext, ctx)\n    ctx.containerResolver.bindValue(Logger, ctx.logger)\n\n    return next()\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\force_json_response_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\n/**\n * Updating the \"Accept\" header to always accept \"application/json\" response\n * from the server. This will force the internals of the framework like\n * validator errors or auth errors to return a JSON response.\n */\nexport default class ForceJsonResponseMiddleware {\n  async handle({ request }: HttpContext, next: NextFn) {\n    const headers = request.headers()\n    headers.accept = 'application/json'\n\n    return next()\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\get_user_session_middleware.ts</source>
<document_content>import UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport lucia from '#services/lucia_service'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\nexport default class GetUserSessionMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    /**\n     * Middleware logic goes here (before the next call)\n     */\n    const sessionId = lucia.readSessionCookie(ctx.request.headers().cookie ?? '')\n    if (!sessionId) {\n      //console.log('no session')\n      ctx.request.user = null\n      ctx.request.session = null\n      const output = await next()\n      return output\n    } else {\n      const { session, user } = await lucia.validateSession(sessionId)\n      if (session && session.fresh) {\n        ctx.response.header('Set-Cookie', lucia.createSessionCookie(session.id).serialize())\n      }\n\n      if (!session) {\n        ctx.response.header('Set-Cookie', lucia.createBlankSessionCookie().serialize())\n      }\n\n      if (session && session.fresh) {\n        ctx.response.header('Set-Cookie', lucia.createSessionCookie(session.id).serialize())\n      }\n\n      // if there is no user found but a role prop exist\n      //if (!user) {\n      //  console.log('no user')\n      //  throw new UnAuthorizedException()\n      //}\n\n      ctx.request.user = user\n      ctx.request.session = session\n\n      /**\n       * Call next method in the pipeline and return its output\n       */\n      await next()\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\admin_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport SalesService from '#services/sales_service'\nimport { CodeRepoStatus, OrderStatus, Role, SupportTicketStatus, UserCommentFlag, Language, SellerVerificationStatus } from '@prisma/client'\nimport SupportTicketService from './support_service.js'\nimport logger from '@adonisjs/core/services/logger'\nimport { Prisma } from '@prisma/client'\nimport { z } from 'zod'\n\nconst languageEnum = z.enum(['JSX', 'TSX', 'Unknown']);\n\nconst topSellingRepoSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  language: languageEnum,\n  totalRevenue: z.number()\n});\n\nconst financialInsightsSchema = z.object({\n  currentMonthRevenue: z.number(),\n  previousMonthRevenue: z.number(),\n  revenueGrowth: z.number(),\n  pendingPayouts: z.number(),\n  processedPayouts: z.number(),\n  topSellingRepos: z.array(topSellingRepoSchema),\n  revenueByLanguage: z.record(languageEnum, z.number())\n});\n\ntype SalesAggregateItem = {\n  id: string\n  sellerId: string\n  date: Date\n  revenue: number\n  salesCount: number\n}\n\ntype DashboardData = {\n  salesOverview: {\n    totalRevenue: number\n    totalSales: number\n    averageOrderValue: number\n    dailySales: { revenue: number; salesCount: number }\n    weeklySales: { revenue: number; salesCount: number }\n    monthlySales: { revenue: number; salesCount: number }\n  }\n  userStatistics: {\n    totalUsers: number\n    userTypeCounts: Record<Role, number>\n    newUsers: number\n  }\n  repoMetrics: {\n    totalRepos: number\n    pendingApprovalRepos: number\n    popularRepos: { id: string; name: string; _count: { orders: number } }[]\n    recentRepos: { id: string; name: string; createdAt: Date }[]\n  }\n  sellerPerformance: {\n    topSellers: {\n      id: string\n      email: string\n      sellerProfile: { verificationStatus: SellerVerificationStatus; balance: number } | null\n      profile: { name: string | null } | null\n      _count: { orders: number }\n    }[]\n    newSellerApplications: number\n  }\n  orderManagement: {\n    recentOrders: {\n      id: string\n      userId: string\n      codeRepoId: string\n      createdAt: Date\n      updatedAt: Date\n      deletedAt: Date | null\n      status: OrderStatus\n      totalAmount: number\n      stripePaymentIntentId: string | null\n      stripePaymentMethodId: string | null\n      payoutRequestId: string | null\n      user: { email: string }\n      codeRepo: { name: string }\n    }[]\n    orderStatusCounts: Record<OrderStatus, number>\n  }\n  financialInsights: {\n    currentMonthRevenue: number\n    previousMonthRevenue: number\n    revenueGrowth: number\n    pendingPayouts: number\n    processedPayouts: number\n    topSellingRepos: { id: string; name: string; language: Language; totalRevenue: number }[]\n  }\n  supportTickets: {\n    openTicketsCount: number\n    averageResponseTime: number | null\n    ticketStatusCounts: Record<SupportTicketStatus, number>\n  }\n  contentModeration: {\n    flaggedReviews: number\n    flaggedComments: number\n    totalFlaggedContent: number\n  }\n}\n\n@inject()\nexport default class AdminDashboardService {\n  constructor(\n    private salesService: SalesService,\n    private supportTicketService: SupportTicketService\n  ) {}\n\n  public async getDashboardData(): Promise<DashboardData> {\n    try {\n      const now = DateTime.now()\n      const startOfDay = now.startOf('day').toJSDate()\n      const startOfWeek = now.startOf('week').toJSDate()\n      const startOfMonth = now.startOf('month').toJSDate()\n\n      const [\n        salesOverview,\n        userStatistics,\n        repoMetrics,\n        sellerPerformance,\n        orderManagement,\n        financialInsights,\n        supportTickets,\n        contentModeration\n      ] = await Promise.all([\n        this.getSalesOverview(startOfDay, startOfWeek, startOfMonth),\n        this.getUserStatistics(),\n        this.getRepoMetrics(),\n        this.getSellerPerformance(),\n        this.getOrderManagement(),\n        this.getFinancialInsights(),\n        this.getSupportTickets(),\n        this.getContentModeration()\n      ])\n\n      return {\n        salesOverview,\n        userStatistics,\n        repoMetrics,\n        sellerPerformance,\n        orderManagement,\n        financialInsights,\n        supportTickets,\n        contentModeration\n      }\n    } catch (error) {\n      logger.error('Error in getDashboardData:', error)\n      throw new Error('Failed to retrieve dashboard data')\n    }\n  }\n\n  private async getSalesOverview(startOfDay: Date, startOfWeek: Date, startOfMonth: Date) {\n    try {\n      const [sellers, totalRevenue, totalSales] = await Promise.all([\n        prisma.user.findMany({\n          where: { role: Role.SELLER },\n          select: { id: true }\n        }),\n        prisma.order.aggregate({\n          _sum: { totalAmount: true },\n          where: { status: OrderStatus.SUCCEEDED }\n        }),\n        prisma.order.count({ where: { status: OrderStatus.SUCCEEDED } })\n      ])\n\n      const now = new Date()\n\n      const salesPromises = sellers.flatMap(seller => [\n        this.salesService.getSalesAggregate(seller.id, startOfDay, now),\n        this.salesService.getSalesAggregate(seller.id, startOfWeek, now),\n        this.salesService.getSalesAggregate(seller.id, startOfMonth, now)\n      ])\n\n      const allSalesData = await Promise.all(salesPromises)\n\n      const [dailySales, weeklySales, monthlySales] = [\n        allSalesData.filter((_, index) => index % 3 === 0),\n        allSalesData.filter((_, index) => index % 3 === 1),\n        allSalesData.filter((_, index) => index % 3 === 2)\n      ]\n\n      const aggregateSales = (sales: SalesAggregateItem[][]) => {\n        return sales.reduce((acc, sellerSales) => {\n          const totalRevenue = sellerSales.reduce((sum, sale) => sum + sale.revenue, 0)\n          const totalSalesCount = sellerSales.reduce((sum, sale) => sum + sale.salesCount, 0)\n          return {\n            revenue: acc.revenue + totalRevenue,\n            salesCount: acc.salesCount + totalSalesCount\n          }\n        }, { revenue: 0, salesCount: 0 })\n      }\n\n      return {\n        totalRevenue: totalRevenue._sum.totalAmount ?? 0,\n        totalSales,\n        averageOrderValue: totalSales > 0 ? (totalRevenue._sum.totalAmount ?? 0) / totalSales : 0,\n        dailySales: aggregateSales(dailySales),\n        weeklySales: aggregateSales(weeklySales),\n        monthlySales: aggregateSales(monthlySales)\n      }\n    } catch (error) {\n      logger.error('Error in getSalesOverview:', error)\n      throw new Error('Failed to retrieve sales overview')\n    }\n  }\n\n  private async getUserStatistics() {\n    try {\n      const [totalUsers, userTypeCounts, newUsers] = await Promise.all([\n        prisma.user.count(),\n        prisma.user.groupBy({\n          by: ['role'],\n          _count: true\n        }),\n        prisma.user.count({\n          where: {\n            createdAt: {\n              gte: DateTime.now().minus({ days: 30 }).toJSDate()\n            }\n          }\n        })\n      ])\n\n      return {\n        totalUsers,\n        userTypeCounts: userTypeCounts.reduce((acc, { role, _count }) => {\n          acc[role as Role] = _count\n          return acc\n        }, {} as Record<Role, number>),\n        newUsers\n      }\n    } catch (error) {\n      logger.error('Error in getUserStatistics:', error)\n      throw new Error('Failed to retrieve user statistics')\n    }\n  }\n\n  private async getRepoMetrics() {\n    try {\n      const [totalRepos, pendingApprovalRepos, popularRepos, recentRepos] = await Promise.all([\n        prisma.codeRepo.count(),\n        prisma.codeRepo.count({\n          where: { status: CodeRepoStatus.pending }\n        }),\n        prisma.codeRepo.findMany({\n          take: 5,\n          orderBy: { orders: { _count: 'desc' } },\n          select: { id: true, name: true, _count: { select: { orders: true } } }\n        }),\n        prisma.codeRepo.findMany({\n          take: 5,\n          orderBy: { createdAt: 'desc' },\n          select: { id: true, name: true, createdAt: true }\n        })\n      ])\n\n      return {\n        totalRepos,\n        pendingApprovalRepos,\n        popularRepos,\n        recentRepos\n      }\n    } catch (error) {\n      logger.error('Error in getRepoMetrics:', error)\n      throw new Error('Failed to retrieve repo metrics')\n    }\n  }\n\n  private async getSellerPerformance() {\n    try {\n      const [topSellers, newSellerApplications] = await Promise.all([\n        prisma.user.findMany({\n          where: { role: Role.SELLER },\n          take: 5,\n          orderBy: { orders: { _count: 'desc' } },\n          select: {\n            id: true,\n            email: true,\n            profile: { select: { name: true } },\n            _count: { select: { orders: true } },\n            sellerProfile: {\n              select: {\n                balance: true,\n                verificationStatus: true\n              }\n            }\n          }\n        }),\n        prisma.sellerProfile.count({\n          where: { verificationStatus: 'PENDING' }\n        })\n      ])\n\n      return {\n        topSellers,\n        newSellerApplications\n      }\n    } catch (error) {\n      logger.error('Error in getSellerPerformance:', error)\n      throw new Error('Failed to retrieve seller performance data')\n    }\n  }\n\n  private async getOrderManagement() {\n    try {\n      const [recentOrders, orderStatusCounts] = await Promise.all([\n        prisma.order.findMany({\n          take: 10,\n          orderBy: { createdAt: 'desc' },\n          include: {\n            user: { select: { email: true } },\n            codeRepo: { select: { name: true } }\n          }\n        }),\n        prisma.order.groupBy({\n          by: ['status'],\n          _count: true\n        })\n      ])\n\n      return {\n        recentOrders,\n        orderStatusCounts: orderStatusCounts.reduce((acc, { status, _count }) => {\n          acc[status as OrderStatus] = _count\n          return acc\n        }, {} as Record<OrderStatus, number>)\n      }\n    } catch (error) {\n      logger.error('Error in getOrderManagement:', error)\n      throw new Error('Failed to retrieve order management data')\n    }\n  }\n\n  private async getFinancialInsights() {\n    try {\n      const now = DateTime.now()\n      const startOfMonth = now.startOf('month').toJSDate()\n      const startOfPreviousMonth = now.minus({ months: 1 }).startOf('month').toJSDate()\n\n      const [\n        currentMonthRevenue,\n        previousMonthRevenue,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      ] = await Promise.all([\n        this.getMonthlyRevenue(startOfMonth),\n        this.getMonthlyRevenue(startOfPreviousMonth, startOfMonth),\n        this.getPendingPayouts(),\n        this.getProcessedPayouts(),\n        this.getTopSellingRepos(),\n      ])\n\n      const revenueGrowth = this.calculateRevenueGrowth(currentMonthRevenue, previousMonthRevenue)\n\n      logger.info('Financial Insights:', {\n        currentMonthRevenue,\n        previousMonthRevenue,\n        revenueGrowth,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      })\n\n      return {\n        currentMonthRevenue,\n        previousMonthRevenue,\n        revenueGrowth,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      }\n    } catch (error) {\n      logger.error('Error in getFinancialInsights:', error)\n      return {\n        currentMonthRevenue: 0,\n        previousMonthRevenue: 0,\n        revenueGrowth: 0,\n        pendingPayouts: 0,\n        processedPayouts: 0,\n        topSellingRepos: [],\n        revenueByLanguage: {}\n      }\n    }\n  }\n\n  private async getMonthlyRevenue(startDate: Date, endDate: Date = new Date()) {\n    const result = await prisma.order.aggregate({\n      _sum: { totalAmount: true },\n      where: {\n        status: OrderStatus.SUCCEEDED,\n        createdAt: {\n          gte: startDate,\n          lt: endDate\n        }\n      }\n    })\n    return result._sum.totalAmount ?? 0\n  }\n\n  private calculateRevenueGrowth(currentRevenue: number, previousRevenue: number) {\n    if (previousRevenue === 0) return currentRevenue > 0 ? 100 : 0\n    return ((currentRevenue - previousRevenue) / previousRevenue) * 100\n  }\n\n  private async getPendingPayouts() {\n    return prisma.payoutRequest.aggregate({\n      _sum: { totalAmount: true },\n      where: { status: 'PENDING' }\n    }).then(result => result._sum.totalAmount ?? 0)\n  }\n\n  private async getProcessedPayouts() {\n    return prisma.payout.aggregate({\n      _sum: { totalAmount: true }\n    }).then(result => result._sum.totalAmount ?? 0)\n  }\n\n  private async getTopSellingRepos(limit: number = 5) {\n    const repos = await prisma.codeRepo.findMany({\n      take: limit,\n      select: {\n        id: true,\n        name: true,\n        language: true,\n        orders: {\n          where: { status: OrderStatus.SUCCEEDED },\n          select: { totalAmount: true }\n        }\n      },\n      orderBy: {\n        orders: {\n          _count: 'desc'\n        }\n      }\n    })\n\n    return repos.map(repo => ({\n      id: repo.id,\n      name: repo.name,\n      language: repo.language,\n      totalRevenue: repo.orders.reduce((sum, order) => sum + order.totalAmount, 0)\n    }))\n  }\n\n  private async getRevenueByLanguage() {\n    const revenueByRepo = await prisma.order.groupBy({\n      by: ['codeRepoId'],\n      _sum: { totalAmount: true },\n      where: { status: OrderStatus.SUCCEEDED }\n    })\n\n    const repoLanguages = await prisma.codeRepo.findMany({\n      where: { id: { in: revenueByRepo.map(r => r.codeRepoId) } },\n      select: { id: true, language: true }\n    })\n\n    const languageMap = new Map(repoLanguages.map(r => [r.id, r.language]))\n\n    return revenueByRepo.reduce((acc, { codeRepoId, _sum }) => {\n      const language = languageMap.get(codeRepoId) ?? 'Unknown'\n      acc[language] = (acc[language] ?? 0) + (_sum.totalAmount ?? 0)\n      return acc\n    }, {} as Record<Language | 'Unknown', number>)\n  }\n\n  private async getSupportTickets() {\n    try {\n      const [openTickets, ticketStatusCounts, completedTickets] = await Promise.all([\n        this.supportTicketService.getTicketsByStatus(SupportTicketStatus.todo),\n        prisma.supportTicket.groupBy({\n          by: ['status'],\n          _count: true\n        }),\n        prisma.supportTicket.findMany({\n          where: {\n            status: {\n              in: [SupportTicketStatus.inProgress, SupportTicketStatus.done]\n            }\n          },\n          select: {\n            createdAt: true,\n            updatedAt: true\n          }\n        })\n      ])\n\n      const totalResponseTime = completedTickets.reduce((total, ticket) => {\n        return total + ticket.updatedAt.getTime() - ticket.createdAt.getTime()\n      }, 0)\n\n      const averageResponseTime = completedTickets.length > 0\n        ? totalResponseTime / completedTickets.length / (1000 * 60 * 60) // Convert to hours\n        : null\n\n      return {\n        openTicketsCount: openTickets.length,\n        averageResponseTime,\n        ticketStatusCounts: ticketStatusCounts.reduce((acc, { status, _count }) => {\n          acc[status as SupportTicketStatus] = _count\n          return acc\n        }, {} as Record<SupportTicketStatus, number>)\n      }\n    } catch (error) {\n      logger.error('Error in getSupportTickets:', error)\n      throw new Error('Failed to retrieve support ticket data')\n    }\n  }\n\n  private async getContentModeration() {\n    try {\n      const [flaggedReviews, flaggedComments] = await Promise.all([\n        prisma.review.count({\n          where: { flag: { not: UserCommentFlag.NONE } }\n        }),\n        prisma.comment.count({\n          where: { flag: { not: UserCommentFlag.NONE } }\n        })\n      ])\n\n      return {\n        flaggedReviews,\n        flaggedComments,\n        totalFlaggedContent: flaggedReviews + flaggedComments\n      }\n    } catch (error) {\n      logger.error('Error in getContentModeration:', error)\n      throw new Error('Failed to retrieve content moderation data')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\auth_service.ts</source>
<document_content>import { createDate, TimeSpan, isWithinExpirationDate } from 'oslo'\nimport { verify } from '@node-rs/argon2'\nimport { hash } from '@node-rs/argon2'\nimport { Cookie, User, generateIdFromEntropySize } from 'lucia'\nimport { encodeHex } from 'oslo/encoding'\nimport { sha256 } from 'oslo/crypto'\nimport UserVerificationService from '#services/user_verification_service'\nimport lucia from '#services/lucia_service'\nimport { prisma } from '#services/prisma_service'\n// import { User } from \"lucia\";\n// import { AuthValidator, ZodLoginAuthStrategy, PrismaEmailExistsAuthStrategy, ZodRegistrationAuthStrategy, PrismaEmailUniqueAuthStrategy } from \"#validators/auth\";\nimport { inject } from '@adonisjs/core'\nimport mailConfig from '#config/mail'\nimport { Exception } from '@adonisjs/core/exceptions'\nimport logger from '@adonisjs/core/services/logger'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\n\n@inject()\nexport default class AuthService {\n  constructor(private userVerificationService: UserVerificationService) {}\n\n  /**\n   * Handles logging in a user with the given email and password.\n   *\n   * @param {string} email - The user's email.\n   * @param {string} password - The user's password.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handleLogin(email: string, password: string): Promise<Response | Cookie> {\n    const user = await prisma.user.findUnique({ where: { email } })\n\n    if (!user) {\n      // return new Response(\"Invalid email or password\", { status: 400 });\n      throw new Exception('Invalid email or password')\n    }\n\n    const validPassword = await verify(user.passwordHash, password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n\n    if (!validPassword) {\n      throw new Exception('Invalid credentials', { status: 400 })\n    }\n\n    const session = await lucia.createSession(user.id.toString(), {})\n    const sessionCookie = lucia.createSessionCookie(session.id.toString())\n    return sessionCookie\n  }\n\n  /**\n   * Handles registering a new user with the given email, password, and full name.\n   *\n   * @param {string} email - The user's email.\n   * @param {string} password - The user's password.\n   * @param {string} fullname - The user's full name.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handleRegistration(\n    email: string,\n    password: string,\n    fullname: string\n  ): Promise<Response | string> {\n    const passwordHash = await hash(password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n\n    const id = generateIdFromEntropySize(32)\n\n    try {\n      await prisma.user.create({\n        data: { id, email, passwordHash, role: 'USER' },\n      })\n\n      await prisma.profile.create({\n        data: { userId: id, name: fullname },\n      })\n      const session = await lucia.createSession(id, {})\n      const sessionCookie = lucia.createSessionCookie(session.id)\n      const token = sessionCookie.serialize()\n      logger.info(token)\n\n      const code = await this.userVerificationService.generateEmailVerificationCode(id, email)\n      await this.userVerificationService.sendVerificationCode(email, code, token)\n      return token\n    } catch (e) {\n      console.error('Failed to register user: ', e)\n      throw new Exception('Failed to register user')\n    }\n  }\n\n  /**\n   * Handles logging out a user by invalidating their session.\n   *\n   * @param {string} sessionId - The session ID to invalidate.\n   * @returns {Promise<void>}\n   */\n  public async handleLogout(sessionId: string): Promise<void> {\n    return await lucia.invalidateSession(sessionId)\n  }\n\n  /**\n   * Handles verifying a user's email with a verification code.\n   *\n   * @param {string} sessionId - The session ID of the user.\n   * @param {string} code - The verification code.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handleVerifyEmail(sessionId: string, code: string): Promise<string | Response> {\n    const { user } = await lucia.validateSession(sessionId)\n\n    if (!user) {\n      throw new UnAuthorizedException('Invalid User', { status: 401 })\n    }\n\n    const validCode = await this.userVerificationService.verifyVerificationCode(user, code)\n\n    if (!validCode) {\n      return new Response('Invalid code', { status: 400 })\n    }\n\n    await lucia.invalidateUserSessions(user.id)\n    await prisma.user.update({\n      where: { id: user.id },\n      data: { emailVerified: true },\n    })\n\n    const session = await lucia.createSession(user.id, {})\n    const sessionCookie = lucia.createSessionCookie(session.id)\n    return sessionCookie.serialize()\n  }\n\n  /**\n   * Handles creating a password reset token for a user.\n   *\n   * @param {string} userId - The user's ID.\n   * @returns {Promise<string>} - The password reset token.\n   */\n  public async handleCreatePasswordResetToken(userId: string): Promise<string | Response> {\n    await prisma.passwordResetToken.deleteMany({ where: { userId } })\n\n    const tokenId = generateIdFromEntropySize(25)\n    const tokenHash = encodeHex(await sha256(new TextEncoder().encode(tokenId)))\n\n    await prisma.passwordResetToken.create({\n      data: {\n        tokenHash,\n        userId,\n        expiresAt: createDate(new TimeSpan(2, 'h')),\n      },\n    })\n\n    return tokenId\n  }\n\n  /**\n   * Handles verifying if a user exists and their email is verified.\n   *\n   * @param {string} email - The user's email.\n   * @returns {Promise<boolean>} - True if user exists and email is verified, false otherwise.\n   */\n  public async handleVerifyUserExistAndEmailVerified(email: string): Promise<boolean> {\n    const user = await prisma.user.findUnique({ where: { email } })\n    return !!user && user.emailVerified\n  }\n\n  /**\n   * Handles password reset for a user with the given token and new password.\n   *\n   * @param {string} token - The password reset token.\n   * @param {string} password - The new password.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handlePasswordReset(token: string, password: string): Promise<Cookie | Response> {\n    const tokenHash = encodeHex(await sha256(new TextEncoder().encode(token)))\n\n    const tokenData = await prisma.passwordResetToken.findUnique({ where: { tokenHash } })\n\n    if (!tokenData || !isWithinExpirationDate(tokenData.expiresAt)) {\n      await prisma.passwordResetToken.delete({ where: { tokenHash } })\n      return new Response('Invalid or expired token', { status: 400 })\n    }\n\n    await lucia.invalidateUserSessions(tokenData.userId.toString())\n\n    const passwordHash = await hash(password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n\n    await prisma.user.update({\n      where: { id: tokenData.userId },\n      data: { passwordHash },\n    })\n\n    await prisma.passwordResetToken.delete({ where: { tokenHash } })\n\n    const session = await lucia.createSession(tokenData.userId.toString(), {})\n    return lucia.createSessionCookie(session.id)\n  }\n\n  public async sendVerifyEmailCode(user: User) {\n    if (!user.email) {\n      throw new Exception('User does not have an email in the system', { status: 400 })\n    }\n    logger.info('sending email verification code to ' + user.email)\n    if (user.emailVerified) {\n      throw new Exception('Email already verified', { status: 400 })\n    }\n    const session = await lucia.createSession(user.id.toString(), {})\n    const token = lucia.createSessionCookie(session.id).serialize()\n\n    const code = await this.userVerificationService.generateEmailVerificationCode(\n      user.id,\n      user.email\n    )\n    await this.userVerificationService.sendVerificationCode(user.email, code, token)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\checkout_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport StripeFacade from '#integrations/stripe/stripe_facade'\nimport RepoService from '#services/repo_service'\nimport OrderService from '#services/order_service'\nimport SellerService from '#services/seller_service'\nimport SalesService from '#services/sales_service'\nimport { Prisma, OrderStatus } from '@prisma/client'\nimport { z } from 'zod'\nimport RepoAccessService from '#services/repo_access_service'\n\nconst processPaymentSchema = z.object({\n  paymentIntentId: z.string(),\n})\n\n@inject()\nexport default class CheckoutService {\n  constructor(\n    protected stripeFacade: StripeFacade,\n    protected repoService: RepoService,\n    protected orderService: OrderService,\n    protected sellerService: SellerService,\n    protected salesService: SalesService,\n    protected repoAccessService: RepoAccessService\n  ) {}\n\n  /**\n   * Initialize the checkout process for a repo\n   * @param repoId - The ID of the repo being purchased\n   * @param userId - The ID of the user making the purchase\n   * @param customerId - The Stripe customer ID of the user\n   * @returns An object containing the Stripe client secret\n   */\n  public async initCheckout(repoId: string, userId: string) {\n    // check if repo exist\n    const repoInfo = await this.repoService.getRepoById(repoId)\n\n    if (!repoInfo) {\n      throw new Error('Repo not found or seller profile not available')\n    }\n\n    // check if repo seller is verified\n    const isSellerVerified = await this.sellerService.checkIfSellerVerified(repoInfo.userId)\n\n    if (!isSellerVerified) {\n      throw new Error('Repo not found or seller profile not available')\n    }\n\n    if (repoInfo.userId === userId) {\n      throw new Error('You cannot purchase your own repo')\n    }\n\n    // create order\n\n    const paymentIntent = await this.stripeFacade.createPaymentIntentForRepo(\n      repoInfo.price,\n      'MYR', // Default currency\n      repoInfo.userId,\n      repoInfo.id\n    )\n\n    await this.orderService.createOrder({\n      userId: userId,\n      repoId: paymentIntent.metadata.repoId,\n      amount: paymentIntent.amount,\n      status: OrderStatus.REQUIRESACTION,\n      stripePaymentIntentId: paymentIntent.id,\n    })\n\n    return { clientSecret: paymentIntent.client_secret }\n  }\n\n  /**\n   * Process a successful payment\n   * @param paymentIntentId - The ID of the Stripe payment intent\n   * @param tx - Prisma transaction client\n   * @returns An object indicating success and the order ID\n   */\n  public async processPayment(userId: string, paymentIntentId: string, tx: Prisma.TransactionClient) {\n    const { paymentIntentId: validatedPaymentIntentId } = processPaymentSchema.parse({\n      paymentIntentId,\n    })\n\n    const paymentIntent = await this.stripeFacade.retrievePaymentIntent(validatedPaymentIntentId)\n    if (!paymentIntent) {\n      throw new Error('Payment intent not found')\n    }\n\n    // get order by intent id\n    const order = await this.orderService.getOrderByStripePaymentIntentId(paymentIntentId)\n    if (!order) {\n      throw new Error('Order not found')\n    }\n\n    // get repo seller\n    const repo = await this.repoService.getRepoById(order.codeRepoId)\n    if (!repo) {\n      throw new Error('Repo not found')\n    }\n\n    const sellerProfile = await this.sellerService.getSellerProfile(repo.userId)\n\n    if (sellerProfile === null) {\n      throw new Error('seller not available')\n    }\n\n    await this.orderService.updateOrderStatus(order.id, OrderStatus.SUCCEEDED, tx)\n\n    await this.sellerService.updateBalance(sellerProfile.id, order.totalAmount, tx)\n    await this.salesService.updateSalesAggregate(repo.userId, order.totalAmount, tx)\n\n    const accessGranted = await this.repoAccessService.grantAccess(userId, order.codeRepoId, order.id, tx )\n    if (!accessGranted) {\n      throw new Error('Failed to grant access to the repo')\n    }\n\n    return { success: true, orderId: order.id }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\code_check_service.ts</source>
<document_content>import { OpenAIEmbeddings } from '@langchain/openai'\nimport { HNSWLib } from '@langchain/community/vectorstores/hnswlib'\nimport { formatDocumentsAsString } from 'langchain/util/document'\nimport { PromptTemplate } from '@langchain/core/prompts'\nimport { RunnableSequence, RunnablePassthrough } from '@langchain/core/runnables'\nimport { StringOutputParser } from '@langchain/core/output_parsers'\nimport { codeCheckSchema } from '#validators/code_check'\nimport logger from '@adonisjs/core/services/logger'\nimport { pdfDocReader } from '../integrations/langchain/document_reader.js'\nimport { prisma } from '#services/prisma_service'\nimport { openaiModel } from '../integrations/langchain/openai.js'\nimport { ESLint } from 'eslint'\n\ninterface CodeCheckResult {\n  securityScore: number\n  maintainabilityScore: number\n  readabilityScore: number\n  securitySuggestion: string\n  maintainabilitySuggestion: string\n  readabilitySuggestion: string\n  overallDescription: string\n  eslintErrorCount: number\n  eslintFatalErrorCount: number\n}\n\nexport default class CodeCheckService {\n  private vectorStore: HNSWLib | null = null\n  private readonly condenseQuestionPrompt: PromptTemplate\n  private readonly answerPrompt: PromptTemplate\n  private readonly jsonSchema: object\n  private eslint: ESLint\n\n  constructor() {\n    this.condenseQuestionPrompt = PromptTemplate.fromTemplate(`\n      Given the following code, analyze it for security, maintainability, and readability:\n      Code: {question}\n      Provide a concise summary of the main concerns in each area.\n    `)\n\n    this.answerPrompt = PromptTemplate.fromTemplate(`\n      Based on the following context and code, provide a comprehensive analysis:\n      Context: {context}\n      Code: {question}\n\n      1. Overall Description: Summarize the code quality, considering security, maintainability, and readability in one or two sentences.\n\n      2. Security Analysis:\n         - Score the code's security on a scale of 0 to 100, where 0 is extremely insecure and 100 is highly secure.\n         - Provide specific suggestions for improving security.\n\n      3. Maintainability Analysis:\n         - Score the code's maintainability on a scale of 0 to 100, where 0 is very difficult to maintain and 100 is easily maintainable.\n         - Provide specific suggestions for improving maintainability.\n\n      4. Readability Analysis:\n         - Score the code's readability on a scale of 0 to 100, where 0 is very difficult to read and 100 is easily readable.\n         - Provide specific suggestions for improving readability.\n\n      Please ensure all suggestions are based solely on the given code, and ensure all fields mentioned above are fulfilled.\n    `)\n\n    this.jsonSchema = {\n      title: 'CodeCheckResult',\n      type: 'object',\n      properties: {\n        securityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        maintainabilityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        readabilityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        securitySuggestion: { type: 'string' },\n        maintainabilitySuggestion: { type: 'string' },\n        readabilitySuggestion: { type: 'string' },\n        overallDescription: { type: 'string' },\n      },\n      required: [\n        'securityScore',\n        'maintainabilityScore',\n        'readabilityScore',\n        'securitySuggestion',\n        'maintainabilitySuggestion',\n        'readabilitySuggestion',\n        'overallDescription',\n      ],\n    }\n\n    // Initialize ESLint with settings for JSX and TSX\n    this.eslint = new ESLint({\n      useEslintrc: false,\n      overrideConfig: {\n        parser: '@typescript-eslint/parser',\n        parserOptions: {\n          ecmaVersion: 2021,\n          sourceType: 'module',\n          ecmaFeatures: {\n            jsx: true,\n          },\n        },\n        plugins: ['react', '@typescript-eslint'],\n        extends: [\n          'eslint:recommended',\n          'plugin:react/recommended',\n          'plugin:@typescript-eslint/recommended',\n        ],\n        rules: {\n          // Add any specific rules you want to enforce\n          'react/prop-types': 'off', // Example: Turn off prop-types rule\n        },\n      },\n    })\n  }\n\n  private async initializeVectorStore(): Promise<void> {\n    if (!this.vectorStore) {\n      this.vectorStore = await HNSWLib.fromTexts(\n        pdfDocReader.map((doc) => doc.pageContent),\n        pdfDocReader.map((_, index) => ({ id: index + 1 })),\n        new OpenAIEmbeddings()\n      )\n    }\n  }\n\n  private createStandaloneQuestionChain(): RunnableSequence {\n    return RunnableSequence.from([\n      {\n        question: (input: { question: string; chat_history: [string, string][] }) => input.question,\n        chat_history: (input: { question: string; chat_history: [string, string][] }) =>\n          this.formatChatHistory(input.chat_history),\n      },\n      this.condenseQuestionPrompt,\n      openaiModel,\n      new StringOutputParser(),\n    ])\n  }\n\n  private formatChatHistory(chatHistory: [string, string][]): string {\n    return chatHistory\n      .map(([human, assistant]) => `Human: ${human}\nAssistant: ${assistant}`)\n      .join('\n')\n  }\n\n  private async lintCode(\n    code: string,\n    language: 'JSX' | 'TSX'\n  ): Promise<{ errorCount: number; fatalErrorCount: number }> {\n    const extension = language === 'JSX' ? '.jsx' : '.tsx'\n    const results = await this.eslint.lintText(code, { filePath: `temp${extension}` })\n    return {\n      errorCount: results[0].errorCount,\n      fatalErrorCount: results[0].fatalErrorCount,\n    }\n  }\n\n  public async performCodeCheck(code: string, language: 'JSX' | 'TSX'): Promise<CodeCheckResult> {\n    try {\n      await this.initializeVectorStore()\n\n      if (!this.vectorStore) {\n        throw new Error('Vector store initialization failed')\n      }\n\n      const retriever = this.vectorStore.asRetriever()\n      const standaloneQuestionChain = this.createStandaloneQuestionChain()\n\n      const answerChain = RunnableSequence.from([\n        {\n          context: retriever.pipe(formatDocumentsAsString),\n          question: new RunnablePassthrough(),\n        },\n        this.answerPrompt,\n        openaiModel.withStructuredOutput(this.jsonSchema),\n      ])\n\n      const conversationalRetrievalQAChain = standaloneQuestionChain.pipe(answerChain)\n\n      const result = await conversationalRetrievalQAChain.invoke({\n        question: `Analyze the following ${language} code for overall description, security, maintainability, and readability:\n\n${code}`,\n        chat_history: [],\n      })\n\n      const { errorCount, fatalErrorCount } = await this.lintCode(code, language)\n\n      logger.info({ message: 'Code check result', result })\n      logger.info({ message: 'ESLint error counts', errorCount, fatalErrorCount })\n\n      const finalResult: CodeCheckResult = {\n        ...codeCheckSchema.parse(result),\n        eslintErrorCount: errorCount,\n        eslintFatalErrorCount: fatalErrorCount,\n      }\n\n      logger.info({ message: 'Code check completed', result: finalResult })\n      return finalResult\n    } catch (error) {\n      logger.error({ message: 'Error performing code check', error })\n      throw new Error(\n        `Code check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  public async performAndStoreCodeCheck(\n    repoId: string,\n    code: string,\n    language: 'JSX' | 'TSX'\n  ): Promise<CodeCheckResult> {\n    try {\n      const result = await this.performCodeCheck(code, language)\n\n      await this.storeCodeCheckResult(repoId, result)\n\n      return result\n    } catch (error) {\n      logger.error({ message: 'Error performing and storing code check', error, repoId })\n      throw new Error(\n        `Code check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  private async storeCodeCheckResult(repoId: string, result: CodeCheckResult): Promise<void> {\n    try {\n      await prisma.codeCheck.create({\n        data: {\n          repoId,\n          securityScore: result.securityScore,\n          maintainabilityScore: result.maintainabilityScore,\n          readabilityScore: result.readabilityScore,\n          securitySuggestion: result.securitySuggestion,\n          maintainabilitySuggestion: result.maintainabilitySuggestion,\n          readabilitySuggestion: result.readabilitySuggestion,\n          overallDescription: result.overallDescription,\n          eslintErrorCount: result.eslintErrorCount,\n          eslintFatalErrorCount: result.eslintFatalErrorCount,\n        },\n      })\n\n      logger.info({ message: 'Code check result stored successfully', repoId })\n    } catch (error) {\n      logger.error({ message: 'Error storing code check result', error, repoId })\n      throw new Error(\n        `Failed to store code check result: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  public async getLatestCodeCheck(repoId: string): Promise<CodeCheckResult | null> {\n    try {\n      const latestCodeCheck = await prisma.codeCheck.findFirst({\n        where: { repoId },\n        orderBy: { createdAt: 'desc' },\n      })\n\n      if (!latestCodeCheck) {\n        return null\n      }\n\n      return {\n        securityScore: latestCodeCheck.securityScore,\n        maintainabilityScore: latestCodeCheck.maintainabilityScore,\n        readabilityScore: latestCodeCheck.readabilityScore,\n        securitySuggestion: latestCodeCheck.securitySuggestion,\n        maintainabilitySuggestion: latestCodeCheck.maintainabilitySuggestion,\n        readabilitySuggestion: latestCodeCheck.readabilitySuggestion,\n        overallDescription: latestCodeCheck.overallDescription,\n        eslintErrorCount: latestCodeCheck.eslintErrorCount,\n        eslintFatalErrorCount: latestCodeCheck.eslintFatalErrorCount,\n      }\n    } catch (error) {\n      logger.error({ message: 'Error retrieving latest code check', error, repoId })\n      throw new Error(\n        `Failed to retrieve latest code check: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\comment_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { Comment, UserCommentFlag, VoteType } from '@prisma/client'\nimport { RegExpMatcher, englishDataset, englishRecommendedTransformers } from 'obscenity'\n\ninterface CommentCreationData {\n  content: string\n  userId: string\n  reviewId: string\n}\n\ninterface CommentUpdateData {\n  content?: string\n}\n\ninterface CommentResponse {\n  id: string\n  content: string\n  userId: string\n  reviewId: string\n  createdAt?: Date\n  updatedAt?: Date\n  upvotes?: number\n  downvotes?: number\n  flag: UserCommentFlag\n}\n\nexport class CommentService {\n  private matcher: RegExpMatcher\n\n  constructor() {\n    this.matcher = new RegExpMatcher({\n      ...englishDataset.build(),\n      ...englishRecommendedTransformers,\n    })\n  }\n\n  private checkContent(content: string): UserCommentFlag {\n    return this.matcher.hasMatch(content) ? 'INAPPROPRIATE_LANGUAGE' : 'NONE'\n  }\n\n  private sanitizeComment(comment: Comment): CommentResponse {\n    const { id, content, userId, reviewId, createdAt, updatedAt, upvotes, downvotes, flag } =\n      comment\n    return { id, content, userId, reviewId, createdAt, updatedAt, upvotes, downvotes, flag }\n  }\n\n  async createComment(data: CommentCreationData): Promise<CommentResponse> {\n    const flag = this.checkContent(data.content)\n    const comment = await prisma.comment.create({ data: { ...data, flag } })\n    return this.sanitizeComment(comment)\n  }\n\n  async getCommentById(id: string): Promise<CommentResponse | null> {\n    const comment = await prisma.comment.findUnique({ where: { id, deletedAt: null } })\n    return comment ? this.sanitizeComment(comment) : null\n  }\n\n  async updateComment(id: string, data: CommentUpdateData): Promise<CommentResponse> {\n    const flag = data.content ? this.checkContent(data.content) : undefined\n    const comment = await prisma.comment.update({\n      where: { id, deletedAt: null },\n      data: { ...data, flag },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async revertFlag(id: string): Promise<CommentResponse> {\n    const comment = await prisma.comment.update({\n      where: { id },\n      data: { flag: UserCommentFlag.NONE },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async deleteComment(id: string): Promise<CommentResponse> {\n    const comment = await prisma.comment.update({\n      where: { id },\n      data: { deletedAt: new Date() },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async getAllFlaggedComments(): Promise<\n    Omit<CommentResponse, 'upvotes' | 'downvotes' | 'createdAt'>[]\n  > {\n    const comments = await prisma.comment.findMany({\n      where: {\n        flag: { not: UserCommentFlag.NONE },\n      },\n      include: { user: true },\n    })\n\n    return comments.map(({ upvotes, downvotes, createdAt, ...rest }) => {\n      return {\n        ...rest,\n        user: {\n          email: rest.user.email,\n        },\n      }\n    })\n  }\n\n  async handleVote(\n    commentId: string,\n    userId: string,\n    voteType: VoteType\n  ): Promise<CommentResponse> {\n    const existingVote = await prisma.vote.findUnique({\n      where: {\n        userId_commentId: {\n          userId,\n          commentId,\n        },\n      },\n    })\n\n    await prisma.$transaction(async (tx) => {\n      if (!existingVote) {\n        await tx.vote.create({\n          data: {\n            userId,\n            commentId,\n            type: voteType,\n          },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { increment: 1 },\n          },\n        })\n      } else if (existingVote.type !== voteType) {\n        await tx.vote.update({\n          where: { id: existingVote.id },\n          data: { type: voteType },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { increment: 1 },\n            [voteType === VoteType.UPVOTE ? 'downvotes' : 'upvotes']: { decrement: 1 },\n          },\n        })\n      } else {\n        await tx.vote.delete({\n          where: { id: existingVote.id },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { decrement: 1 },\n          },\n        })\n      }\n    })\n\n    const updatedComment = await prisma.comment.findUnique({\n      where: { id: commentId },\n    })\n\n    if (!updatedComment) {\n      throw new Error('Comment not found after vote operation')\n    }\n\n    return this.sanitizeComment(updatedComment)\n  }\n\n  async getPaginatedCommentsByReview(reviewId: string, page: number, perPage: number) {\n    const skip = (page - 1) * perPage\n    const [comments, total] = await prisma.$transaction([\n      prisma.comment.findMany({\n        where: { reviewId },\n        skip,\n        take: perPage,\n        orderBy: { createdAt: 'desc' },\n        include: {\n          user: {\n            select: {\n              id: true,\n              email: true,\n              profile: {\n                select: {\n                  name: true,\n                  profileImg: true,\n                },\n              },\n            },\n          },\n        },\n      }),\n      prisma.comment.count({ where: { reviewId } }),\n    ])\n\n    return {\n      data: comments,\n      meta: {\n        total,\n        page,\n        perPage,\n        lastPage: Math.ceil(total / perPage),\n      },\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\lucia_service.ts</source>
<document_content>import { Lucia } from 'lucia'\nimport { PrismaAdapter } from '@lucia-auth/adapter-prisma'\nimport { Role } from '@prisma/client'\nimport { prisma } from './prisma_service.js'\n\nimport {\n  HttpContext,\n  // Response,\n} from '@adonisjs/core/http'\nimport logger from '@adonisjs/core/services/logger'\n\n// import type { Session, User } from 'lucia'\n\nconst client = prisma\nconst adapter = new PrismaAdapter(client.session, client.user)\n\nconst env = process.env.NODE_ENV\n\nexport const lucia = new Lucia(adapter, {\n  sessionCookie: {\n    attributes: {\n      secure: env === 'PRODUCTION', // set `Secure` flag in HTTPS\n    },\n  },\n  getUserAttributes: (attributes) => {\n    // get profile attributes from the user\n    return {\n      email: attributes.email,\n      emailVerified: attributes.emailVerified,\n      // avatar: attributes.avatar,\n      role: attributes.role,\n      bannedUntil: attributes.bannedUntil,\n      deletedAt: attributes.deletedAt,\n    }\n  },\n})\n\nexport const validateRequestFromMiddleware = async (ctx: HttpContext) => {\n  const sessionId = lucia.readSessionCookie(ctx.request.headers().cookie ?? '')\n  if (!sessionId)\n    return {\n      user: null,\n      session: null,\n    }\n\n  const result = await lucia.validateSession(sessionId)\n  try {\n    if (result.session && result.session.fresh) {\n      const sessionCookie = lucia.createSessionCookie(result.session.id)\n      ctx.request.headers().SetCookie = sessionCookie.serialize()\n    }\n  } catch (error) {\n    logger.error(error)\n  }\n  return result\n}\n\ndeclare module 'lucia' {\n  interface Register {\n    Lucia: typeof lucia\n    DatabaseUserAttributes: {\n      email: string\n      avatar: string\n      emailVerified: boolean\n      role: Role\n      bannedUntil?: Date | null\n      deletedAt?: Date | null\n    }\n  }\n}\n\nexport default lucia\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\moderator_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport { UserCommentFlag, Role } from '@prisma/client'\n\n@inject()\nexport default class ModeratorDashboardService {\n  /**\n   * Get moderator dashboard data\n   * @param moderatorId - The ID of the moderator\n   * @returns Promise<object> Dashboard data\n   */\n  public async getDashboardData(moderatorId: string): Promise<object> {\n    const now = DateTime.now()\n    const startOfDay = now.startOf('day').toJSDate()\n    const startOfWeek = now.startOf('week').toJSDate()\n    const startOfMonth = now.startOf('month').toJSDate()\n\n    const [\n      contentModerationOverview,\n      moderationActivity,\n      userReportManagement,\n      contentAnalytics,\n      userManagement,\n      reviewAndCommentMetrics,\n      moderationQueue,\n      moderatorPerformance\n    ] = await Promise.all([\n      this.getContentModerationOverview(),\n      this.getModerationActivity(moderatorId, startOfDay, startOfWeek, startOfMonth),\n      this.getUserReportManagement(),\n      this.getContentAnalytics(),\n      this.getUserManagement(),\n      this.getReviewAndCommentMetrics(),\n      this.getModerationQueue(),\n      this.getModeratorPerformance(moderatorId)\n    ])\n\n    return {\n      contentModerationOverview,\n      moderationActivity,\n      userReportManagement,\n      contentAnalytics,\n      userManagement,\n      reviewAndCommentMetrics,\n      moderationQueue,\n      moderatorPerformance\n    }\n  }\n\n  private async getContentModerationOverview() {\n    const flaggedReviews = await prisma.review.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const flaggedComments = await prisma.comment.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const awaitingModeration = await prisma.review.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    }) + await prisma.comment.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const recentFlaggedContent = await prisma.review.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 5,\n      orderBy: { updatedAt: 'desc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    return {\n      totalFlaggedContent: flaggedReviews + flaggedComments,\n      awaitingModeration,\n      recentFlaggedContent\n    }\n  }\n\n  private async getModerationActivity(moderatorId: string, startOfDay: Date, startOfWeek: Date, startOfMonth: Date) {\n    const moderatedLast24Hours = await this.getModeratedCount(moderatorId, startOfDay)\n    const moderatedLast7Days = await this.getModeratedCount(moderatorId, startOfWeek)\n    const moderatedLast30Days = await this.getModeratedCount(moderatorId, startOfMonth)\n\n    return {\n      moderatedLast24Hours,\n      moderatedLast7Days,\n      moderatedLast30Days\n    }\n  }\n\n  private async getModeratedCount(moderatorId: string, startDate: Date) {\n    const reviewCount = await prisma.review.count({\n      where: {\n        votes: {\n          some: {\n            userId: moderatorId,\n            createdAt: { gte: startDate }\n          }\n        }\n      }\n    })\n\n    const commentCount = await prisma.comment.count({\n      where: {\n        votes: {\n          some: {\n            userId: moderatorId,\n            createdAt: { gte: startDate }\n          }\n        }\n      }\n    })\n\n    return reviewCount + commentCount\n  }\n\n  private async getUserReportManagement() {\n    // Note: This method assumes you have a UserReport model. If not, you may need to adjust this.\n    const recentReports = await prisma.supportTicket.findMany({\n      where: { type: 'USER_REPORT' },\n      take: 10,\n      orderBy: { createdAt: 'desc' },\n      include: {\n        user: { select: { email: true } }\n      }\n    })\n\n    const openReports = await prisma.supportTicket.count({\n      where: { \n        type: 'USER_REPORT',\n        status: 'todo'\n      }\n    })\n\n    return { recentReports, openReports }\n  }\n\n  private async getContentAnalytics() {\n    const activeDiscussions = await prisma.codeRepo.findMany({\n      take: 5,\n      orderBy: { reviews: { _count: 'desc' } },\n      select: {\n        id: true,\n        name: true,\n        _count: { select: { reviews: true } }\n      }\n    })\n\n    // Trending topics would require more complex text analysis\n    // This is a simplified version looking at frequent words in recent reviews\n    const recentReviews = await prisma.review.findMany({\n      take: 100,\n      orderBy: { createdAt: 'desc' },\n      select: { content: true }\n    })\n\n    const words = recentReviews.flatMap(review => review.content.split(/\s+/))\n    const wordFrequency = words.reduce((acc, word) => {\n      acc[word] = (acc[word] || 0) + 1\n      return acc\n    }, {} as Record<string, number>)\n\n    const trendingTopics = Object.entries(wordFrequency)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([word]) => word)\n\n    return { activeDiscussions, trendingTopics }\n  }\n\n  private async getUserManagement() {\n    const recentBans = await prisma.user.findMany({\n      where: { bannedUntil: { not: null } },\n      take: 5,\n      orderBy: { bannedUntil: 'desc' },\n      select: { id: true, email: true, bannedUntil: true }\n    })\n\n    const usersWithMultipleFlags = await prisma.user.findMany({\n      where: {\n        OR: [\n          { reviews: { some: { flag: { not: UserCommentFlag.NONE } } } },\n          { comments: { some: { flag: { not: UserCommentFlag.NONE } } } }\n        ]\n      },\n      take: 10,\n      select: {\n        id: true,\n        email: true,\n        _count: {\n          select: {\n            reviews: { where: { flag: { not: UserCommentFlag.NONE } } },\n            comments: { where: { flag: { not: UserCommentFlag.NONE } } }\n          }\n        }\n      },\n      orderBy: {\n        reviews: { _count: 'desc' }\n      }\n    })\n\n    return { recentBans, usersWithMultipleFlags }\n  }\n\n  private async getReviewAndCommentMetrics() {\n    const totalReviews = await prisma.review.count()\n    const totalComments = await prisma.comment.count()\n\n    const averageRating = await prisma.review.aggregate({\n      _avg: { rating: true }\n    })\n\n    const ratingDistribution = await prisma.review.groupBy({\n      by: ['rating'],\n      _count: true\n    })\n\n    return {\n      totalReviews,\n      totalComments,\n      averageRating: averageRating._avg.rating || 0,\n      ratingDistribution: ratingDistribution.reduce((acc, { rating, _count }) => {\n        acc[rating] = _count\n        return acc\n      }, {} as Record<number, number>)\n    }\n  }\n\n  private async getModerationQueue() {\n    const pendingReviews = await prisma.review.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 10,\n      orderBy: { createdAt: 'asc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    const pendingComments = await prisma.comment.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 10,\n      orderBy: { createdAt: 'asc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    return { pendingReviews, pendingComments }\n  }\n\n  private async getModeratorPerformance(moderatorId: string) {\n    const moderatedReviews = await prisma.vote.findMany({\n      where: {\n        userId: moderatorId,\n        review: { isNot: null }\n      },\n      select: { createdAt: true, review: { select: { createdAt: true } } }\n    })\n\n    const moderatedComments = await prisma.vote.findMany({\n      where: {\n        userId: moderatorId,\n        comment: { isNot: null }\n      },\n      select: { createdAt: true, comment: { select: { createdAt: true } } }\n    })\n\n    const allModeratedItems = [\n      ...moderatedReviews.map(r => ({ moderatedAt: r.createdAt, createdAt: r.review!.createdAt })),\n      ...moderatedComments.map(c => ({ moderatedAt: c.createdAt, createdAt: c.comment!.createdAt }))\n    ]\n\n    const totalResponseTime = allModeratedItems.reduce((total, item) => {\n      return total + (item.moderatedAt.getTime() - item.createdAt.getTime())\n    }, 0)\n\n    const averageResponseTime = allModeratedItems.length > 0\n      ? totalResponseTime / allModeratedItems.length / (1000 * 60 * 60) // Convert to hours\n      : 0\n\n    return {\n      totalModeratedItems: allModeratedItems.length,\n      averageResponseTime\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\order_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Prisma, OrderStatus } from '@prisma/client'\n\n@inject()\nexport default class OrderService {\n  async createOrder(\n    data: {\n      userId: string\n      repoId: string\n      amount: number\n      status: OrderStatus\n      stripePaymentIntentId: string\n    },\n    tx?: Prisma.TransactionClient\n  ) {\n    const db = tx || prisma\n    return await db.order.create({\n      data: {\n        userId: data.userId,\n        codeRepoId: data.repoId,\n        totalAmount: data.amount,\n        status: data.status,\n        stripePaymentIntentId: data.stripePaymentIntentId,\n      },\n    })\n  }\n\n  async getOrderById(orderId: string) {\n    return await prisma.order.findUnique({\n      where: { id: orderId },\n    })\n  }\n\n  async updateOrderStatus(orderId: string, status: OrderStatus, tx?: Prisma.TransactionClient) {\n    const db = tx || prisma\n    return await db.order.update({\n      where: { id: orderId },\n      data: { status },\n    })\n  }\n\n  async getOrderByStripePaymentIntentId(paymentIntentId: string) {\n    return await prisma.order.findFirst({\n      where: { stripePaymentIntentId: paymentIntentId },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\payout_request_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { PayoutRequest, PayoutRequestStatus, SellerProfile, SellerVerificationStatus, Payout, Prisma, BankAccount, Order } from '@prisma/client'\nimport { DateTime } from 'luxon'\nimport { z } from 'zod'\n\nconst MINIMUM_PAYOUT_AMOUNT = 50\nconst COOLDOWN_PERIOD_DAYS = 7\n\nconst createPayoutRequestSchema = z.object({\n  totalAmount: z.number().positive(),\n})\n\ntype CreatePayoutRequestData = z.infer<typeof createPayoutRequestSchema>\n\n@inject()\nexport default class PayoutRequestService {\n  /**\n   * Create a new payout request.\n   * @param {string} userId - The user ID of the seller.\n   * @param {CreatePayoutRequestData} data - The payout request data.\n   * @returns {Promise<PayoutRequest>} The created payout request.\n   * @throws {Error} If the seller profile is not found, not verified, or other validation errors.\n   */\n  public async createPayoutRequest(userId: string, data: CreatePayoutRequestData): Promise<PayoutRequest> {\n    const validatedData = createPayoutRequestSchema.parse(data)\n\n    return prisma.$transaction(async (tx) => {\n      const sellerProfile = await tx.sellerProfile.findUnique({\n        where: { userId },\n        include: { user: true },\n      })\n      if (!sellerProfile) {\n        throw new Error('Seller profile not found')\n      }\n\n      if (sellerProfile.verificationStatus !== SellerVerificationStatus.APPROVED) {\n        throw new Error('Seller is not verified')\n      }\n\n      const lastPayoutDate = sellerProfile.lastPayoutDate || new Date(0)\n      const cooldownPeriod = DateTime.fromJSDate(lastPayoutDate).plus({ days: COOLDOWN_PERIOD_DAYS }).startOf('day')\n      const now = DateTime.utc().startOf('day')\n\n      if (now < cooldownPeriod) {\n        throw new Error('Cooldown period has not elapsed since last payout request')\n      }\n\n      if (validatedData.totalAmount < MINIMUM_PAYOUT_AMOUNT) {\n        throw new Error(`Minimum payout amount is $${MINIMUM_PAYOUT_AMOUNT}`)\n      }\n\n      if (validatedData.totalAmount > sellerProfile.balance) {\n        throw new Error('Requested amount exceeds available balance')\n      }\n\n      const payoutRequest = await tx.payoutRequest.create({\n        data: {\n          sellerProfileId: sellerProfile.id,\n          totalAmount: validatedData.totalAmount,\n          status: PayoutRequestStatus.PENDING,\n        },\n      })\n\n      await tx.sellerProfile.update({\n        where: { id: sellerProfile.id },\n        data: {\n          lastPayoutDate: now.toJSDate(),\n          balance: {\n            decrement: validatedData.totalAmount,\n          },\n        },\n      })\n\n      return payoutRequest\n    })\n  }\n\n  /**\n   * Get the balance and last payout request date for a seller.\n   * @param {string} userId - The user ID of the seller.\n   * @returns {Promise<{ balance: number; lastPayoutRequestDate: Date | null }>} The seller's balance and last payout request date.\n   * @throws {Error} If the seller profile is not found.\n   */\n  public async getSellerBalance(userId: string): Promise<{ balance: number; lastPayoutRequestDate: Date | null }> {\n    const sellerProfile = await prisma.sellerProfile.findUnique({\n      where: { userId },\n      select: { balance: true, lastPayoutDate: true },\n    })\n\n    if (!sellerProfile) {\n      throw new Error('Seller profile not found')\n    }\n\n    return {\n      balance: sellerProfile.balance,\n      lastPayoutRequestDate: sellerProfile.lastPayoutDate,\n    }\n  }\n\n  /**\n   * Get a payout request by its ID.\n   * @param {string} id - The payout request ID.\n   * @returns {Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }>} The payout request with related data.\n   * @throws {Error} If the payout request is not found.\n   */\n  public async getPayoutRequestById(id: string): Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }> {\n    const payoutRequest = await prisma.payoutRequest.findUnique({\n      where: { id },\n      include: {\n        sellerProfile: {\n          include: { bankAccount: true },\n        },\n        orders: true,\n      },\n    })\n    if (!payoutRequest) {\n      throw new Error('PayoutRequest not found')\n    }\n    return payoutRequest\n  }\n\n  /**\n   * Update a payout request's status.\n   * @param {string} id - The payout request ID.\n   * @param {Partial<PayoutRequestStatus>} data - The updated status data.\n   * @returns {Promise<PayoutRequest>} The updated payout request.\n   */\n  public async updatePayoutRequest(id: string, data: Partial<PayoutRequestStatus>): Promise<PayoutRequest> {\n    return prisma.payoutRequest.update({\n      where: { id },\n      data: {\n        status: data,\n      },\n    })\n  }\n\n  /**\n   * Delete a payout request.\n   * @param {string} id - The payout request ID.\n   * @returns {Promise<PayoutRequest>} The deleted payout request.\n   */\n  public async deletePayoutRequest(id: string): Promise<PayoutRequest> {\n    return prisma.payoutRequest.delete({ where: { id } })\n  }\n\n  /**\n   * Get paginated payout requests.\n   * @param {number} page - The page number.\n   * @param {number} limit - The number of items per page.\n   * @returns {Promise<{ data: PayoutRequest[]; meta: { total: number; page: number; limit: number } }>} Paginated payout requests.\n   */\n  public async getPaginatedPayoutRequests(page: number, limit: number): Promise<{ data: PayoutRequest[]; meta: { total: number; page: number; limit: number } }> {\n    const totalCount = await prisma.payoutRequest.count()\n    const payoutRequests = await prisma.payoutRequest.findMany({\n      skip: (page - 1) * limit,\n      take: limit,\n      include: {\n        sellerProfile: {\n          include: { user: true },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    })\n\n    return {\n      data: payoutRequests,\n      meta: {\n        total: totalCount,\n        page,\n        limit,\n      },\n    }\n  }\n\n  /**\n   * Get all payout requests for approved sellers.\n   * @returns {Promise<PayoutRequest[]>} All payout requests for approved sellers.\n   */\n  public async getAllPayoutRequests(): Promise<PayoutRequest[]> {\n    return await prisma.payoutRequest.findMany({\n      where: {\n        sellerProfile: {\n          verificationStatus: SellerVerificationStatus.APPROVED,\n        },\n      },\n      include: {\n        sellerProfile: {\n          include: {\n            user: {\n              select: { email: true, role: true, bannedUntil: true, deletedAt: true },\n            },\n            bankAccount: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Get payout requests for a specific user.\n   * @param {string} userId - The user ID.\n   * @returns {Promise<PayoutRequest[]>} Payout requests for the user.\n   * @throws {Error} If the seller profile is not found.\n   */\n  public async getPayoutRequestsByUser(userId: string): Promise<PayoutRequest[]> {\n    const sellerProfile = await prisma.sellerProfile.findUnique({ where: { userId } })\n    if (!sellerProfile) {\n      throw new Error('Seller profile not found')\n    }\n\n    return prisma.payoutRequest.findMany({\n      where: { sellerProfileId: sellerProfile.id },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Process a payout request.\n   * @param {string} id - The payout request ID.\n   * @param {'approve' | 'reject'} action - The action to take.\n   * @param {string} adminId - The ID of the admin processing the request.\n   * @returns {Promise<PayoutRequest>} The processed payout request.\n   * @throws {Error} If the payout request is not found or not in a pending state.\n   */\n  public async processPayoutRequest(id: string, action: 'approve' | 'reject', adminId: string): Promise<PayoutRequest> {\n    return prisma.$transaction(async (tx) => {\n      const payoutRequest = await tx.payoutRequest.findUnique({\n        where: { id },\n        include: { sellerProfile: true },\n      })\n\n      if (!payoutRequest) {\n        throw new Error('PayoutRequest not found')\n      }\n\n      if (payoutRequest.status !== PayoutRequestStatus.PENDING) {\n        throw new Error('PayoutRequest is not in a pending state')\n      }\n\n      if (action === 'approve') {\n        await tx.payout.create({\n          data: {\n            sellerProfileId: payoutRequest.sellerProfileId,\n            payoutRequestId: payoutRequest.id,\n            totalAmount: payoutRequest.totalAmount,\n            currency: 'MYR',\n          },\n        })\n\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: PayoutRequestStatus.PROCESSED,\n            processedAt: DateTime.utc().toJSDate(),\n          },\n        })\n      } else {\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: PayoutRequestStatus.REJECTED,\n            processedAt: DateTime.utc().toJSDate(),\n          },\n        })\n\n        // Refund the amount back to the seller's balance\n        await tx.sellerProfile.update({\n          where: { id: payoutRequest.sellerProfileId },\n          data: {\n            balance: {\n              increment: payoutRequest.totalAmount,\n            },\n          },\n        })\n      }\n\n      return tx.payoutRequest.findUnique({\n        where: { id },\n        include: {\n          sellerProfile: {\n            include: { bankAccount: true },\n          },\n          orders: true,\n        },\n      }) as Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }>\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\payout_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Payout, PayoutRequest, Prisma } from '@prisma/client'\nimport { z } from 'zod'\n\nconst createPayoutSchema = z.object({\n  payoutRequestId: z.string().cuid(),\n  sellerProfileId: z.string().cuid(),\n  amount: z.number().positive(),\n  currency: z.string().default('MYR'),\n})\n\ntype CreatePayoutData = z.infer<typeof createPayoutSchema>\n\n@inject()\nexport default class PayoutService {\n  /**\n   * Create a new payout.\n   * @param {CreatePayoutData} data - The payout data.\n   * @returns {Promise<Payout>} The created payout.\n   */\n  public async createPayout(data: CreatePayoutData): Promise<Payout> {\n    const validatedData = createPayoutSchema.parse(data)\n    return prisma.payout.create({\n      data: {\n        payoutRequestId: validatedData.payoutRequestId,\n        sellerProfileId: validatedData.sellerProfileId,\n        totalAmount: validatedData.amount,\n        currency: validatedData.currency,\n      },\n    })\n  }\n\n  /**\n   * Get a payout by its ID.\n   * @param {string} id - The payout ID.\n   * @returns {Promise<Payout>} The payout.\n   * @throws {Error} If the payout is not found.\n   */\n  public async getPayoutById(id: string): Promise<Payout> {\n    const payout = await prisma.payout.findUnique({ where: { id } })\n    if (!payout) {\n      throw new Error('Payout not found')\n    }\n    return payout\n  }\n\n  /**\n   * Get all payouts for a specific seller profile.\n   * @param {string} sellerProfileId - The seller profile ID.\n   * @returns {Promise<Payout[]>} An array of payouts.\n   */\n  public async getPayoutsBySellerProfile(sellerProfileId: string): Promise<Payout[]> {\n    return prisma.payout.findMany({\n      where: { sellerProfileId },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Process a payout request.\n   * @param {string} id - The payout request ID.\n   * @param {'approve' | 'reject'} action - The action to take.\n   * @returns {Promise<Payout | null>} The processed payout or null if rejected.\n   * @throws {Error} If the payout request is not found or not in a pending state.\n   */\n  public async processPayoutRequest(id: string, action: 'approve' | 'reject'): Promise<Payout | null> {\n    return prisma.$transaction(async (tx) => {\n      const payoutRequest = await tx.payoutRequest.findUnique({\n        where: { id },\n        include: { sellerProfile: true },\n      })\n\n      if (!payoutRequest) {\n        throw new Error('Payout request not found')\n      }\n\n      if (payoutRequest.status !== 'PENDING') {\n        throw new Error('Payout request is not in a pending state')\n      }\n\n      if (action === 'approve') {\n        const payout = await tx.payout.create({\n          data: {\n            sellerProfileId: payoutRequest.sellerProfileId,\n            payoutRequestId: payoutRequest.id,\n            totalAmount: payoutRequest.totalAmount,\n            currency: 'MYR',\n          },\n        })\n\n        await tx.sellerProfile.update({\n          where: { id: payoutRequest.sellerProfileId },\n          data: {\n            lastPayoutDate: new Date(),\n            balance: {\n              decrement: payoutRequest.totalAmount,\n            },\n          },\n        })\n\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: 'PROCESSED',\n            processedAt: new Date(),\n          },\n        })\n\n        return payout\n      } else {\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: 'REJECTED',\n            processedAt: new Date(),\n          },\n        })\n\n        return null\n      }\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\prisma_service.ts</source>
<document_content>import { PrismaClient } from '@prisma/client'\nimport pg from 'pg'\nimport { PrismaPg } from '@prisma/adapter-pg'\nimport env from '#start/env'\n\nconst { Pool } = pg\n\nconst connectionString = `${env.get('DATABASE_URL')}`\n\nconst pool = new Pool({ connectionString })\n\nconst adapter = new PrismaPg(pool)\nexport const prisma = new PrismaClient({ adapter })\n\nexport type PrismaTransactionalClient = Parameters<Parameters<PrismaClient['$transaction']>[0]>[0]\n// export const prisma = new PrismaClient({});\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\profile_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { z } from 'zod'\nimport { s3Facade } from '#integrations/s3/s3_facade'\nimport { MultipartFile } from '@adonisjs/core/bodyparser'\nimport { Request } from '@adonisjs/core/http'\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n  phoneNumber: z.string().optional(),\n})\n\nexport class ProfileService {\n  /**\n   * @createProfile\n   * @description Create a new user profile\n   * @param {string} userId - The ID of the user\n   * @param {object} profileData - The profile data to be created\n   * @returns {Promise<object>} The created profile and signed URL for the profile image\n   */\n  async createProfile(userId: string, profileData: z.infer<typeof createProfileSchema>) {\n    const validatedData = createProfileSchema.parse(profileData)\n\n    return await prisma.$transaction(async (tx) => {\n      const existingProfile = await tx.profile.findUnique({ where: { userId } })\n      if (existingProfile) {\n        throw new Error('Profile already exists for this user')\n      }\n\n      let mediaId: string | undefined\n      let signedUrl: string | undefined\n\n      const profile = await tx.profile.create({\n        data: {\n          name: validatedData.name,\n          phoneNumber: validatedData.phoneNumber,\n          profileImg: mediaId ?? null,\n          user: { connect: { id: userId } },\n        },\n      })\n\n      return { profile, signedUrl }\n    })\n  }\n\n  /**\n   * @getProfile\n   * @description Get a user's profile\n   * @param {string} userId - The ID of the user\n   * @returns {Promise<object | null>} The user's profile or null if not found\n   */\n  async getProfile(userId: string) {\n    const profile = await prisma.profile.findUnique({\n      where: { userId },\n      include: { user: true },\n    })\n\n    if (profile && profile.profileImg) {\n      const media = await prisma.media.findUnique({ where: { id: profile.profileImg } })\n      if (media) {\n        const signedUrl = await s3Facade.getSignedUrl(media.url.split('/').pop()!)\n        return { ...profile, profileImgUrl: signedUrl }\n      }\n    }\n\n    return profile\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_access_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { PrismaTransactionalClient } from '#services/prisma_service'\nimport { OrderStatus, UserRepoAccess, Role } from '@prisma/client'\nimport { generateIdFromEntropySize } from 'lucia'\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class RepoAccessService {\n  /**\n   * Check if a user has access to a specific repo\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param tx - Prisma transactional client\n   * @returns A boolean indicating whether the user has access\n   */\n  public async hasAccess(\n    userId: string,\n    repoId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<boolean> {\n    const user = await tx.user.findUnique({ where: { id: userId } })\n    if (!user) {\n      return false\n    }\n\n    if (user.role === Role.ADMIN) {\n      return true\n    }\n\n    const access = await tx.userRepoAccess.findUnique({\n      where: {\n        userId_repoId: {\n          userId,\n          repoId,\n        },\n      },\n    })\n\n    if (!access) {\n      return false\n    }\n\n    // Check if access has expired\n    if (access.expiresAt && access.expiresAt < new Date()) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Grant access to a repo for a user based on a successful order\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param orderId - The ID of the completed order\n   * @param tx - Prisma transactional client\n   * @returns A boolean indicating whether access was successfully granted\n   */\n  public async grantAccess(\n    userId: string,\n    repoId: string,\n    orderId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<boolean> {\n    try {\n      const order = await tx.order.findUnique({\n        where: { id: orderId },\n        include: { codeRepo: true },\n      })\n\n      if (!order || order.status !== OrderStatus.SUCCEEDED) {\n        console.error(`Invalid order or order not completed: ${orderId}`)\n        return false\n      }\n\n      if (order.codeRepoId !== repoId || order.userId !== userId) {\n        console.error(`Order ${orderId} does not match the provided user and repo`)\n        return false\n      }\n\n      await this.upsertUserRepoAccess(userId, repoId, orderId, tx)\n      return true\n    } catch (error) {\n      console.error(`Error granting access for order ${orderId}:`, error)\n      return false\n    }\n  }\n\n  /**\n   * Create or update a UserRepoAccess entry\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param orderId - The ID of the order\n   * @param tx - Prisma transactional client\n   * @returns The created or updated UserRepoAccess entry\n   */\n  private async upsertUserRepoAccess(\n    userId: string,\n    repoId: string,\n    orderId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<UserRepoAccess> {\n    return tx.userRepoAccess.upsert({\n      where: {\n        userId_repoId: {\n          userId,\n          repoId,\n        },\n      },\n      update: {\n        orderId,\n        grantedAt: new Date(),\n        expiresAt: null, // Reset expiration if updating\n      },\n      create: {\n        id: generateIdFromEntropySize(32),\n        userId,\n        repoId,\n        orderId,\n        grantedAt: new Date(),\n      },\n    })\n  }\n\n\n  /**\n   * Get all repos a user has access to\n   * @param userId - The ID of the user\n   * @param tx - Prisma transactional client\n   * @returns An array of repo IDs the user has access to\n   */\n  public async getUserAccessibleRepos(\n    userId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<string[]> {\n    try {\n      const accesses = await tx.userRepoAccess.findMany({\n        where: {\n          userId,\n          OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],\n        },\n        select: { repoId: true },\n      })\n\n      return accesses.map((access) => access.repoId)\n    } catch (error) {\n      logger.error(`Error retrieving accessible repos for user ${userId}:`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Get all users who have access to a specific repo\n   * @param repoId - The ID of the repo\n   * @param tx - Prisma transactional client\n   * @returns An array of user IDs who have access to the repo\n   */\n  public async getRepoAccessibleUsers(\n    repoId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<string[]> {\n    const accesses = await tx.userRepoAccess.findMany({\n      where: {\n        repoId,\n        OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],\n      },\n      select: { userId: true },\n    })\n\n    return accesses.map((access) => access.userId)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_search_service.ts</source>
<document_content>import { Kysely, sql, SelectQueryBuilder, Expression, SqlBool } from 'kysely'\nimport { Language, Visibility, SellerVerificationStatus } from '@prisma/client'\nimport { DB } from '#database/kysely/types'\nimport { kyselyDb } from '#database/kysely'\nimport logger from '@adonisjs/core/services/logger'\nimport { generateIdFromEntropySize } from 'lucia'\n\nexport interface SearchCriteria {\n  query?: string\n  tags?: string[]\n  minPrice?: number\n  maxPrice?: number\n  language?: Language\n  visibility?: Visibility\n}\n\ninterface CodeRepoSearchResult {\n  id: string\n  name: string\n  description: string | null\n  language: Language\n  price: number\n  visibility: Visibility\n  tags: string[]\n  createdAt: Date\n}\n\ntype CodeRepoSearchQuery = SelectQueryBuilder<\n  DB,\n  'CodeRepo' | 'TagsOnRepos' | 'Tag' | 'User' | 'SellerProfile',\n  any\n>\n\nexport class CodeRepoSearchBuilder {\n  private db: Kysely<DB>\n  private searchCriteria: SearchCriteria\n  private query: CodeRepoSearchQuery\n  private userId?: string\n\n  constructor(db: Kysely<DB>) {\n    this.db = db\n    this.searchCriteria = {}\n    this.query = this.db\n      .selectFrom('CodeRepo')\n      .leftJoin('TagsOnRepos', 'CodeRepo.id', 'TagsOnRepos.codeRepoId')\n      .leftJoin('Tag', 'TagsOnRepos.tagId', 'Tag.id')\n      .innerJoin('User', 'CodeRepo.userId', 'User.id')\n      .innerJoin('SellerProfile', 'User.id', 'SellerProfile.userId')\n      .select([\n        'CodeRepo.id',\n        'CodeRepo.name',\n        'CodeRepo.description',\n        'CodeRepo.language',\n        'CodeRepo.price',\n        'CodeRepo.visibility',\n        'CodeRepo.createdAt',\n        sql<string[]>`array_agg(DISTINCT \"Tag\".\"name\")`.as('tags'),\n      ])\n      .where('SellerProfile.verificationStatus', '=', SellerVerificationStatus.APPROVED)\n      .where('CodeRepo.deletedAt', 'is', null) // Exclude soft-deleted repos\n      .groupBy([\n        'CodeRepo.id',\n        'CodeRepo.name',\n        'CodeRepo.description',\n        'CodeRepo.language',\n        'CodeRepo.price',\n        'CodeRepo.visibility',\n        'CodeRepo.createdAt',\n      ])\n  }\n\n  withQuery(query?: string): this {\n    if (query) {\n      this.searchCriteria.query = query\n      const searchTerms = query.split(' ').filter((term) => term.length > 0)\n      this.query = this.query.where((eb) => {\n        const conditions = searchTerms.map((term) =>\n          eb.or([\n            eb('CodeRepo.name', 'ilike', `%${term}%`),\n            eb('CodeRepo.description', 'ilike', `%${term}%`),\n          ])\n        )\n        return eb.and(conditions)\n      })\n    }\n    return this\n  }\n\n  withTags(tags?: string[]): this {\n    if (tags && tags.length > 0) {\n      this.searchCriteria.tags = tags\n      this.query = this.query.where('Tag.name', 'in', tags)\n    }\n    return this\n  }\n\n  withPriceRange(minPrice?: number, maxPrice?: number): this {\n    if (minPrice !== undefined) {\n      this.searchCriteria.minPrice = minPrice\n      this.query = this.query.where('CodeRepo.price', '>=', minPrice)\n    }\n    if (maxPrice !== undefined) {\n      this.searchCriteria.maxPrice = maxPrice\n      this.query = this.query.where('CodeRepo.price', '<=', maxPrice)\n    }\n    return this\n  }\n\n  withLanguage(language?: Language): this {\n    if (language) {\n      this.searchCriteria.language = language\n      this.query = this.query.where('CodeRepo.language', '=', language)\n    }\n    return this\n  }\n\n  withVisibility(visibility?: Visibility): this {\n    if (visibility) {\n      this.searchCriteria.visibility = visibility\n      this.query = this.query.where('CodeRepo.visibility', '=', visibility)\n    }\n    return this\n  }\n\n  withUserId(userId?: string): this {\n    if (userId) this.userId = userId\n    return this\n  }\n\n  private async saveSearchHistory(): Promise<void> {\n    if (!this.userId || !this.searchCriteria.query) {\n      return\n    }\n\n    try {\n      const test = new Date()\n      await this.db\n        .insertInto('SearchHistory')\n        .values({\n          id: generateIdFromEntropySize(32),\n          userId: this.userId,\n          tag: this.searchCriteria.query,\n          createdAt: test,\n        })\n        .execute()\n    } catch (error) {\n      logger.error({ error }, 'Error saving search history')\n    }\n  }\n\n  build(): CodeRepoSearchQuery {\n    this.saveSearchHistory().catch((error) => {\n      logger.error({ error }, 'Error saving search history')\n    })\n\n    return this.query\n  }\n}\n\nexport default class CodeRepoSearchService {\n  private db: Kysely<DB>\n\n  constructor() {\n    this.db = kyselyDb\n  }\n\n  async search(criteria: SearchCriteria, userId?: string, page: number = 1, pageSize: number = 10) {\n    const offset = (page - 1) * pageSize\n\n    const builder = new CodeRepoSearchBuilder(this.db)\n      .withQuery(criteria.query)\n      .withTags(criteria.tags)\n      .withPriceRange(criteria.minPrice, criteria.maxPrice)\n      .withLanguage(criteria.language)\n      .withVisibility('public' as Visibility)\n      .withUserId(userId)\n\n    try {\n      const query = builder.build()\n\n      // Create a separate count query without GROUP BY\n      const countQuery = this.db\n        .selectFrom('CodeRepo')\n        .leftJoin('TagsOnRepos', 'CodeRepo.id', 'TagsOnRepos.codeRepoId')\n        .leftJoin('Tag', 'TagsOnRepos.tagId', 'Tag.id')\n        .innerJoin('User', 'CodeRepo.userId', 'User.id')\n        .innerJoin('SellerProfile', 'User.id', 'SellerProfile.userId')\n        .select(sql<number>`count(distinct \"CodeRepo\".\"id\")`.as('count'))\n        .where((eb) => {\n          const conditions: Expression<SqlBool>[] = [\n            eb('SellerProfile.verificationStatus', '=', SellerVerificationStatus.APPROVED),\n            eb('CodeRepo.deletedAt', 'is', null), // Exclude soft-deleted repos\n          ]\n\n          if (criteria.tags && criteria.tags.length > 0) {\n            conditions.push(eb('Tag.name', 'in', criteria.tags))\n          }\n          if (criteria.query) {\n            const searchTerms = criteria.query.split(' ').filter((term) => term.length > 0)\n            const searchConditions = searchTerms.map((term) =>\n              eb.or([\n                eb('CodeRepo.name', 'ilike', `%${term}%`),\n                eb('CodeRepo.description', 'ilike', `%${term}%`),\n              ])\n            )\n            conditions.push(eb.and(searchConditions))\n          }\n          if (criteria.minPrice !== undefined) {\n            conditions.push(eb('CodeRepo.price', '>=', criteria.minPrice))\n          }\n          if (criteria.maxPrice !== undefined) {\n            conditions.push(eb('CodeRepo.price', '<=', criteria.maxPrice))\n          }\n          if (criteria.language) {\n            conditions.push(eb('CodeRepo.language', '=', criteria.language))\n          }\n          conditions.push(eb('CodeRepo.visibility', '=', 'public' as Visibility))\n\n          return eb.and(conditions)\n        })\n\n      const resultsQuery = query.limit(pageSize).offset(offset)\n\n      const [totalCountResult, results] = await Promise.all([\n        countQuery.executeTakeFirst(),\n        resultsQuery.execute() as Promise<CodeRepoSearchResult[]>,\n      ])\n\n      const total = Number(totalCountResult?.count || 0)\n\n      // Process the results to format tags\n      const formattedResults = results.map((repo) => ({\n        ...repo,\n        tags: repo.tags?.filter(Boolean) || [], // Remove null values and ensure it's an array\n      }))\n\n      return {\n        data: formattedResults,\n        meta: {\n          total,\n          page,\n          pageSize,\n          lastPage: Math.ceil(total / pageSize),\n        },\n      }\n    } catch (error) {\n      logger.error({ error, stack: error.stack }, 'Error executing search query')\n      throw new Error('An error occurred while executing the search query')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_service.ts</source>
<document_content>import { sql } from 'kysely'\nimport { CodeRepo, OrderStatus, Tag } from '@prisma/client'\nimport { kyselyDb } from '#database/kysely'\nimport { prisma } from './prisma_service.js'\n\ntype PartialCodeRepo = Omit<CodeRepo, 'sourceJs' | 'sourceCss' | 'userId'> & {\n  sourceJs?: string\n  sourceCss?: string\n  tags?: { tag: Tag }[];\n}\n\ntype RepoCheckoutInfo = {\n  repo: PartialCodeRepo\n  sellerProfileId: string | null\n}\n\nexport default class RepoService {\n  public async createRepo(\n    data: Omit<CodeRepo, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'> & { tags: string[] }\n  ): Promise<CodeRepo> {\n    const repo = await prisma.codeRepo.create({\n      data: {\n        ...data,\n        tags: {\n          create: data.tags.map((tagName) => ({\n            tag: {\n              connectOrCreate: {\n                where: { name: tagName },\n                create: { name: tagName },\n              },\n            },\n          })),\n        },\n      },\n      include: { tags: true },\n    })\n\n    return repo\n  }\n\n public async getRepoById(id: string, userId?: string | null): Promise<CodeRepo | null> {\n    const repo = await prisma.codeRepo.findUnique({\n      where: { \n        id,\n        deletedAt: null // Only return non-deleted repos\n      },\n      include: {\n        tags: true, // Include tags to match the test expectations\n      }\n    })\n    return repo\n  }\n\n  public async updateRepo(\n    id: string,\n    data: Partial<CodeRepo> & { tags?: string[] }\n  ): Promise<CodeRepo> {\n    const { tags, ...otherData } = data\n\n    const updatedRepo = await prisma.codeRepo.update({\n      where: { id },\n      data: {\n        ...otherData,\n        tags: tags\n          ? {\n              deleteMany: {},\n              create: tags.map((tagName) => ({\n                tag: {\n                  connectOrCreate: {\n                    where: { name: tagName },\n                    create: { name: tagName },\n                  },\n                },\n              })),\n            }\n          : undefined,\n      },\n      include: { tags: { include: { tag: true } } },\n    })\n\n    return updatedRepo\n  }\n\n  /**\n   * @getRepoByIdPublic\n   * @description Get a public repo by ID, excluding soft deleted repos.\n   * @param id - The ID of the Repo to retrieve.\n   * @returns Promise<PartialCodeRepo | null> - The partial CodeRepo object or null if not found.\n   */\n  public async getRepoByIdPublic(id: string): Promise<PartialCodeRepo | null> {\n    const repo = await prisma.codeRepo.findFirst({\n      where: {\n        id,\n        deletedAt: null,\n        visibility: 'public'\n      },\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        language: true,\n        price: true,\n        visibility: true,\n        status: true,\n        createdAt: true,\n        updatedAt: true,\n        deletedAt: true,\n        tags: {\n          select: {\n            tag: true\n          }\n        }\n      }\n    })\n\n    if (!repo) return null\n\n    return repo;\n  }\n\n\n  /**\n   * Check if a user has purchased a repo.\n   *\n   * @param userId - The ID of the user.\n   * @param repoId - The ID of the repo.\n   * @returns Promise<boolean> - True if the user has purchased the repo, false otherwise.\n   */\n  private async hasPurchased(userId: string, repoId: string): Promise<boolean> {\n    const count = await prisma.order.count({\n      where: {\n        userId,\n        codeRepoId: repoId,\n        status: 'completed' as OrderStatus,\n      },\n    })\n    return count > 0\n  }\n  /**\n   * @softDeleteRepo\n   * @description Soft delete a Repo by ID by setting the deletedAt timestamp.\n   * @param id - The ID of the Repo to soft delete.\n   * @returns Promise<CodeRepo> - The soft deleted CodeRepo object.\n   * @throws Error if the repo is not found or if the operation fails.\n   */\n  public async softDeleteRepo(id: string): Promise<CodeRepo> {\n    return await prisma.$transaction(async (tx) => {\n      const repo = await tx.codeRepo.findUnique({ where: { id } })\n      if (!repo) {\n        throw new Error('Repo not found')\n      }\n      \n      // Always update the repo, even if it's already deleted\n      const softDeletedRepo = await tx.codeRepo.update({\n        where: { id },\n        data: {\n          deletedAt: new Date(),\n          visibility: 'private'\n        },\n      })\n      return softDeletedRepo\n    })\n  }\n\n  /**\n   * Retrieve paginated Repos with public visibility.\n   *\n   * @param page - The page number for pagination.\n   * @param limit - The number of items per page.\n   * @param userId - The ID of the user requesting the pagination (can be null for guests).\n   * @returns Promise<{ data: PartialCodeRepo[]; total: number; page: number; limit: number }> - Paginated results.\n   */\n\n  public async getPaginatedRepos(\n    page: number = 1,\n    limit: number = 10,\n    userId: string | null\n  ): Promise<{ data: PartialCodeRepo[]; total: number; page: number; limit: number }> {\n    const offset = (page - 1) * limit\n\n    let query = kyselyDb\n      .selectFrom('CodeRepo as cr')\n      .leftJoin('TagsOnRepos as tor', 'cr.id', 'tor.codeRepoId')\n      .leftJoin('Tag as t', 'tor.tagId', 't.id')\n      .selectAll('cr')\n      .select('t.name as tagName')\n      .where('cr.visibility', '=', 'public')\n      .where('cr.status', '=', 'active')\n      .distinctOn('cr.id')\n      .limit(limit)\n      .offset(offset)\n\n    if (userId) {\n      // Fetch user's recent search tags\n      const recentTags = await prisma.searchHistory.findMany({\n        where: { userId },\n        orderBy: { createdAt: 'desc' },\n        take: 10, // Adjust as needed\n      })\n\n      const recentTagNames = recentTags.map((tag) => tag.tag)\n\n      // Prioritize repos that match recent search tags\n      query = query\n        .orderBy(\n          sql`CASE WHEN t.name IN (${recentTagNames.map((tag) => `'${tag}'`).join(', ')}) THEN 1 ELSE 2 END`\n        )\n        .orderBy('cr.createdAt', 'desc')\n    }\n\n    const repos = await query.execute()\n    const total = await prisma.codeRepo.count({\n      where: {\n        visibility: 'public',\n        status: 'active',\n      },\n    })\n\n    // Filter out source code for unauthorized users\n    const filteredRepos = await Promise.all(\n      repos.map(async (repo) => {\n        const partialRepo: PartialCodeRepo = { ...repo }\n        if (userId) {\n          const user = await prisma.user.findUnique({ where: { id: userId } })\n          const hasAccess =\n            repo.userId === userId ||\n            user?.role === 'ADMIN' ||\n            (await this.hasPurchased(userId, repo.id))\n\n          if (!hasAccess) {\n            delete partialRepo.sourceJs\n            delete partialRepo.sourceCss\n          }\n        } else {\n          delete partialRepo.sourceJs\n          delete partialRepo.sourceCss\n        }\n        return partialRepo\n      })\n    )\n\n    return { data: filteredRepos, total, page, limit }\n  }\n\n  /**\n   * Record search tag for a user.\n   *\n   * @param userId - The ID of the user.\n   * @param tag - The searched tag.\n   */\n  public async recordSearch(userId: string, tag: string): Promise<void> {\n    await prisma.searchHistory.create({\n      data: {\n        userId,\n        tag,\n      },\n    })\n  }\n\n  /**\n   * Retrieve Repos by user ID.\n   *\n   * @param userId - The user ID to filter by.\n   * @returns Promise<CodeRepo[]> - Array of CodeRepo objects belonging to the user.\n   */\n  public async getReposByUser(userId: string): Promise<CodeRepo[]> {\n    const query = kyselyDb.selectFrom('CodeRepo').selectAll().where('userId', '=', userId)\n    return await query.execute()\n  }\n\n  public async getFeaturedRepos(limit: number = 5): Promise<CodeRepo[]> {\n    const featuredRepos = await prisma.codeRepo.findMany({\n      where: {\n        visibility: 'public',\n        status: 'active',\n      },\n      include: {\n        reviews: true,\n        user: {\n          select: {\n            id: true,\n            email: true,\n            profile: true,\n          },\n        },\n      },\n      orderBy: [{ reviews: { _count: 'desc' } }, { updatedAt: 'desc' }],\n      take: limit,\n    })\n\n    // Calculate average rating for each repo\n    const reposWithRatings = featuredRepos.map((repo) => {\n      const avgRating =\n        repo.reviews.reduce((sum, review) => sum + review.rating, 0) / repo.reviews.length || 0\n      return { ...repo, avgRating }\n    })\n\n    // Sort by average rating and then by number of reviews\n    return reposWithRatings.sort(\n      (a, b) => b.avgRating - a.avgRating || b.reviews.length - a.reviews.length\n    )\n  }\n\n  /**\n   * Get a repo by its ID, including necessary related data for checkout.\n   *\n   * @param id - The ID of the repo.\n   * @returns Promise<RepoCheckoutInfo | null> - The repo data and seller info, or null if not found.\n   */\n  public async getRepoForCheckout(id: string): Promise<RepoCheckoutInfo | null> {\n    const repo = await prisma.codeRepo.findUnique({\n      where: { id },\n      include: {\n        user: {\n          select: {\n            sellerProfile: {\n              select: {\n                id: true,\n              },\n            },\n          },\n        },\n      },\n    })\n\n    if (!repo) return null\n\n    const { sourceJs, sourceCss, user, ...safeRepo } = repo\n    return {\n      repo: safeRepo,\n      sellerProfileId: user?.sellerProfile?.id ?? null,\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\review_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport type { Review, Vote, VoteType } from '@prisma/client'\nimport logger from '@adonisjs/core/services/logger'\n\ninterface ReviewCreationData {\n  content: string\n  userId: string\n  repoId: string\n  rating: number\n}\n\ninterface ReviewUpdateData {\n  content?: string\n  rating?: number\n}\n\nexport class ReviewService {\n  /**\n   * Create a new review.\n   * @param data - The data to create a review.\n   * @returns The created review.\n   */\n  async createReview(data: ReviewCreationData): Promise<Review> {\n    return prisma.review.create({\n      data,\n    })\n  }\n\n  async getPaginatedReviewsByRepo(\n    repoId: string,\n    page: number,\n    perPage: number\n  ): Promise<{\n    data: Review[]\n    meta: {\n      total: number\n      page: number\n      perPage: number\n      lastPage: number\n    }\n  }> {\n    const reviews = await prisma.review.findMany({\n      where: { repoId, deletedAt: null },\n      skip: (page - 1) * perPage,\n      take: perPage,\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            profile: {\n              select: {\n                name: true,\n                profileImg: true,\n              },\n            },\n          },\n        },\n      },\n    })\n    const total = await prisma.review.count({\n      where: { repoId, deletedAt: null },\n    })\n    return {\n      data: reviews,\n      meta: {\n        total,\n        page,\n        perPage,\n        lastPage: Math.ceil(total / perPage),\n      },\n    }\n  }\n\n  /**\n   * Retrieve a review by ID.\n   * @param id - The ID of the review to retrieve.\n   * @returns The retrieved review.\n   */\n  async getReviewById(id: string): Promise<Review | null> {\n    return prisma.review.findUnique({ where: { id, deletedAt: null } })\n  }\n\n  /**\n   * Update a review by ID.\n   * @param id - The ID of the review to update.\n   * @param data - The data to update the review.\n   * @returns The updated review.\n   */\n  async updateReview(id: string, data: ReviewUpdateData): Promise<Review> {\n    return prisma.review.update({ where: { id, deletedAt: null }, data })\n  }\n\n  /**\n   * Soft delete a review by ID.\n   * @param id - The ID of the review to delete.\n   * @returns The deleted review.\n   */\n  async deleteReview(id: string): Promise<Review> {\n    return prisma.review.update({\n      where: { id },\n      data: { deletedAt: new Date() },\n    })\n  }\n\n  /**\n   * Retrieve all flagged reviews.\n   * @returns All flagged reviews.\n   */\n  async getAllFlaggedReviews(): Promise<Review[]> {\n    const reviews = await prisma.review.findMany({\n      where: { deletedAt: null, flag: { not: 'NONE' } },\n      include: { user: true },\n    })\n\n    return reviews.map((r) => ({\n      ...r,\n      user: {\n        email: r.user.email,\n      },\n    }))\n  }\n\n  async revertFlag(id: string): Promise<Review> {\n    return prisma.review.update({\n      where: { id },\n      data: { flag: 'NONE' },\n    })\n  }\n\n  /**\n   * Handle voting on a review.\n   * @param reviewId - The ID of the review to vote on.\n   * @param userId - The ID of the user voting.\n   * @param voteType - The type of vote (UPVOTE or DOWNVOTE).\n   * @returns The updated review.\n   */\n  async handleVote(reviewId: string, userId: string, voteType: VoteType): Promise<Review> {\n    const existingVote = await prisma.vote.findUnique({\n      where: {\n        userId_reviewId: {\n          userId,\n          reviewId,\n        },\n      },\n    })\n\n    return prisma.$transaction(async (tx) => {\n      if (!existingVote) {\n        await tx.vote.create({\n          data: {\n            userId,\n            reviewId,\n            type: voteType,\n          },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { increment: 1 },\n          },\n        })\n      } else if (existingVote.type !== voteType) {\n        await tx.vote.update({\n          where: { id: existingVote.id },\n          data: { type: voteType },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { increment: 1 },\n            [voteType === 'UPVOTE' ? 'downvotes' : 'upvotes']: { decrement: 1 },\n          },\n        })\n      } else {\n        await tx.vote.delete({\n          where: { id: existingVote.id },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { decrement: 1 },\n          },\n        })\n      }\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\sales_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Prisma } from '@prisma/client'\n\n@inject()\nexport default class SalesService {\n  async updateSalesAggregate(sellerId: string, amount: number, tx?: Prisma.TransactionClient) {\n    const db = tx || prisma\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n\n    const existingAggregate = await db.salesAggregate.findUnique({\n      where: {\n        sellerId_date: {\n          sellerId,\n          date: today,\n        },\n      },\n    })\n\n    if (existingAggregate) {\n      return await db.salesAggregate.update({\n        where: { id: existingAggregate.id },\n        data: {\n          revenue: { increment: amount },\n          salesCount: { increment: 1 },\n        },\n      })\n    } else {\n      return await db.salesAggregate.create({\n        data: {\n          sellerId,\n          date: today,\n          revenue: amount,\n          salesCount: 1,\n        },\n      })\n    }\n  }\n\n  async getSalesAggregate(sellerId: string, startDate: Date, endDate: Date) {\n    return await prisma.salesAggregate.findMany({\n      where: {\n        sellerId,\n        date: {\n          gte: startDate,\n          lte: endDate,\n        },\n      },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\seller_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport {\n  SellerProfile,\n  //User,\n  SellerVerificationStatus,\n  PayoutRequest,\n  PayoutRequestStatus,\n} from '@prisma/client'\nimport { PrismaTransactionalClient, prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport {\n  createSellerProfileSchema,\n  updateSellerProfileSchema,\n  createPayoutRequestSchema,\n  UpdateSellerProfileDto,\n} from '#validators/seller'\nimport { S3Facade } from '#integrations/s3/s3_facade'\n\ninterface SalesDataPoint {\n  date: string\n  revenue: number\n  salesCount: number\n}\n\ninterface RecentReview {\n  id: string\n  content: string\n  rating: number\n  createdAt: Date\n  repoName: string\n  userName: string\n}\n\ninterface DashboardData {\n  salesData: SalesDataPoint[]\n  recentReviews: RecentReview[]\n}\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class SellerService {\n  constructor(protected s3Facade: S3Facade) {}\n  /**\n   * Apply for a seller account\n   * @param userId - The ID of the user applying to be a seller\n   * @param profileData - The seller profile and bank account data\n   */\n  public async applyForSellerAccount(userId: string, profileData: any): Promise<SellerProfile> {\n    const validatedData = createSellerProfileSchema.parse(profileData)\n\n    return await prisma.$transaction(async (trx) => {\n      // Update the existing seller profile\n      const updatedProfile = await trx.sellerProfile.update({\n        where: { userId },\n        data: {\n          businessName: validatedData.businessName,\n          businessAddress: validatedData.businessAddress,\n          businessPhone: validatedData.businessPhone,\n          businessEmail: validatedData.businessEmail,\n          verificationStatus: SellerVerificationStatus.PENDING,\n        },\n      })\n\n      // Create or update the bank account\n      await trx.bankAccount.upsert({\n        where: { sellerProfileId: updatedProfile.id },\n        create: {\n          sellerProfileId: updatedProfile.id,\n          accountHolderName: validatedData.accountHolderName,\n          accountNumber: validatedData.accountNumber,\n          bankName: validatedData.bankName,\n          swiftCode: validatedData.swiftCode,\n          iban: validatedData.iban,\n          routingNumber: validatedData.routingNumber,\n        },\n        update: {\n          accountHolderName: validatedData.accountHolderName,\n          accountNumber: validatedData.accountNumber,\n          bankName: validatedData.bankName,\n          swiftCode: validatedData.swiftCode,\n          iban: validatedData.iban,\n          routingNumber: validatedData.routingNumber,\n        },\n      })\n\n      return updatedProfile\n    })\n  }\n\n  /**\n   * Get a seller's profile\n   * @param userId - The ID of the user or seller\n   */\n  public async getSellerProfile(userId: string): Promise<SellerProfile | null> {\n    return await prisma.sellerProfile.findUnique({\n      where: { userId },\n    })\n  }\n\n  /**\n   * Update a seller's profile including bank account details and verification status\n   * @param userId - The ID of the user or seller\n   * @param profileData - The updated profile data\n   */\n  public async updateSellerProfile(\n    userId: string,\n    profileData: UpdateSellerProfileDto\n  ): Promise<SellerProfile> {\n    const validatedData = updateSellerProfileSchema.parse(profileData)\n    const user = await prisma.user.findUnique({ where: { id: userId } })\n    if (!user) {\n      throw new Error('User not found')\n    }\n    try {\n      const updatedProfile = await prisma.sellerProfile.update({\n        where: { userId: user.id },\n        data: {\n          ...(validatedData.businessName && { businessName: validatedData.businessName }),\n          ...(validatedData.businessAddress && { businessAddress: validatedData.businessAddress }),\n          ...(validatedData.businessPhone && { businessPhone: validatedData.businessPhone }),\n          ...(validatedData.businessEmail && { businessEmail: validatedData.businessEmail }),\n          ...(validatedData.verificationStatus && {\n            verificationStatus: validatedData.verificationStatus,\n            ...(validatedData.verificationStatus === 'APPROVED' && {\n              verificationDate: new Date(),\n            }),\n          }),\n          bankAccount: {\n            upsert: {\n              create: {\n                accountHolderName: validatedData.accountHolderName || '',\n                accountNumber: validatedData.accountNumber || '',\n                bankName: validatedData.bankName || '',\n                swiftCode: validatedData.swiftCode || '',\n                iban: validatedData.iban,\n                routingNumber: validatedData.routingNumber,\n              },\n              update: {\n                ...(validatedData.accountHolderName && {\n                  accountHolderName: validatedData.accountHolderName,\n                }),\n                ...(validatedData.accountNumber && { accountNumber: validatedData.accountNumber }),\n                ...(validatedData.bankName && { bankName: validatedData.bankName }),\n                ...(validatedData.swiftCode && { swiftCode: validatedData.swiftCode }),\n                ...(validatedData.iban && { iban: validatedData.iban }),\n                ...(validatedData.routingNumber && { routingNumber: validatedData.routingNumber }),\n              },\n            },\n          },\n        },\n        include: { bankAccount: true },\n      })\n      return updatedProfile\n    } catch (error) {\n      throw new Error(`Failed to update seller profile: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get all seller applications\n   * @param status - Optional filter for verification status\n   */\n  public async getSellerApplications(status?: SellerVerificationStatus): Promise<SellerProfile[]> {\n    return await prisma.sellerProfile.findMany({\n      where: status ? { verificationStatus: status } : undefined,\n      include: { user: true },\n    })\n  }\n\n  /**\n   * Update seller application status\n   * @param sellerId - The ID of the seller profile\n   * @param status - The new verification status\n   */\n  public async updateSellerApplicationStatus(\n    sellerId: string,\n    status: SellerVerificationStatus\n  ): Promise<SellerProfile> {\n    return await prisma.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        verificationStatus: status,\n        verificationDate: status === SellerVerificationStatus.APPROVED ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Get seller's balance\n   * @param userId - The ID of the user or seller\n   */\n  public async getSellerBalance(userId: string): Promise<number> {\n    const profile = await this.getSellerProfile(userId)\n    return profile?.balance ?? 0\n  }\n\n  /**\n   * Request a payout\n   * @param userId - The ID of the user or seller\n   * @param amount - The amount to request for payout\n   */\n  public async requestPayout(userId: string, amount: number): Promise<PayoutRequest> {\n    const validatedData = createPayoutRequestSchema.parse({ amount })\n\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n    if (profile.balance < amount) throw new Error('Insufficient balance')\n\n    return await prisma.payoutRequest.create({\n      data: {\n        sellerProfileId: profile.id,\n        totalAmount: validatedData.amount,\n        status: PayoutRequestStatus.PENDING,\n      },\n    })\n  }\n\n  /**\n   * Get payout history for a seller\n   * @param userId - The ID of the user or seller\n   */\n  public async getPayoutHistory(userId: string): Promise<PayoutRequest[]> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n\n    return await prisma.payoutRequest.findMany({\n      where: { sellerProfileId: profile.id },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Upload or update identity document\n   * @param userId - The ID of the user or seller\n   * @param documentUrl - The URL of the uploaded document\n   */\n  //public async uploadIdentityDocument(userId: string, documentUrl: string): Promise<SellerProfile> {\n  //  return await prisma.sellerProfile.update({\n  //    where: { userId },\n  //    data: {\n  //      identityDoc: documentUrl,\n  //      verificationStatus: SellerVerificationStatus.PENDING,\n  //    },\n  //  })\n  //}\n\n  /**\n   * Verify seller's identity document\n   * @param sellerId - The ID of the seller profile\n   * @param isVerified - Whether the document is verified\n   */\n  public async verifySellerDocument(sellerId: string, isVerified: boolean): Promise<SellerProfile> {\n    return await prisma.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        verificationStatus: isVerified\n          ? SellerVerificationStatus.APPROVED\n          : SellerVerificationStatus.REJECTED,\n        verificationDate: isVerified ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Get all payout requests\n   * @param status - Optional filter for payout request status\n   */\n  public async getPayoutRequests(status?: PayoutRequestStatus): Promise<PayoutRequest[]> {\n    return await prisma.payoutRequest.findMany({\n      where: status ? { status } : undefined,\n      include: { sellerProfile: true },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Update payout request status\n   * @param requestId - The ID of the payout request\n   * @param status - The new status of the payout request\n   */\n  public async updatePayoutRequestStatus(\n    requestId: string,\n    status: PayoutRequestStatus\n  ): Promise<PayoutRequest> {\n    return await prisma.payoutRequest.update({\n      where: { id: requestId },\n      data: {\n        status,\n        processedAt: status === PayoutRequestStatus.PROCESSED ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Upload identity document for a seller\n   * @param userId - The ID of the user or seller\n   * @param file - The PDF file to upload\n   */\n  public async uploadIdentityDocument(userId: string, file: Buffer): Promise<SellerProfile> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n\n    try {\n      const { media } = await this.s3Facade.uploadFile(\n        file,\n        'application/pdf',\n        prisma,\n        'identity-documents'\n      )\n\n      return await prisma.sellerProfile.update({\n        where: { userId },\n        data: {\n          identityDoc: media.url,\n          verificationStatus: SellerVerificationStatus.PENDING,\n        },\n      })\n    } catch (error) {\n      throw new Error(`Failed to upload identity document: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get the signed URL for a seller's identity document\n   * @param userId - The ID of the user or seller\n   */\n  public async getIdentityDocumentUrl(userId: string): Promise<string | null> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile || !profile.identityDoc) return null\n\n    const fileKey = profile.identityDoc.split('/').pop()\n    if (!fileKey) return null\n\n    try {\n      return await this.s3Facade.getSignedUrl(fileKey)\n    } catch (error) {\n      throw new Error(`Failed to get signed URL: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get dashboard data including sales analytics and recent reviews\n   * @param userId - The ID of the user or seller\n   * @param days - Number of days to fetch sales data for (default: 30)\n   */\n  public async getDashboardData(userId: string, days: number = 180): Promise<DashboardData> {\n    const endDate = DateTime.now().endOf('day')\n    const startDate = endDate.minus({ days: days - 1 }).startOf('day')\n\n    // Fetch sales data\n    const salesData = await prisma.salesAggregate.findMany({\n      where: {\n        sellerId: userId,\n        date: {\n          gte: startDate.toJSDate(),\n          lte: endDate.toJSDate(),\n        },\n      },\n      orderBy: { date: 'asc' },\n    })\n\n    // Fill in missing dates with zero values\n    const filledSalesData: SalesDataPoint[] = []\n    let currentDate = startDate\n    while (currentDate <= endDate) {\n      const existingData = salesData.find((d) =>\n        DateTime.fromJSDate(d.date).hasSame(currentDate, 'day')\n      )\n      filledSalesData.push({\n        date: currentDate.toFormat('yyyy-MM-dd'),\n        revenue: existingData?.revenue ?? 0,\n        salesCount: existingData?.salesCount ?? 0,\n      })\n      currentDate = currentDate.plus({ days: 1 })\n    }\n\n    // Fetch recent reviews\n    const recentReviews = await prisma.review.findMany({\n      where: {\n        repo: {\n          userId: userId,\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: 5,\n      include: {\n        repo: {\n          select: { name: true },\n        },\n        user: {\n          select: { email: true },\n        },\n      },\n    })\n\n    const formattedReviews: RecentReview[] = recentReviews.map((review) => ({\n      id: review.id,\n      content: review.content,\n      rating: review.rating,\n      createdAt: review.createdAt,\n      repoName: review.repo.name,\n      userName: review.user.email, // Using email as userName for privacy\n    }))\n\n    return {\n      salesData: filledSalesData,\n      recentReviews: formattedReviews,\n    }\n  }\n\n  public async checkIfSellerVerified(userId: string): Promise<boolean> {\n    const profile = await this.getSellerProfile(userId)\n    return profile?.verificationStatus === SellerVerificationStatus.APPROVED\n  }\n\n  public async updateBalance(sellerId: string, amount: number, tx?: PrismaTransactionalClient) {\n    const db = tx || prisma\n\n    return await db.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        balance: {\n          increment: amount,\n        },\n      },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\support_service.ts</source>
<document_content>import { SupportTicketType, SupportTicketStatus } from '@prisma/client'\nimport { prisma } from './prisma_service.js'\nimport { kyselyDb } from '#database/kysely'\nimport { z } from 'zod'\nimport mail from '@adonisjs/mail/services/main'\nimport { render } from '@react-email/components'\nimport env from '#start/env'\nimport KortexSupportTicketReceived from '#resources/mail-templates/support-received.mail'\n\nexport const ticketSchema = z.object({\n  id: z.string().cuid(),\n  email: z.string().email(),\n  title: z.string().min(1),\n  content: z.string().min(1),\n  status: z.nativeEnum(SupportTicketStatus),\n  type: z.nativeEnum(SupportTicketType),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n})\n\nexport const newTicketSchema = z.object({\n  email: z.string().email(),\n  title: z.string().min(1),\n  content: z.string().min(1),\n  type: z.nativeEnum(SupportTicketType),\n})\n\n/**\n * Service class for handling support ticket operations.\n */\nexport default class SupportTicketService {\n  /**\n   * Creates a new support ticket.\n   *\n   * @param email - The email address of the user.\n   * @param title - The title of the support ticket.\n   * @param content - The content of the support ticket.\n   * @param type - The type of the support ticket.\n   * @returns The created support ticket.\n   */\n  public async createTicket(\n    email: string,\n    title: string,\n    content: string,\n    type: SupportTicketType\n  ) {\n    const validatedData = newTicketSchema.parse({ email, title, content, type })\n\n    try {\n      const ticket = await prisma.supportTicket.create({\n        data: validatedData,\n      })\n      return ticket\n    } catch (error: any) {\n      throw new Error(`Failed to create ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves paginated support tickets.\n   *\n   * @param page - The page number for pagination.\n   * @param limit - The number of tickets per page.\n   * @returns An object containing the tickets and pagination metadata.\n   */\n  //public async getPaginatedTickets(page: number = 1, limit: number = 10) {\n  //  const offset = (page - 1) * limit\n  //  try {\n  //    const [tickets, total] = await Promise.all([\n  //      prisma.supportTicket.findMany({\n  //        skip: offset,\n  //        take: limit,\n  //        orderBy: { createdAt: 'desc' },\n  //      }),\n  //      prisma.supportTicket.count(),\n  //    ])\n  //\n  //    return {\n  //      data: tickets,\n  //      meta: {\n  //        total,\n  //        page,\n  //        limit,\n  //        lastPage: Math.ceil(total / limit),\n  //      },\n  //    }\n  //  } catch (error: any) {\n  //    throw new Error(`Failed to retrieve paginated tickets: ${error.message}`)\n  //  }\n  //}\n\n  /**\n   * Retrieves all support tickets.\n   *\n   * @returns An array of all support tickets.\n   */\n  public async getAllTickets() {\n    try {\n      return await prisma.supportTicket.findMany({\n        orderBy: { createdAt: 'desc' },\n      })\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve all tickets: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves a support ticket by its ID.\n   *\n   * @param id - The ID of the support ticket.\n   * @returns The support ticket or null if not found.\n   */\n  public async getTicketById(id: string) {\n    try {\n      return await prisma.supportTicket.findUnique({ where: { id } })\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by title using full text search.\n   *\n   * @param title - The title to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByTitle(title: string) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('title', 'ilike', `%${title}%`)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by title: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by email.\n   *\n   * @param email - The email address to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByEmail(email: string) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('email', '=', email)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by email: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by status.\n   *\n   * @param status - The status to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByStatus(status: SupportTicketStatus) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('status', '=', status)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by status: ${error.message}`)\n    }\n  }\n\n  /**\n   * Updates the status of a support ticket.\n   *\n   * @param id - The ID of the support ticket.\n   * @param status - The new status of the support ticket.\n   * @returns The updated support ticket or null if not found.\n   */\n  public async updateTicket(id: string, status: SupportTicketStatus) {\n    try {\n      return await prisma.supportTicket.update({\n        where: { id },\n        data: { status },\n      })\n    } catch (error: any) {\n      if (error.code === 'P2025') {\n        return null\n      }\n      throw new Error(`Failed to update ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Deletes a support ticket.\n   *\n   * @param id - The ID of the support ticket to delete.\n   * @returns True if the ticket was deleted, false if not found.\n   */\n  public async deleteTicket(id: string) {\n    try {\n      await prisma.supportTicket.delete({\n        where: { id },\n      })\n      return true\n    } catch (error: any) {\n      if (error.code === 'P2025') {\n        return false\n      }\n      throw new Error(`Failed to delete ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Sends a default email notification.\n   *\n   * @param email - The email address to send the notification to.\n   */\n  public async sendDefaultEmail(email: string) {\n    try {\n      await mail.send((message) => {\n        message\n          .to(email)\n          .from(env.get('SMTP_HOST') ?? '')\n          .subject('Support Ticket Received')\n          .html(render(KortexSupportTicketReceived()))\n      })\n\n      return {\n        success: true,\n        message: 'Email sent successfully',\n      }\n    } catch (error: any) {\n      throw new Error(`Failed to send email: ${error.message}`)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport RepoAccessService from '#services/repo_access_service'\nimport { OrderStatus } from '@prisma/client'\n\n@inject()\nexport default class UserDashboardService {\n  /**\n   * Get user dashboard data\n   * @param userId - The ID of the user\n   * @returns Promise<object> Dashboard data\n   */\n  public async getDashboardData(userId: string): Promise<object> {\n    try {\n      const [\n        purchaseHistory,\n        accountInfo,\n        usageStatistics,\n        recommendations,\n      ] = await Promise.all([\n        this.getPurchaseHistory(userId),\n        this.getAccountInfo(userId),\n        this.getUsageStatistics(userId),\n        this.getRecommendations(userId),\n      ])\n\n      return {\n        purchaseHistory,\n        accountInfo,\n        usageStatistics,\n        recommendations,\n      }\n    } catch (error) {\n      console.error('Error in getDashboardData:', error)\n      throw new Error('Failed to retrieve dashboard data')\n    }\n  }\n\n  private async getPurchaseHistory(userId: string) {\n    try {\n      const recentPurchases = await prisma.order.findMany({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        take: 5,\n        orderBy: { createdAt: 'desc' },\n        include: { codeRepo: { select: { name: true } } }\n      })\n\n      const totalSpent = await prisma.order.aggregate({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        _sum: { totalAmount: true }\n      })\n\n      const componentsBought = await prisma.order.count({\n        where: { userId, status: OrderStatus.SUCCEEDED }\n      })\n\n      return {\n        recentPurchases,\n        totalSpent: totalSpent._sum.totalAmount || 0,\n        componentsBought\n      }\n    } catch (error) {\n      console.error('Error in getPurchaseHistory:', error)\n      throw new Error('Failed to retrieve purchase history')\n    }\n  }\n\n  private async getAccountInfo(userId: string) {\n    try {\n      return await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n          email: true,\n          emailVerified: true,\n          profile: true,\n          createdAt: true\n        }\n      })\n    } catch (error) {\n      console.error('Error in getAccountInfo:', error)\n      throw new Error('Failed to retrieve account info')\n    }\n  }\n\n  private async getUsageStatistics(userId: string) {\n    try {\n      const frequentlyPurchased = await prisma.order.groupBy({\n        by: ['codeRepoId'],\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        _count: { codeRepoId: true },\n        orderBy: { _count: { codeRepoId: 'desc' } },\n        take: 5\n      })\n\n      const repoIds = frequentlyPurchased.map(fp => fp.codeRepoId)\n      const repoDetails = await prisma.codeRepo.findMany({\n        where: { id: { in: repoIds } },\n        select: { id: true, name: true }\n      })\n\n      return {\n        mostUsedComponents: frequentlyPurchased.map(fp => ({\n          ...repoDetails.find(rd => rd.id === fp.codeRepoId),\n          usageCount: fp._count.codeRepoId\n        }))\n      }\n    } catch (error) {\n      console.error('Error in getUsageStatistics:', error)\n      throw new Error('Failed to retrieve usage statistics')\n    }\n  }\n\n  private async getRecommendations(userId: string) {\n    try {\n      const userPurchases = await prisma.order.findMany({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        select: { codeRepoId: true }\n      })\n\n      const purchasedRepoIds = userPurchases.map(p => p.codeRepoId)\n\n      const popularComponents = await prisma.codeRepo.findMany({\n        where: {\n          id: { notIn: purchasedRepoIds },\n          status: 'active',\n          visibility: 'public'\n        },\n        orderBy: { orders: { _count: 'desc' } },\n        take: 5,\n        select: { id: true, name: true }\n      })\n\n      return { recommendations: popularComponents }\n    } catch (error) {\n      console.error('Error in getRecommendations:', error)\n      throw new Error('Failed to retrieve recommendations')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_service.ts</source>
<document_content>// user_service.ts\nimport { prisma } from '#services/prisma_service'\nimport { hash } from '@node-rs/argon2'\nimport { UserFactory } from '../factories/user_factory.js'\nimport type { Role, SellerProfile, Profile } from '@prisma/client'\nimport type { User } from 'lucia'\n\ninterface UserCreationData {\n  email: string\n  password: string\n  fullname: string\n  role: Role\n}\n\ninterface UserProfileUpdateData {\n  email?: string\n  password?: string\n  fullname?: string\n  businessName?: string\n  businessAddress?: string\n  businessPhone?: string\n  businessEmail?: string\n}\n\n/**\n * Service class for managing users.\n */\nexport class UserService {\n  /**\n   * Creates a user with the specified role.\n   *\n   * @param {UserCreationData} data - The user creation data.\n   * @returns {Promise<User>} - The created user.\n   * @throws {Error} - If an invalid role is provided.\n   */\n  async createUser(data: UserCreationData): Promise<User> {\n    const { role, ...userData } = data\n    switch (role) {\n      case 'USER':\n        return (await UserFactory.createUser(userData)).user\n      case 'SELLER':\n        return (await UserFactory.createSeller(userData)).user\n      case 'MODERATOR':\n        return (await UserFactory.createModerator(userData)).user\n      case 'ADMIN':\n        return (await UserFactory.createAdmin(userData)).user\n      default:\n        throw new Error(`Invalid role: ${role}`)\n    }\n  }\n\n  /**\n   * Retrieves a user by their email.\n   *\n   * @param {string} email - The email of the user.\n   * @returns {Promise<User>} - The user.\n   * @throws {Error} - If the user is not found.\n   */\n  async getUserByEmail(email: string): Promise<User> {\n    const user = await prisma.user.findUnique({\n      where: { email, deletedAt: null },\n      include: {\n        profile: true,\n        sellerProfile: {\n          include: {\n            bankAccount: true,\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      throw new Error(`User with email ${email} not found.`)\n    }\n\n    return user\n  }\n\n  /**\n   * Retrieves all users.\n   *\n   * @returns {Promise<User[]>} - All users.\n   */\n  async getAllUsers(): Promise<{ id: string; email: string; role: Role }[]> {\n    // only return the ncessary data\n    return prisma.user.findMany({\n      select: {\n        id: true,\n        email: true,\n        bannedUntil: true,\n        //fullname: true,\n        role: true,\n        sellerProfile: {\n          include: {\n            bankAccount: true,\n          },\n          //select: {\n          //  businessName: true,\n          //  businessAddress: true,\n          //  businessPhone: true,\n          //  businessEmail: true,\n          //  identityDoc: true,\n          //\n          //  bankAccount: true,\n          //  verificationStatus: true,\n          //},\n        },\n      },\n    })\n  }\n\n  /**\n   * Retrieves paginated users.\n   *\n   * @param {number} page - The page number.\n   * @param {number} pageSize - The number of users per page.\n   * @returns {Promise<{ users: User[], total: number }>} - The paginated users and total count.\n   */\n  async getPaginatedUsers(\n    page: number,\n    pageSize: number\n  ): Promise<{ users: User[]; total: number }> {\n    const [users, total] = await prisma.$transaction([\n      prisma.user.findMany({\n        where: { deletedAt: null },\n        skip: (page - 1) * pageSize,\n        take: pageSize,\n      }),\n      prisma.user.count({\n        where: { deletedAt: null },\n      }),\n    ])\n\n    return { users, total }\n  }\n\n  /*\n   * Retrieves a user by their ID.\n   *\n   * @param {string} id - The ID of the user.\n   * @returns {Promise<User>} - The user.\n   * @throws {Error} - If the user is not found.\n   *\n   */\n\n  async getUserProfileById(id: string): Promise<Profile | SellerProfile | null> {\n    const user = await prisma.user.findUnique({\n      where: { id },\n    })\n    if (!user) {\n      throw new Error(`User with id ${id} not found.`)\n    }\n\n    if (user.role === 'SELLER') {\n      const profile = await prisma.sellerProfile.findFirst({\n        where: { userId: id },\n      })\n\n      return profile\n    } else {\n      const profile = await prisma.profile.findFirst({\n        where: { userId: id },\n      })\n\n      return profile ?? null\n    }\n  }\n\n  /**\n   * Updates a user with the specified data.\n   *\n   * @param {string} email - The email of the user to update.\n   * @param {Partial<UserCreationData>} data - The data to update the user with.\n   * @returns {Promise<User>} - The updated user.\n   */\n  async updateUser(email: string, data: Partial<UserCreationData>): Promise<User> {\n    const user = await prisma.user.update({\n      where: { email, deletedAt: null },\n      data,\n    })\n\n    return user\n  }\n\n  /**\n   * Updates a user's profile based on their role.\n   *\n   * @param {string} email - The email of the user whose profile is to be updated.\n   * @param {UserProfileUpdateData} data - The profile data to update.\n   * @returns {Promise<User>} - The updated user.\n   * @throws {Error} - If the user is not found or the role is invalid.\n   */\n  async updateUserProfile(email: string, data: UserProfileUpdateData): Promise<User> {\n    const user = await this.getUserByEmail(email)\n\n    switch (user.role) {\n      case 'USER':\n      case 'MODERATOR':\n      case 'ADMIN':\n        const updatedUser = await prisma.user.update({\n          where: { email },\n          data: { passwordHash: data.password ? await hash(data.password) : undefined },\n        })\n\n        await prisma.profile.update({\n          where: { userId: user.id },\n          data: { name: data.fullname },\n        })\n\n        return updatedUser\n\n      case 'SELLER':\n        await prisma.sellerProfile.update({\n          where: { userId: user.id },\n          data: {\n            businessName: data.businessName,\n            businessAddress: data.businessAddress,\n            businessPhone: data.businessPhone,\n            businessEmail: data.businessEmail,\n          },\n        })\n\n        return user\n\n      default:\n        throw new Error(`Invalid role: ${user.role}`)\n    }\n  }\n\n  /**\n   * Soft deletes a user by their email.\n   *\n   * @param {string} email - The email of the user to soft delete.\n   * @returns {Promise<User>} - The soft deleted user.\n   */\n  async deleteUser(email: string): Promise<User> {\n    const user = await prisma.user.update({\n      where: { email },\n      data: { deletedAt: new Date() },\n    })\n\n    return user\n  }\n\n  /**\n   * Bans a user by setting their status to 'banned' and recording the reason.\n   * Also hides all repositories owned by the user.\n   *\n   * @param {string} email - The email of the user to ban.\n   * @returns {Promise<User>} - The banned user.\n   */\n  async banUser(email: string): Promise<User> {\n    return prisma.$transaction(async (tx) => {\n      // Update user status to banned\n      const user = await tx.user.update({\n        where: { email, deletedAt: null },\n        data: {\n          bannedUntil: new Date(),\n        },\n      })\n\n      // Update all repositories owned by the user to 'bannedUser'\n      await tx.codeRepo.updateMany({\n        where: { userId: user.id },\n        data: { status: 'bannedUser' },\n      })\n\n      return user\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_verification_service.ts</source>
<document_content>import { createDate, TimeSpan, isWithinExpirationDate } from 'oslo'\nimport { generateIdFromEntropySize } from 'lucia'\nimport { alphabet, generateRandomString } from 'oslo/crypto'\nimport { prisma } from './prisma_service.js'\nimport type { User } from 'lucia'\nimport mail from '@adonisjs/mail/services/main'\nimport env from '#start/env'\nimport { render } from '@react-email/components'\nimport KortexVerifyEmail from '../../resources/mail-templates/verify-email.mail.js'\n\nexport default class UserVerificationService {\n  async generateEmailVerificationCode(userId: string, email: string): Promise<string> {\n    // delete all previous codes\n    await prisma.emailVerificationCode.deleteMany({\n      where: { userId },\n    })\n\n    const code = generateRandomString(8, alphabet('0-9'))\n    await prisma.emailVerificationCode.create({\n      data: {\n        id: generateIdFromEntropySize(32),\n        userId,\n        email,\n        code,\n        expiresAt: createDate(new TimeSpan(15, 'm')), // 15 minutes\n      },\n    })\n    return code\n  }\n\n  async sendVerificationCode(email: string, code: string, token: string): Promise<void> {\n    await mail.send((message) => {\n      message\n        .to(email)\n        .from(env.get('SMTP_HOST') ?? '')\n        .subject('Verify your email address')\n        .html(render(KortexVerifyEmail({ validationCode: code, authToken: token })))\n    })\n  }\n\n  async verifyVerificationCode(user: User, code: string): Promise<boolean> {\n    const transaction = await prisma.$transaction(async (tx) => {\n      const databaseCode = await tx.emailVerificationCode.findFirstOrThrow({\n        where: { userId: user.id },\n      })\n\n      if (!databaseCode || databaseCode.code !== code) {\n        return false\n      }\n\n      if (!isWithinExpirationDate(databaseCode.expiresAt) || databaseCode.email !== user.email) {\n        return false\n      }\n\n      await tx.emailVerificationCode.delete({ where: { id: databaseCode.id } })\n\n      return true\n    })\n\n    return transaction\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\auth.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { ZodError, z } from 'zod'\n\n/**\n * Schema for validating user registration data.\n */\nexport const registrationSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z\n    .string()\n    .min(8, { message: 'Password must be at least 8 characters long' })\n    .max(255, { message: 'Password must be at most 255 characters long' })\n    .regex(/[a-zA-Z]/, { message: 'Password must contain at least one letter' })\n    .regex(/\d/, { message: 'Password must contain at least one number' }),\n  fullname: z.string().min(1, { message: 'Full name is required' }),\n})\n\n/**\n * Schema for validating user login data.\n */\nexport const loginSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n})\n\n/**\n * Schema for validating forgot password request data.\n */\nexport const forgotPasswordSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n})\n\n/**\n * Schema for validating reset password data.\n */\nexport const resetPasswordSchema = z\n  .object({\n    token: z.string().min(1, { message: 'Token is required' }),\n    password: z\n      .string()\n      .min(8, { message: 'Password must be at least 8 characters long' })\n      .max(255, { message: 'Password must be at most 255 characters long' })\n      .regex(/[a-zA-Z]/, { message: 'Password must contain at least one letter' })\n      .regex(/\d/, { message: 'Password must contain at least one number' }),\n    confirmPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n  })\n  .refine((data) => data.password === data.confirmPassword, {\n    message: 'Passwords must match',\n    path: ['confirmPassword'],\n  })\n\n/**\n * Interface for authentication strategies.\n */\nexport interface AuthStrategy {\n  /**\n   * Validates the provided data.\n   * @param data - The data to validate.\n   */\n  validate(data: {\n    email?: string\n    password?: string\n    fullname?: string\n    token?: string\n    confirmPassword?: string\n  }): Promise<void>\n}\n\n/**\n * Strategy for validating user registration data using Zod schema.\n */\nexport class ZodRegistrationAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string; fullname: string }): Promise<void> {\n    try {\n      registrationSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating user login data using Zod schema.\n */\nexport class ZodLoginAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string }): Promise<void> {\n    try {\n      loginSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating forgot password request data using Zod schema.\n */\nexport class ZodForgotPasswordAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    try {\n      forgotPasswordSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating reset password data using Zod schema.\n */\nexport class ZodResetPasswordAuthStrategy implements AuthStrategy {\n  async validate(data: {\n    token: string\n    password: string\n    confirmPassword: string\n  }): Promise<void> {\n    try {\n      resetPasswordSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n/**\n * Strategy for ensuring unique email using Prisma.\n */\nexport class PrismaEmailUniqueAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    const existingUser = await prisma.user.findUnique({ where: { email: data.email } })\n    if (existingUser) {\n      throw new Error('Email is already in use')\n    }\n  }\n}\n\n/**\n * Strategy for checking if an email exists using Prisma.\n */\nexport class PrismaEmailExistsAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    const existingUser = await prisma.user.findUnique({ where: { email: data.email } })\n    if (!existingUser) {\n      throw new Error('Email does not exist')\n    }\n  }\n}\n\nexport class EmptyFieldAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string; fullname: string }): Promise<void> {\n    if (!data.email || !data.password) {\n      throw new Error('Emtpy fields on request body')\n    }\n  }\n}\n\n/**\n * Class for validating data using multiple authentication strategies.\n */\nexport class AuthValidator {\n  private strategies: AuthStrategy[] = []\n\n  /**\n   * Adds a new authentication strategy to the validator.\n   * @param strategy - The strategy to add.\n   */\n  addStrategy(strategy: AuthStrategy): void {\n    this.strategies.push(strategy)\n  }\n\n  /**\n   * Validates the provided data using all added strategies.\n   * @param data - The data to validate.\n   */\n  async validate(data: { email: string; password: string; fullname?: string }): Promise<void> {\n    for (const strategy of this.strategies) {\n      await strategy.validate(data)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\checkout.ts</source>
<document_content></document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\code_check.ts</source>
<document_content>import { z } from 'zod'\nimport { Language } from '@prisma/client'\n\nexport const codeCheckSchema = z.object({\n  // New fields\n  securityScore: z.number().min(0).max(100),\n  maintainabilityScore: z.number().min(0).max(100),\n  readabilityScore: z.number().min(0).max(100),\n  securitySuggestion: z.string(),\n  maintainabilitySuggestion: z.string(),\n  readabilitySuggestion: z.string(),\n  overallDescription: z.string(),\n})\n\nexport const codeCheckRequestSchema = z.object({\n  code: z.string().min(1, 'Code is required'),\n  language: z.enum([Language.JSX, Language.TSX]),\n})\n\nexport type CodeCheckRequest = z.infer<typeof codeCheckRequestSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\order.ts</source>
<document_content>import { z } from 'zod'\n\nexport const CreateOrderSchema = z.object({\n  userId: z.string().uuid(),\n  codeRepoId: z.string().uuid(),\n  totalAmount: z.number().positive(),\n})\n\nexport const UpdateOrderSchema = z.object({\n  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED']).optional(),\n  totalAmount: z.number().positive().optional(),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\payout_request.ts</source>
<document_content>import { z } from 'zod'\n\nexport const createPayoutRequestSchema = z.object({\n  totalAmount: z.number().positive(),\n})\n\nexport const updatePayoutRequestSchema = z.object({\n  status: z.enum(['PENDING', 'REJECTED', 'PROCESSED']),\n})\n\nexport const processPayoutRequestSchema = z.object({\n  action: z.enum(['approve', 'reject']),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\payout.ts</source>
<document_content>// app/validators/payout.ts\nimport { z } from 'zod'\n\nexport const createPayoutSchema = z.object({\n  sellerProfileId: z.string().cuid(),\n  amount: z.number().positive(),\n  currency: z.string().min(3).max(3),\n  payoutRequestId: z.string(),\n})\n\nexport type CreatePayoutDTO = z.infer<typeof createPayoutSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\profile.ts</source>
<document_content>import { z } from 'zod'\nimport { isValidPhoneNumber } from 'libphonenumber-js'\n\nexport const updateProfileSchema = z.object({\n  name: z.string().optional(),\n  phoneNumber: z.string().optional(),\n  //profileImg: z.string().optional(),\n})\n\nexport const updateSellerProfileSchema = z.object({\n  businessName: z.string().min(1, 'Business name is required'),\n  businessAddress: z.string().min(1, 'Business address is required'),\n  businessPhone: z.string().refine(isValidPhoneNumber, { message: 'Invalid phone number' }),\n  businessEmail: z.string().email('Invalid email address'),\n  accountHolderName: z.string().min(1, 'Account holder name is required'),\n  accountNumber: z.string().min(1, 'Account number is required'),\n  bankName: z.string().min(1, 'Bank name is required'),\n  swiftCode: z.string().min(8).max(11),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\repo.ts</source>
<document_content>import { z } from 'zod'\n\n// Enum for Language\nconst LanguageEnum = z.enum(['JSX', 'TSX'])\n\n// Enum for Visibility\nconst VisibilityEnum = z.enum(['public', 'private'])\n\n// Enum for CodeRepoStatus\nconst CodeRepoStatusEnum = z.enum(['pending', 'active', 'rejected', 'bannedUser'])\n\n// Schema for creating a new repo\nexport const createRepoSchema = z.object({\n  name: z.string().min(1).max(255),\n  description: z.string().nullable(),\n  language: LanguageEnum,\n  price: z.number().nonnegative().default(0.0),\n  tags: z.array(z.string()),\n  visibility: VisibilityEnum.default('public'),\n  //sourceJs: z.string(),\n  //sourceCss: z.string(),\n})\n\n// Schema for updating a repo\nexport const updateRepoSchema = z.object({\n  name: z.string().min(1).max(255).optional(),\n  description: z.string().nullable().optional(),\n  language: LanguageEnum.optional(),\n  price: z.number().nonnegative().optional(),\n  tags: z.array(z.string()).optional(),\n  visibility: VisibilityEnum.optional(),\n  status: CodeRepoStatusEnum.optional(),\n  sourceJs: z.string().optional(),\n  sourceCss: z.string().optional(),\n  //stripeProductId: z.string().nullable().optional(),\n  //stripePriceId: z.string().nullable().optional(),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\seller.ts</source>
<document_content>import { z } from 'zod'\n\nexport const createSellerProfileSchema = z.object({\n  businessName: z.string().min(1, 'Business name is required'),\n  businessAddress: z.string().min(1, 'Business address is required'),\n  businessPhone: z.string().min(1, 'Business phone is required'),\n  businessEmail: z.string().email('Invalid email address'),\n  accountHolderName: z.string().min(1, 'Account holder name is required'),\n  accountNumber: z.string().min(1, 'Account number is required'),\n  bankName: z.string().min(1, 'Bank name is required'),\n  swiftCode: z.string().min(8).max(11, 'SWIFT code must be 8 or 11 characters'),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n  verificationStatus: z.enum(['PENDING', 'APPROVED', 'REJECTED', 'IDLE']),\n})\n\nexport const updateSellerProfileSchema = createSellerProfileSchema.partial()\n\nexport const createPayoutRequestSchema = z.object({\n  amount: z.number().positive('Amount must be positive'),\n})\n\nexport const updatePayoutRequestSchema = z.object({\n  status: z.enum(['PENDING', 'APPROVED', 'REJECTED', 'PROCESSED']),\n})\n\nexport type CreateSellerProfileDto = z.infer<typeof createSellerProfileSchema>\nexport type UpdateSellerProfileDto = z.infer<typeof updateSellerProfileSchema>\nexport type CreatePayoutRequestDto = z.infer<typeof createPayoutRequestSchema>\nexport type UpdatePayoutRequestDto = z.infer<typeof updatePayoutRequestSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\prisma\schema.prisma</source>
<document_content>generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"driverAdapters\"]\n}\n\ngenerator kysely {\n  provider     = \"prisma-kysely\"\n  output       = \"../database//kysely/\"\n  fileName     = \"types.ts\"\n  enumFileName = \"enums.ts\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel emailVerificationCode {\n  id        String   @id\n  code      String\n  userId    String\n  email     String\n  expiresAt DateTime\n  User      User     @relation(fields: [userId], references: [id])\n}\n\nenum Role {\n  USER\n  ADMIN\n  MODERATOR\n  SELLER\n}\n\nmodel User {\n  id            String    @id @default(cuid())\n  email         String    @unique\n  passwordHash  String\n  sessions      Session[]\n  emailVerified Boolean   @default(false)\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n  deletedAt     DateTime?\n\n  PasswordResetToken    PasswordResetToken[]\n  CodeRepo              CodeRepo[]\n  emailVerificationCode emailVerificationCode[]\n  orders                Order[]\n\n  bannedUntil DateTime?\n\n  role Role @default(USER)\n\n  sellerProfile SellerProfile?\n  profile       Profile?\n\n  Review         Review[]\n  Comment        Comment[]\n  SearchHistory  SearchHistory[]\n  SalesAggregate SalesAggregate[]\n  Vote           Vote[]\n  repoAccesses   UserRepoAccess[]\n}\n\nmodel Profile {\n  id          String  @id @default(cuid())\n  profileImg  String?\n  name        String?\n  phoneNumber String?\n  user        User    @relation(fields: [userId], references: [id])\n  userId      String  @unique\n}\n\nmodel SellerProfile {\n  id                 String                   @id @default(cuid())\n  user               User                     @relation(fields: [userId], references: [id])\n  userId             String                   @unique\n  profileImg         String?\n  businessName       String\n  businessAddress    String\n  businessPhone      String\n  businessEmail      String\n  identityDoc        String?\n  verificationDate   DateTime?\n  verificationStatus SellerVerificationStatus @default(PENDING)\n  bankAccount        BankAccount?\n  Payout             Payout[]\n  balance            Float                    @default(0)\n  PayoutRequest      PayoutRequest[]\n  lastPayoutDate     DateTime?\n}\n\nenum SellerVerificationStatus {\n  IDLE\n  PENDING\n  APPROVED\n  REJECTED\n}\n\nmodel BankAccount {\n  id                String        @id @default(cuid())\n  sellerProfile     SellerProfile @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId   String        @unique\n  accountHolderName String\n  accountNumber     String\n  bankName          String\n  swiftCode         String\n  iban              String?\n  routingNumber     String?\n  createdAt         DateTime      @default(now())\n  updatedAt         DateTime      @updatedAt\n}\n\nmodel PayoutRequest {\n  id              String              @id @default(cuid())\n  sellerProfile   SellerProfile       @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId String\n  totalAmount     Float\n  status          PayoutRequestStatus @default(PENDING)\n  createdAt       DateTime            @default(now())\n  updatedAt       DateTime            @updatedAt\n  processedAt     DateTime?\n  payout          Payout?\n  lastPayoutDate  DateTime?\n  orders          Order[]\n}\n\nenum PayoutRequestStatus {\n  PENDING\n  REJECTED\n  PROCESSED\n}\n\nmodel Payout {\n  id              String        @id @default(cuid())\n  sellerProfile   SellerProfile @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId String\n  payoutRequest   PayoutRequest @relation(fields: [payoutRequestId], references: [id])\n  payoutRequestId String        @unique\n  totalAmount     Float\n  currency        String\n  createdAt       DateTime      @default(now())\n  updatedAt       DateTime      @updatedAt\n}\n\nmodel Session {\n  id        String   @id\n  userId    String\n  expiresAt DateTime\n  user      User     @relation(references: [id], fields: [userId], onDelete: Cascade)\n}\n\nmodel PasswordResetToken {\n  id        Int      @id @default(autoincrement())\n  tokenHash String   @unique\n  userId    String\n  expiresAt DateTime\n  user      User     @relation(fields: [userId], references: [id])\n}\n\nmodel CodeRepo {\n  id          String         @id @default(cuid())\n  userId      String\n  user        User           @relation(fields: [userId], references: [id])\n  sourceJs    String         @db.Text\n  sourceCss   String         @db.Text\n  reviews     Review[]\n  createdAt   DateTime       @default(now())\n  updatedAt   DateTime       @updatedAt\n  deletedAt   DateTime?\n  visibility  Visibility     @default(public)\n  status      CodeRepoStatus @default(pending)\n  name        String\n  description String?\n  language    Language\n  price       Float          @default(0.0)\n  tags        TagsOnRepos[]\n  codeChecks  CodeCheck[]\n  orders      Order[]\n  userAccesses UserRepoAccess[]\n}\n\nmodel Tag {\n  id        String        @id @default(cuid())\n  name      String        @unique\n  repos     TagsOnRepos[]\n  createdAt DateTime      @default(now())\n  updatedAt DateTime      @updatedAt\n  deletedAt DateTime?\n}\n\nmodel TagsOnRepos {\n  codeRepo   CodeRepo @relation(fields: [codeRepoId], references: [id])\n  codeRepoId String\n  tag        Tag      @relation(fields: [tagId], references: [id])\n  tagId      String\n\n  @@id([codeRepoId, tagId])\n}\n\nenum CodeRepoStatus {\n  pending\n  active\n  rejected\n  bannedUser\n}\n\nenum Visibility {\n  public\n  private\n}\n\nenum Language {\n  JSX\n  TSX\n}\n\nmodel SearchHistory {\n  id        String   @id @default(cuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id])\n  tag       String\n  createdAt DateTime @default(now())\n}\n\nmodel CodeCheck {\n  id                        String   @id @default(cuid())\n  repoId                    String\n  securityScore             Int\n  maintainabilityScore      Int\n  readabilityScore          Int\n  securitySuggestion        String   @db.Text\n  maintainabilitySuggestion String   @db.Text\n  readabilitySuggestion     String   @db.Text\n  overallDescription        String   @db.Text\n  eslintErrorCount          Int\n  eslintFatalErrorCount     Int\n  createdAt                 DateTime @default(now())\n  updatedAt                 DateTime @updatedAt\n  Repo                      CodeRepo @relation(fields: [repoId], references: [id])\n}\n\nmodel Order {\n  id                    String         @id @default(cuid())\n  userId                String\n  user                  User           @relation(fields: [userId], references: [id])\n  codeRepoId            String\n  codeRepo              CodeRepo       @relation(fields: [codeRepoId], references: [id])\n  createdAt             DateTime       @default(now())\n  updatedAt             DateTime       @updatedAt\n  deletedAt             DateTime?\n  status                OrderStatus    @default(REQUIRESPAYMENTMETHOD)\n  totalAmount           Float\n  stripePaymentIntentId String?\n  stripePaymentMethodId String?\n  payoutRequest         PayoutRequest? @relation(fields: [payoutRequestId], references: [id])\n  payoutRequestId       String?\n  userRepoAccesses      UserRepoAccess[]\n}\n\nenum OrderStatus {\n  REQUIRESPAYMENTMETHOD\n  REQUIRESCONFIRMATION\n  REQUIRESACTION\n  PROCESSING\n  REQUIRESCAPTURE\n  CANCELLED\n  SUCCEEDED\n}\n\nmodel SalesAggregate {\n  id         String   @id @default(cuid())\n  sellerId   String\n  seller     User     @relation(fields: [sellerId], references: [id])\n  date       DateTime\n  revenue    Float\n  salesCount Int\n\n  @@unique([sellerId, date])\n}\n\nenum UserCommentFlag {\n  NONE\n  SPAM\n  INAPPROPRIATE_LANGUAGE\n  HARASSMENT\n  OFF_TOPIC\n  FALSE_INFORMATION\n  OTHER\n}\n\nmodel Review {\n  id        String          @id @default(cuid())\n  content   String\n  userId    String\n  user      User            @relation(fields: [userId], references: [id])\n  repoId    String\n  repo      CodeRepo        @relation(fields: [repoId], references: [id])\n  rating    Int             @default(0)\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt\n  deletedAt DateTime?\n  comments  Comment[]\n  flag      UserCommentFlag @default(NONE)\n\n  upvotes   Int             @default(0)\n  downvotes Int             @default(0)\n  votes     Vote[]\n}\n\nmodel Comment {\n  id        String          @id @default(cuid())\n  content   String\n  userId    String\n  user      User            @relation(fields: [userId], references: [id])\n  reviewId  String\n  review    Review          @relation(fields: [reviewId], references: [id])\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt\n  deletedAt DateTime?\n  flag      UserCommentFlag @default(NONE)\n\n  upvotes   Int             @default(0)\n  downvotes Int             @default(0)\n  votes     Vote[]\n}\n\nmodel Vote {\n  id        String   @id @default(cuid())\n  userId    String\n  type      VoteType\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  user      User     @relation(fields: [userId], references: [id])\n\n  comment   Comment? @relation(fields: [commentId], references: [id])\n  commentId String?\n  Review    Review?  @relation(fields: [reviewId], references: [id])\n  reviewId  String?\n\n  @@unique([userId, commentId])\n  @@unique([userId, reviewId])\n}\n\nenum VoteType {\n  UPVOTE\n  DOWNVOTE\n}\n\nmodel SupportTicket {\n  id        String              @id @default(cuid())\n  email     String\n  title     String\n  content   String\n  status    SupportTicketStatus @default(todo)\n  type      SupportTicketType   @default(general)\n  createdAt DateTime            @default(now())\n  updatedAt DateTime            @updatedAt\n}\n\nenum SupportTicketStatus {\n  inProgress\n  todo\n  backlog\n  done\n}\n\nenum SupportTicketType {\n  general\n  technical\n  payment\n}\n\nmodel Media {\n  id        String   @id @default(cuid())\n  url       String\n  type      String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel UserRepoAccess {\n  id        String   @id @default(cuid())\n  user      User     @relation(fields: [userId], references: [id])\n  userId    String\n  repo      CodeRepo @relation(fields: [repoId], references: [id])\n  repoId    String\n  order     Order    @relation(fields: [orderId], references: [id])\n  orderId   String\n  grantedAt DateTime @default(now())\n  expiresAt DateTime?\n\n  @@unique([userId, repoId])\n}\n</document_content>
</document>

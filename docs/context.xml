<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\admin_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { CommentService } from '#services/comment_service'\nimport SellerService from '#services/seller_service'\nimport { SellerVerificationStatus, PayoutRequestStatus } from '@prisma/client'\nimport { ReviewService } from '#services/review_service'\n\n/**\n * Controller class for handling Admin operations on Seller Profiles.\n */\n@inject()\nexport default class AdminController {\n  constructor(\n    protected commentService: CommentService,\n    protected sellerService: SellerService,\n    protected reviewService: ReviewService\n  ) {}\n  /**\n   * Retrieve a Seller Profile by user ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   */\n  public async getSellerProfile({ params, response }: HttpContext) {\n    const { id } = params\n\n    try {\n      const sellerProfile = await prisma.sellerProfile.findUnique({\n        where: { userId: id },\n        include: { bankAccount: true, user: true },\n      })\n\n      if (!sellerProfile) {\n        return response.status(404).json({ message: 'Seller profile not found' })\n      }\n\n      return response.status(200).json(sellerProfile)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a Seller Profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam data - The data to update the Seller Profile.\n   */\n  public async updateSellerProfile({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only([\n      'businessName',\n      'businessAddress',\n      'businessPhone',\n      'businessEmail',\n      'accountHolderName',\n      'accountNumber',\n      'bankName',\n      'swiftCode',\n      'iban',\n      'routingNumber',\n      'verificationStatus',\n    ])\n\n    if (data.verificationStatus) {\n      if (!Object.values(SellerVerificationStatus).includes(data.verificationStatus)) {\n        return response.status(400).json({ message: 'Invalid status' })\n      }\n    }\n\n    const user = await prisma.user.findUnique({ where: { email } })\n    if (!user) {\n      return response.status(404).json({ message: 'User not found' })\n    }\n\n    try {\n      await this.sellerService.updateSellerProfile(user.id, data)\n      //const updatedProfile = await prisma.sellerProfile.update({\n      //  where: { userId: user.id },\n      //  data: {\n      //    businessName: data.businessName,\n      //    businessAddress: data.businessAddress,\n      //    businessPhone: data.businessPhone,\n      //    businessEmail: data.businessEmail,\n      //    bankAccount: {\n      //      upsert: {\n      //        create: {\n      //          accountHolderName: data.accountHolderName,\n      //          accountNumber: data.accountNumber,\n      //          bankName: data.bankName,\n      //          swiftCode: data.swiftCode,\n      //          iban: data.iban,\n      //          routingNumber: data.routingNumber,\n      //        },\n      //        update: {\n      //          accountHolderName: data.accountHolderName,\n      //          accountNumber: data.accountNumber,\n      //          bankName: data.bankName,\n      //          swiftCode: data.swiftCode,\n      //          iban: data.iban,\n      //          routingNumber: data.routingNumber,\n      //        },\n      //      },\n      //    },\n      //  },\n      //  include: { bankAccount: true },\n      //})\n\n      return response.status(200).json({ message: 'Seller profile updated successfully' })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * List all Seller Profiles with pagination.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam page - The page number for pagination.\n   * @queryParam limit - The number of items per page.\n   */\n  public async listSellerProfiles({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n    const skip = (page - 1) * limit\n\n    try {\n      const [sellerProfiles, total] = await prisma.$transaction([\n        prisma.sellerProfile.findMany({\n          skip,\n          take: limit,\n          include: { user: true, bankAccount: true },\n        }),\n        prisma.sellerProfile.count(),\n      ])\n\n      return response.status(200).json({\n        data: sellerProfiles,\n        meta: {\n          total,\n          page,\n          limit,\n        },\n      })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Verify a Seller Profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam status - The verification status to set.\n   */\n  public async verifySellerProfile({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { status } = request.only(['status'])\n\n    try {\n      const updatedProfile = await prisma.sellerProfile.update({\n        where: { userId: id },\n        data: {\n          verificationStatus: status,\n          verificationDate: new Date(),\n        },\n      })\n\n      return response.status(200).json(updatedProfile)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Ban a user.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam id - The ID of the User/Seller.\n   * @bodyParam banUntil - The date until which the user is banned.\n   */\n  public async banUser({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { banUntil } = request.only(['banUntil'])\n\n    try {\n      const bannedUser = await prisma.user.update({\n        where: { id },\n        data: {\n          bannedUntil: new Date(banUntil),\n        },\n      })\n\n      return response.status(200).json(bannedUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async unbanUser({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const unbanUser = await prisma.user.update({\n        where: { id },\n        data: {\n          bannedUntil: null,\n        },\n      })\n      return response.status(200).json(unbanUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async deleteUser({ params, response }: HttpContext) {\n    const { email } = params\n    try {\n      const deletedUser = await prisma.user.update({\n        where: { email },\n        data: {\n          deletedAt: new Date(),\n        },\n      })\n      return response.status(200).json(deletedUser)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  public async getAllFlaggedReviews({ response }: HttpContext) {\n    try {\n      const comments = await this.reviewService.getAllFlaggedReviews()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  public async getAllFlaggedComments({ response }: HttpContext) {\n    try {\n      const comments = await this.commentService.getAllFlaggedComments()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getSellerApplications\n   * @description Get all seller applications\n   * @queryParam status - Optional filter for verification status\n   * @responseBody 200 - { \"applications\": SellerProfile[] }\n   */\n  public async getSellerApplications({ request, response }: HttpContext) {\n    const status = request.input('status') as SellerVerificationStatus | undefined\n    try {\n      const applications = await this.sellerService.getSellerApplications(status)\n      return response.status(200).json({ applications })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateSellerApplicationStatus\n   * @description Update the status of a seller application\n   * @paramParam id - The ID of the seller profile\n   * @requestBody {\n   *   \"status\": \"APPROVED\" | \"REJECTED\"\n   * }\n   * @responseBody 200 - { \"message\": \"Application status updated\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid status\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async updateSellerApplicationStatus({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { verificationStatus } = request.body()\n\n    if (!Object.values(SellerVerificationStatus).includes(verificationStatus)) {\n      return response.status(400).json({ message: 'Invalid status' })\n    }\n\n    try {\n      const profile = await this.sellerService.updateSellerApplicationStatus(id, verificationStatus)\n      return response.status(200).json({ message: 'Application status updated', profile })\n    } catch (error) {\n      return response.status(404).json({ message: 'Seller profile not found' })\n    }\n  }\n\n  /**\n   * @getPayoutRequests\n   * @description Get all payout requests\n   * @queryParam status - Optional filter for payout request status\n   * @responseBody 200 - { \"requests\": PayoutRequest[] }\n   */\n  public async getPayoutRequests({ request, response }: HttpContext) {\n    const status = request.input('status') as PayoutRequestStatus | undefined\n    try {\n      const requests = await this.sellerService.getPayoutRequests(status)\n      return response.status(200).json({ requests })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updatePayoutRequestStatus\n   * @description Update the status of a payout request\n   * @paramParam id - The ID of the payout request\n   * @requestBody {\n   *   \"status\": \"APPROVED\" | \"REJECTED\" | \"PROCESSED\"\n   * }\n   * @responseBody 200 - { \"message\": \"Payout request status updated\", \"request\": PayoutRequest }\n   * @responseBody 400 - { \"message\": \"Invalid status\" }\n   * @responseBody 404 - { \"message\": \"Payout request not found\" }\n   */\n  public async updatePayoutRequestStatus({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { status } = request.body()\n\n    if (!Object.values(PayoutRequestStatus).includes(status)) {\n      return response.status(400).json({ message: 'Invalid status' })\n    }\n\n    try {\n      const payoutRequest = await this.sellerService.updatePayoutRequestStatus(id, status)\n      return response\n        .status(200)\n        .json({ message: 'Payout request status updated', request: payoutRequest })\n    } catch (error) {\n      return response.status(404).json({ message: 'Payout request not found' })\n    }\n  }\n\n  /**\n   * @verifySellerDocument\n   * @description Verify a seller's identity document\n   * @paramParam id - The ID of the seller profile\n   * @requestBody {\n   *   \"isVerified\": boolean\n   * }\n   * @responseBody 200 - { \"message\": \"Document verification status updated\", \"profile\": SellerProfile }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async verifySellerDocument({ params, request, response }: HttpContext) {\n    const { id } = params\n    const { isVerified } = request.body()\n\n    try {\n      const profile = await this.sellerService.verifySellerDocument(id, isVerified)\n      return response.status(200).json({ message: 'Document verification status updated', profile })\n    } catch (error) {\n      return response.status(404).json({ message: 'Seller profile not found' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\auth_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport AuthService from '#services/auth_service'\nimport {\n  AuthValidator,\n  ZodLoginAuthStrategy,\n  PrismaEmailExistsAuthStrategy,\n  ZodRegistrationAuthStrategy,\n  PrismaEmailUniqueAuthStrategy,\n  EmptyFieldAuthStrategy,\n  registrationSchema,\n} from '#validators/auth'\nimport { inject } from '@adonisjs/core'\nimport lucia from '#services/lucia_service'\nimport { Exception } from '@adonisjs/core/exceptions'\nimport type { Cookie } from 'lucia'\nimport { UserService } from '#services/user_service'\nimport { prisma } from '#services/prisma_service'\nimport InvalidSessionIdException from '#exceptions/invalid_session_id_exception'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport logger from '@adonisjs/core/services/logger'\nimport { z } from 'zod'\n\n/**\n * Controller class for handling user authentication operations.\n */\n@inject()\nexport default class AuthController {\n  /**\n   * Creates an instance of AuthController.\n   *\n   * @param authService - The authentication service.\n   */\n  constructor(\n    protected authService: AuthService,\n    protected userService: UserService\n  ) {}\n\n  /**\n   * @login\n   * @description Handle user login.\n   * @requestBody { \"email\": \"user@example.com\", \"password\": \"123123123\"}\n   * @responseBody 200 - { \"message\": \"Login successful\" }\n   * @responseBody 400 - { \"message\": \"Invalid credentials\" }\n   */\n  async login({ request, response }: HttpContext) {\n    const { email, password } = request.only(['email', 'password'])\n\n    const loginValidator = new AuthValidator()\n    //loginValidator.addStrategy(new ZodLoginAuthStrategy())\n    loginValidator.addStrategy(new PrismaEmailExistsAuthStrategy())\n    loginValidator.addStrategy(new EmptyFieldAuthStrategy())\n\n    try {\n      await loginValidator.validate({ email, password })\n    } catch (e: Error | any) {\n      console.log(e)\n      return response.abort({ message: e.message }, 400)\n    }\n\n    try {\n      const sessionCookie: Cookie | Response = await this.authService.handleLogin(email, password)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Invalid credentials')\n      }\n\n      const c = sessionCookie.serialize()\n      const sid = lucia.readSessionCookie(c)\n      const { user } = await lucia.validateSession(sid ?? '')\n      if (!user) throw new InvalidSessionIdException()\n\n      return response.header('Set-Cookie', c).status(200).json({ message: 'Login successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n\n  /**\n   * @register\n   * @description Handle user registration.\n   * @requestBody { \n   *   \"fullname\": \"John Doe\",\n   *   \"email\": \"user@example.com\", \n   *   \"password\": \"123123123\", \n   *   \"userType\": \"buyer\" | \"seller\"\n   * }\n   * @responseBody 201 - { \"message\": \"Registration successful\", \"user\": { \"id\": \"...\", \"email\": \"...\", \"role\": \"...\" } }\n   * @responseBody 400 - { \"message\": \"Registration failed\" }\n   */\n  async register({ request, response }: HttpContext) {\n    const registrationData = request.only(['fullname', 'email', 'password', 'userType'])\n\n    const registrationValidator = new AuthValidator()\n    registrationValidator.addStrategy(new ZodRegistrationAuthStrategy())\n    registrationValidator.addStrategy(new PrismaEmailUniqueAuthStrategy())\n\n    try {\n      await registrationValidator.validate(registrationData)\n    } catch (e: Error | any) {\n      if (Array.isArray(e)) {\n        return response.abort({ message: e }, 400)\n      } else {\n        return response.abort({ message: e.message }, 400)\n      }\n    }\n\n    try {\n      const { user, sessionCookie } = await this.authService.handleRegistration(\n        registrationData as z.infer<typeof registrationSchema>\n      )\n\n      return response\n        .cookie('session', sessionCookie)\n        .status(201)\n        .json({ \n          message: 'Registration successful',\n          user: {\n            id: user.id,\n            email: user.email,\n            role: user.role\n          }\n        })\n    } catch (error) {\n      logger.error(error)\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @logout\n   * @description Handle user logout.\n   * @responseBody 200 - { \"message\": \"Logout successful\" }\n   * @responseBody 400 - { \"message\": \"Logout failed\" }\n   */\n  async logout({ request, response }: HttpContext) {\n    const sessionId = request.cookie('auth_session')\n    try {\n      await this.authService.handleLogout(sessionId)\n      return response.clearCookie('auth_session').status(200).json({ message: 'Logout successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @verifyEmail\n   * @description Handle email verification.\n   * @requestBody { \"code\": \"123456\" }\n   * @responseBody 200 - { \"message\": \"Email verification successful\" }\n   * @responseBody 400 - { \"message\": \"Email verification failed\" }\n   */\n  async verifyEmail({ request, response }: HttpContext) {\n    const { code } = request.only(['code'])\n    logger.info(request.headers())\n    try {\n      const sessionId = lucia.readSessionCookie(request.headers().cookie ?? '')\n      if (!sessionId) {\n        throw new InvalidSessionIdException()\n      }\n      const sessionCookie = await this.authService.handleVerifyEmail(sessionId, code)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Email verification failed')\n      }\n      return response\n        .cookie('session', sessionCookie)\n        .status(200)\n        .json({ message: 'Email verification successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @createPasswordResetToken\n   * @description Handle password reset token creation.\n   * @requestBody { \"userId\": \"123456\" }\n   * @responseBody 200 - { \"token\": \"generated_token\" }\n   * @responseBody 400 - { \"message\": \"Password reset token creation failed\" }\n   */\n  async createPasswordResetToken({ request, response }: HttpContext) {\n    const { userId } = request.only(['userId'])\n    try {\n      const token = await this.authService.handleCreatePasswordResetToken(userId)\n      if (token instanceof Response) {\n        throw new Error('Password reset token creation failed')\n      }\n      return response.status(200).json({ token })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @resetPassword\n   * @description Handle password reset.\n   * @requestBody { \"token\": \"generated_token\", \"password\": \"123456\" }\n   * @responseBody 200 - { \"message\": \"Password reset successful\" }\n   * @responseBody 400 - { \"message\": \"Password reset failed\" }\n   */\n  async resetPassword({ request, response }: HttpContext) {\n    const { token, password } = request.only(['token', 'password'])\n    try {\n      const sessionCookie = await this.authService.handlePasswordReset(token, password)\n      if (sessionCookie instanceof Response) {\n        throw new Error('Password reset failed')\n      }\n      return response\n        .cookie('session', sessionCookie)\n        .status(200)\n        .json({ message: 'Password reset successful' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @verifyUserExistAndEmailVerified\n   * @description Verify if user exists and their email is verified.\n   * @bodyParam email - The user's email address.\n   * @responseBody 200 - { \"exists\": true }\n   * @responseBody 400 - { \"message\": \"Verification failed\" }\n   */\n  async verifyUserExistAndEmailVerified({ request, response }: HttpContext) {\n    const { email } = request.only(['email'])\n    try {\n      const exists = await this.authService.handleVerifyUserExistAndEmailVerified(email)\n      return response.status(200).json({ exists })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  /**\n   * @sendVerifyEmailCodeFromUser\n   * @description Send verification email code to the user.\n   * @responseBody 401 - { \"message\": \"User not found in request object\" }\n   * @responseBody 400 - { \"message\": \"Sending verification email failed\" }\n   */\n  async sendVerifyEmailCodeFromUser({ request, response }: HttpContext) {\n    if (request.user === null) throw new UnAuthorizedException('User not found in request object')\n    try {\n      await this.authService.sendVerifyEmailCode(request.user)\n      return response.status(200).json({ message: 'Verification email sent' })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n\n  /**\n   * @me\n   * @description Get the user profile.\n   * @responseBody 200 - { \"user\": { \"email\": \"wOwYg@example.com\", \"role\": \"USER\" }, \"profile\": { \"firstName\": \"John\", \"lastName\": \"Doe\" } }\n   * @responseBody 400 - { \"message\": \"Profile retrieval failed\" }\n   */\n  async me({ request, response }: HttpContext) {\n    try {\n      if (request.user === null) throw new Exception('No cookie session found', { status: 204 })\n      const [user, profile, sellerProfile] = await Promise.all([\n        prisma.user.findUnique({ where: { id: request.user.id } }),\n        prisma.profile.findUnique({ where: { userId: request.user.id } }),\n        prisma.sellerProfile.findUnique({ where: { userId: request.user.id } }),\n      ])\n      return response.status(200).json({ user, profile, sellerProfile })\n    } catch (error) {\n      return response.abort({ message: error.message }, error.status ?? 400)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\checkout_controller.ts</source>
<document_content>import { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport CheckoutService from '#services/checkout_service'\nimport { prisma } from '#services/prisma_service'\nimport logger from '@adonisjs/core/services/logger'\n\nconst initCheckoutSchema = z.object({\n  repoId: z.string(),\n})\n\nconst processPaymentSchema = z.object({\n  paymentIntentId: z.string(),\n})\n\n@inject()\nexport default class CheckoutController {\n  constructor(protected checkoutService: CheckoutService) {}\n\n  /**\n   * @initCheckout\n   * @description Initiate the checkout process for a repo\n   * @requestBody {\n   *   \"repoId\": \"clxxxxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 200 - {\n   *   \"clientSecret\": \"pi_xxxxxxxxxxxxx_secret_xxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Repo not found\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while initiating checkout\" }\n   */\n  public async initCheckout({ request, response }: HttpContext) {\n    try {\n      const user = request.user\n      if (!user) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n      const { repoId } = initCheckoutSchema.parse(request.body())\n\n      const result = await this.checkoutService.initCheckout(repoId, user.id)\n      return response.ok(result)\n    } catch (error) {\n      logger.error({ err: error }, 'Error in initCheckout')\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      if (\n        error instanceof Error &&\n        error.message === 'Repo not found or seller profile not available'\n      ) {\n        return response.notFound({ message: error.message })\n      }\n      return response.internalServerError({\n        message: 'An error occurred while initiating checkout',\n      })\n    }\n  }\n\n  /**\n   * @processPayment\n   * @description Process the payment for a checkout\n   * @requestBody {\n   *   \"paymentIntentId\": \"pi_xxxxxxxxxxxxx\"\n   * }\n   * @responseBody 200 - {\n   *   \"success\": true,\n   *   \"orderId\": \"clxxxxxxxxxxxxxxxx\"\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Payment intent not found\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while processing payment\" }\n   */\n  public async processPayment({ request, response }: HttpContext) {\n    const user = request.user\n    if (!user) return response.unauthorized({ message: 'User not authenticated' })\n    const trx = await prisma.$transaction(async (tx) => {\n      try {\n        const { paymentIntentId } = processPaymentSchema.parse(request.body())\n        const result = await this.checkoutService.processPayment(user.id, paymentIntentId, tx)\n        return response.ok(result)\n      } catch (error) {\n        logger.error({ err: error }, 'Error in processPayment')\n        if (error instanceof z.ZodError) {\n          return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n        }\n        if (error instanceof Error && error.message === 'Payment intent not found') {\n          return response.notFound({ message: error.message })\n        }\n        throw error // Re-throw to trigger transaction rollback\n      }\n    })\n\n    return trx\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\code_checks_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport CodeCheckService from '#services/code_check_service'\nimport { codeCheckRequestSchema, type CodeCheckRequest } from '#validators/code_check'\nimport { prisma } from '#services/prisma_service'\n\n@inject()\nexport default class CodeCheckController {\n  constructor(protected codeCheckService: CodeCheckService) {}\n\n  public async publicCheckCode({ request, response }: HttpContext) {\n    try {\n      const data = request.only(['code', 'language'])\n      const validatedData = codeCheckRequestSchema.parse(data) as CodeCheckRequest\n      const result = await this.codeCheckService.performCodeCheck(\n        validatedData.code,\n        validatedData.language\n      )\n\n      return response.status(200).json(result)\n    } catch (error) {\n      if (error.code === 'P2002') {\n        return response.status(400).json({ message: 'Invalid input', errors: error.message })\n      }\n\n      console.error('Code check error:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while processing the request.' })\n    }\n  }\n\n  public async checkAndStoreCode({ request, response }: HttpContext) {\n    try {\n      const data = request.only(['code', 'language', 'repoId'])\n      const validatedData = codeCheckRequestSchema.parse(data) as CodeCheckRequest & {\n        repoId: string\n      }\n\n      const repoExists = await prisma.codeRepo.findUnique({\n        where: { id: validatedData.repoId },\n      })\n      if (!repoExists) {\n        return response.status(404).json({ message: 'Repository not found.' })\n      }\n\n      const result = await this.codeCheckService.performAndStoreCodeCheck(\n        validatedData.repoId,\n        validatedData.code,\n        validatedData.language\n      )\n\n      return response.status(200).json(result)\n    } catch (error) {\n      if (error.code === 'P2002') {\n        return response.status(400).json({ message: 'Invalid input', errors: error.message })\n      }\n\n      console.error('Code check error:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while processing the request.' })\n    }\n  }\n\n  public async getCodeCheck({ params, response, request }: HttpContext) {\n    try {\n      const { id } = params\n\n      const repoExists = await prisma.codeRepo.findUnique({\n        where: { id },\n      })\n      if (!repoExists) {\n        return response.status(404).json({ message: 'Repository not found.' })\n      }\n\n      const result = await this.codeCheckService.getLatestCodeCheck(id, request.user?.id ?? '')\n\n      if (!result) {\n        return response\n          .status(404)\n          .json({ message: 'No code check result found for this repository.' })\n      }\n\n      return response.status(200).json(result)\n    } catch (error) {\n      console.error('Error retrieving code check result:', error)\n      return response\n        .status(500)\n        .json({ message: 'An error occurred while retrieving the code check result.' })\n    }\n  }\n\n\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\comments_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { CommentService } from '#services/comment_service'\nimport { z } from 'zod'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { VoteType } from '@prisma/client'\n\nconst createCommentSchema = z.object({\n  content: z.string().min(1).max(1000),\n  reviewId: z.string(),\n})\n\nconst updateCommentSchema = z.object({\n  content: z.string().max(1000).optional(),\n  flag: z.enum(['NONE']).optional(),\n})\n\nconst paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  perPage: z.coerce.number().int().positive().max(100).default(10),\n  //reviewId: z.string().cuid(),\n})\n\nconst voteSchema = z.object({\n  type: z.enum(['UPVOTE', 'DOWNVOTE']),\n})\n\n@inject()\nexport default class CommentController {\n  constructor(protected commentService: CommentService) {}\n\n  /**\n   * @createComment\n   * @description Create a new comment for a review.\n   * @route POST /comments\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"This is a comment\",\n   *   \"reviewId\": \"cuid1234567890\"\n   * }\n   * @responseBody 201 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\"\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const data = request.all()\n      const validatedData = createCommentSchema.parse(data)\n      const comment = await this.commentService.createComment({\n        ...validatedData,\n        userId,\n      })\n      return response.status(201).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getCommentsByReview\n   * @description Get paginated comments for a specific review.\n   * @route GET /repo/:repoId/reviews/:reviewId\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} page - Page number for pagination.\n   * @queryParam {number} perPage - Number of items per page.\n   * @responseBody 200 - {\n   *   \"data\": [\n   *     {\n   *       \"id\": \"cuid1234567890\",\n   *       \"content\": \"This is a comment\",\n   *       \"userId\": \"user123\",\n   *       \"reviewId\": \"review456\",\n   *       \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *       \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *       \"upvotes\": 5,\n   *       \"downvotes\": 2\n   *     },\n   *     ...\n   *   ],\n   *   \"meta\": {\n   *     \"total\": 100,\n   *     \"page\": 1,\n   *     \"perPage\": 10,\n   *     \"lastPage\": 10\n   *   }\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async getCommentsByReview({ params, request, response }: HttpContext) {\n    try {\n      const { reviewId } = params\n      const { page, perPage } = paginationSchema.parse(request.qs())\n      const comments = await this.commentService.getPaginatedCommentsByReview(\n        reviewId,\n        page,\n        perPage\n      )\n      return response.status(200).json(comments)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getCommentById\n   * @description Get a specific comment by its ID.\n   * @route GET /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async getById({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.getCommentById(id)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateComment\n   * @description Update a specific comment.\n   * @route PUT /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"Updated comment content\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"Updated comment content\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      const data = updateCommentSchema.parse(request.all())\n      const comment = await this.commentService.updateComment(id, data)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @revertCommentFlag\n   * @description Revert the flag on a comment to NONE.\n   * @route PUT /comments/:id/revert\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"flag\": \"NONE\",\n   *   \"upvotes\": 5,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async revertFlag({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.revertFlag(id)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @deleteComment\n   * @description Soft delete a specific comment.\n   * @route DELETE /comments/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { \"message\": \"Comment deleted successfully\", \"comment\": {...} }\n   * @responseBody 400 - { \"message\": \"Invalid ID\", \"errors\": [...] }\n   */\n  public async delete({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const comment = await this.commentService.deleteComment(id)\n      return response.status(200).json({ message: 'Comment deleted successfully', comment })\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Invalid ID', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getAllFlaggedComments\n   * @description Get all flagged comments.\n   * @route GET /comments/flagged\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - [\n   *   {\n   *     \"id\": \"cuid1234567890\",\n   *     \"content\": \"This is a flagged comment\",\n   *     \"userId\": \"user123\",\n   *     \"reviewId\": \"review456\",\n   *     \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *     \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *     \"flag\": \"INAPPROPRIATE_LANGUAGE\"\n   *   },\n   *   ...\n   * ]\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const comments = await this.commentService.getAllFlaggedComments()\n      return response.status(200).json(comments)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @handleVote\n   * @description Handle upvote or downvote for a comment.\n   * @route POST /comments/:id/vote\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"type\": \"UPVOTE\" | \"DOWNVOTE\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid1234567890\",\n   *   \"content\": \"This is a comment\",\n   *   \"userId\": \"user123\",\n   *   \"reviewId\": \"review456\",\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 6,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async handleVote({ params, request, response }: HttpContext) {\n    try {\n      const { id, vote } = params\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      // process the types into the enum\n      const voteType = vote === 'upvote' ? VoteType.UPVOTE : VoteType.DOWNVOTE\n\n      const comment = await this.commentService.handleVote(id, userId, voteType)\n      return response.status(200).json(comment)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\dashboard_controller.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport AdminDashboardService from '#services/admin_dashboard_service'\nimport UserDashboardService from '#services/user_dashboard_service'\nimport ModeratorDashboardService from '#services/moderator_dashboard_service'\n\n@inject()\nexport default class DashboardController {\n  constructor(\n    private adminDashboardService: AdminDashboardService,\n    private moderatorDashboardService: ModeratorDashboardService,\n    private userDashboardService: UserDashboardService\n  ) {}\n\n  /**\n   * @getAdminDashboardData\n   * @description Get admin dashboard data\n   * @responseBody 200 - { salesOverview: {...}, userStatistics: {...}, ... }\n   * @responseBody 403 - { error: \"Unauthorized access\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getAdminDashboardData({ request, response }: HttpContext) {\n    try {\n      if (request.user?.role !== 'ADMIN') {\n        return response.forbidden({ error: 'Unauthorized access' })\n      }\n\n      const dashboardData = await this.adminDashboardService.getDashboardData()\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching admin dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n\n  /**\n   * @getModeratorDashboardData\n   * @description Get moderator dashboard data\n   * @responseBody 200 - { contentModerationOverview: {...}, moderationActivity: {...}, ... }\n   * @responseBody 403 - { error: \"Unauthorized access\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getModeratorDashboardData({ request, response }: HttpContext) {\n    try {\n      if (request.user?.role !== 'MODERATOR') {\n        return response.forbidden({ error: 'Unauthorized access' })\n      }\n\n      const dashboardData = await this.moderatorDashboardService.getDashboardData(request.user.id)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching moderator dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n\n  /**\n   * @getUserDashboardData\n   * @description Get user dashboard data\n   * @responseBody 200 - { purchaseHistory: {...}, accessedRepos: [...], ... }\n   * @responseBody 401 - { error: \"Unauthorized\" }\n   * @responseBody 500 - { error: \"Internal server error\" }\n   */\n  public async getUserDashboardData({ request, response }: HttpContext) {\n    try {\n      if (!request.user) {\n        return response.unauthorized({ error: 'Unauthorized' })\n      }\n\n      const dashboardData = await this.userDashboardService.getDashboardData(request.user.id)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching user dashboard data:', error)\n      return response.internalServerError({ error: 'Internal server error' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\health_checks_controller.ts</source>
<document_content>import { healthChecks } from '#start/health'\nimport type { HttpContext } from '@adonisjs/core/http'\n\nexport default class HealthChecksController {\n  async handle({ response }: HttpContext) {\n    const report = await healthChecks.run()\n\n    if (report.isHealthy) {\n      return response.ok(report)\n    }\n\n    return response.serviceUnavailable(report)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\orders_controller.ts</source>
<document_content>import { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport OrderService from '#services/order_service'\nimport { prisma } from '#services/prisma_service'\nimport { OrderStatus } from '@prisma/client'\n\nconst createOrderSchema = z.object({\n  repoId: z.string(),\n  amount: z.number().positive(),\n  stripePaymentIntentId: z.string(),\n})\n\nconst updateOrderSchema = z.object({\n  status: z.nativeEnum(OrderStatus),\n})\n\n@inject()\nexport default class OrderController {\n  constructor(protected orderService: OrderService) {}\n\n  /**\n   * @createOrder\n   * @description Create a new order\n   * @requestBody {\n   *   \"repoId\": \"clxxxxxxxxxxxxxxxx\",\n   *   \"amount\": 1000,\n   *   \"stripePaymentIntentId\": \"pi_xxxxxxxxxxxxx\"\n   * }\n   * @responseBody 201 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Failed to create order\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const data = createOrderSchema.parse(request.body())\n      const userId = request.user?.id\n\n      if (!userId) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n\n      const order = await this.orderService.createOrder({\n        userId,\n        repoId: data.repoId,\n        amount: data.amount,\n        status: OrderStatus.SUCCEEDED, // Assuming default status, adjust as needed\n        stripePaymentIntentId: data.stripePaymentIntentId,\n      })\n      return response.created(order)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      return response.internalServerError({ message: 'Failed to create order' })\n    }\n  }\n\n  /**\n   * @getOrder\n   * @description Get an order by ID\n   * @paramParam id - The ID of the order\n   * @responseBody 200 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 404 - { \"message\": \"Order not found\" }\n   */\n  public async show({ params, response, request }: HttpContext) {\n    const userId = request.user?.id\n\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    const order = await this.orderService.getOrderById(params.id)\n    if (!order) {\n      return response.notFound({ message: 'Order not found' })\n    }\n\n    // Check if the order belongs to the authenticated user\n    if (order.userId !== userId) {\n      return response.forbidden({ message: 'Access denied' })\n    }\n\n    return response.ok(order)\n  }\n\n  /**\n   * @listOrders\n   * @description List orders for the authenticated user\n   * @queryParam page - Page number\n   * @queryParam limit - Number of items per page\n   * @responseBody 200 - { \"data\": [...], \"meta\": { ... } }\n   */\n  public async index({ request, response }: HttpContext) {\n    const userId = request.user?.id\n\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    // Since getOrdersByUser is not implemented in the service, we'll use prisma directly here\n    // In a real-world scenario, you should implement this method in the OrderService\n    const orders = await prisma.order.findMany({\n      where: { userId },\n      orderBy: { createdAt: 'desc' },\n      include: {\n        codeRepo: {\n          select: {\n            name: true,\n          },\n        },\n        user: {\n          select: {\n            email: true,\n          },\n        },\n      },\n    })\n\n    const total = await prisma.order.count({ where: { userId } })\n\n    return response.ok({\n      data: orders,\n      meta: {\n        total,\n      },\n    })\n  }\n\n  /**\n   * @updateOrder\n   * @description Update an order's status\n   * @paramParam id - The ID of the order\n   * @requestBody {\n   *   \"status\": \"CANCELLED\"\n   * }\n   * @responseBody 200 - { \"id\": \"clxxxxxxxxxxxxxxxx\", ... }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Order not found\" }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { status } = updateOrderSchema.parse(request.body())\n      const userId = request.user?.id\n\n      if (!userId) {\n        return response.unauthorized({ message: 'User not authenticated' })\n      }\n\n      const order = await this.orderService.getOrderById(params.id)\n      if (!order) {\n        return response.notFound({ message: 'Order not found' })\n      }\n\n      if (order.userId !== userId) {\n        return response.forbidden({ message: 'Access denied' })\n      }\n\n      const updatedOrder = await this.orderService.updateOrderStatus(params.id, status)\n      return response.ok(updatedOrder)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      return response.internalServerError({ message: 'Failed to update order' })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\payout_request_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { z } from 'zod'\nimport PayoutRequestService from '#services/payout_request_service'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { createPayoutRequestSchema, updatePayoutRequestSchema } from '#validators/payout_request'\nimport { PayoutRequestStatus } from '@prisma/client'\n\n@inject()\nexport default class PayoutRequestController {\n  constructor(protected payoutRequestService: PayoutRequestService) {}\n\n  public async create({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const data = createPayoutRequestSchema.parse(request.body())\n      const payoutRequest = await this.payoutRequestService.createPayoutRequest(\n        request.user.id,\n        data\n      )\n      return response.status(201).json(payoutRequest)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.abort({ message: 'Validation error', errors: error.errors }, 400)\n      }\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getSellerBalance({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const balance = await this.payoutRequestService.getSellerBalance(request.user.id)\n      return response.status(200).json(balance)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getById({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const payoutRequest = await this.payoutRequestService.getPayoutRequestById(id)\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async update({ params, request, response }: HttpContext) {\n    const { id } = params\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const data = updatePayoutRequestSchema.parse(request.body()) as {\n        status: PayoutRequestStatus\n      }\n      const payoutRequest = await this.payoutRequestService.updatePayoutRequest(id, data.status)\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.abort({ message: 'Validation error', errors: error.errors }, 400)\n      }\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async delete({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      await this.payoutRequestService.deletePayoutRequest(id)\n      return response.status(200).json({ message: 'PayoutRequest deleted successfully' })\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getPaginated({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n    try {\n      const payoutRequests = await this.payoutRequestService.getPaginatedPayoutRequests(page, limit)\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getAll({ response }: HttpContext) {\n    try {\n      const payoutRequests = await this.payoutRequestService.getAllPayoutRequests()\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async getCurrentUserPayoutRequests({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n    try {\n      const payoutRequests = await this.payoutRequestService.getPayoutRequestsByUser(\n        request.user.id\n      )\n      return response.status(200).json(payoutRequests)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n\n  public async processPayoutRequest({ params, request, response }: HttpContext) {\n    const { id } = params\n    if (!request.user) throw new UnAuthorizedException('User not found in request object')\n\n    try {\n      const { action } = request.body()\n      const payoutRequest = await this.payoutRequestService.processPayoutRequest(\n        id,\n        action,\n        request.user.id\n      )\n      return response.status(200).json(payoutRequest)\n    } catch (error) {\n      return response.abort({ message: error.message }, 400)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\profile_controller.ts</source>
<document_content>// controllers/ProfileController.ts\nimport { HttpContext } from '@adonisjs/core/http'\nimport { ProfileService } from '#services/profile_service'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { S3Facade } from '#integrations/s3/s3_facade'\nimport { updateProfileSchema, updateSellerProfileSchema } from '#validators/profile'\nimport { Multipart } from '@adonisjs/core/bodyparser'\nimport { ZodError } from 'zod'\nimport InvalidImageException from '#exceptions/invalid_image_exception'\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class ProfileController {\n  constructor(\n    protected profileService: ProfileService,\n    protected s3Facade: S3Facade\n  ) {}\n\n  /**\n   * @createProfile\n   * @description Create a new user profile\n   * @requestBody {\n   *   \"profileImg\": <file>,\n   *   \"name\": \"John Doe\",\n   *   \"phoneNumber\": \"+1234567890\"\n   * }\n   * @responseBody 201 - { \"profile\": { \"id\": \"...\", \"name\": \"...\", \"phoneNumber\": \"...\", \"userId\": \"...\" }, \"signedUrl\": \"...\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 409 - { \"message\": \"Profile already exists for this user\" }\n   */\n  async createProfile({ request, response }: HttpContext) {\n    try {\n      const userId = request.user!.id\n      const { name, phoneNumber } = request.only(['name', 'phoneNumber'])\n\n      let profileData: { name?: string; phoneNumber?: string } = { name, phoneNumber }\n      const result = await this.profileService.createProfile(userId, profileData)\n      return response.created(result)\n    } catch (error) {\n      if (error instanceof Error) {\n        return response.status(400).json({ message: error.message })\n      }\n      return response.status(500).json({ message: 'An error occurred while creating the profile' })\n    }\n  }\n\n  /**\n   * @getProfile\n   * @description Get the authenticated user's profile\n   * @responseBody 200 - { \"id\": \"...\", \"name\": \"...\", \"phoneNumber\": \"...\", \"userId\": \"...\", \"profileImgUrl\": \"...\" }\n   * @responseBody 404 - { \"message\": \"Profile not found\" }\n   */\n  async getProfile({ request, response }: HttpContext) {\n    const userId = request.user!.id\n    const profile = await this.profileService.getProfile(userId)\n    if (!profile) {\n      return response.notFound({ message: 'Profile not found' })\n    }\n    return response.ok(profile)\n  }\n\n  /**\n   * @updateSellerProfile\n   * @description Update seller profile information including bank account details\n   * @requestBody {\n   *   \"businessName\": \"My Business\",\n   *   \"businessAddress\": \"123 Business St\",\n   *   \"businessPhone\": \"+1234567890\",\n   *   \"businessEmail\": \"business@example.com\",\n   *   \"accountHolderName\": \"John Doe\",\n   *   \"accountNumber\": \"1234567890\",\n   *   \"bankName\": \"Example Bank\",\n   *   \"swiftCode\": \"EXAMPLECODE\",\n   *   \"iban\": \"GB29NWBK60161331926819\",\n   *   \"routingNumber\": \"11122233\"\n   * }\n   * @responseBody 200 - { \"message\": \"Seller profile updated successfully\", \"status\": \"success\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Seller profile update failed\" }\n   */\n  async updateSellerProfile({ request, response }: HttpContext) {\n    const user = request.user!\n\n    try {\n      const sellerProfileData = request.only([\n        'businessName',\n        'businessAddress',\n        'businessPhone',\n        'businessEmail',\n        'accountHolderName',\n        'accountNumber',\n        'bankName',\n        'swiftCode',\n        'iban',\n        'routingNumber',\n      ])\n\n      const validatedData = updateSellerProfileSchema.parse(sellerProfileData)\n\n      await prisma.$transaction(async (tx) => {\n        // Update or create SellerProfile\n        const updatedSellerProfile = await tx.sellerProfile.upsert({\n          where: { userId: user.id },\n          update: {\n            businessName: validatedData.businessName,\n            businessAddress: validatedData.businessAddress,\n            businessPhone: validatedData.businessPhone,\n            businessEmail: validatedData.businessEmail,\n          },\n          create: {\n            userId: user.id,\n            businessName: validatedData.businessName,\n            businessAddress: validatedData.businessAddress,\n            businessPhone: validatedData.businessPhone,\n            businessEmail: validatedData.businessEmail,\n          },\n        })\n\n        // Update or create BankAccount\n        await tx.bankAccount.upsert({\n          where: { sellerProfileId: updatedSellerProfile.id },\n          update: {\n            accountHolderName: validatedData.accountHolderName,\n            accountNumber: validatedData.accountNumber,\n            bankName: validatedData.bankName,\n            swiftCode: validatedData.swiftCode,\n            iban: validatedData.iban,\n            routingNumber: validatedData.routingNumber,\n          },\n          create: {\n            sellerProfileId: updatedSellerProfile.id,\n            accountHolderName: validatedData.accountHolderName,\n            accountNumber: validatedData.accountNumber,\n            bankName: validatedData.bankName,\n            swiftCode: validatedData.swiftCode,\n            iban: validatedData.iban,\n            routingNumber: validatedData.routingNumber,\n          },\n        })\n      })\n\n      return response.status(200).json({\n        message: 'Seller profile updated successfully',\n        status: 'success',\n      })\n    } catch (error) {\n      if (error instanceof ZodError) {\n        return response.status(400).json({\n          message: 'Validation failed',\n          errors: error.errors,\n        })\n      } else {\n        logger.error('Seller profile update failed:', error)\n        return response.status(500).json({ message: 'Seller profile update failed' })\n      }\n    }\n  }\n\n  /*  /**\n   * @updateProfile\n   * @description Update user profile information and optionally upload a profile image\n   * @requestBody {\n   *   \"name\": \"John Doe\",\n   *   \"phoneNumber\": \"+1234567890\",\n   *   \"profileImg\": File (optional)\n   * }\n   * @responseBody 200 - { \"message\": \"Profile updated successfully\", \"status\": \"success\" }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 500 - { \"message\": \"Profile update failed\" }\n   */\n  async updateProfile({ request, response }: HttpContext) {\n    const user = request.user!\n    console.log(request.headers())\n\n    try {\n      const { name, phoneNumber } = request.only(['name', 'phoneNumber'])\n      updateProfileSchema.parse({ name, phoneNumber })\n\n      if (!request.multipart) {\n        await this.updateProfileWithoutImage(user.id, name, phoneNumber)\n      } else {\n        await this.updateProfileWithImage(user.id, name, phoneNumber, request.multipart)\n      }\n\n      return response.status(200).json({\n        message: 'Profile updated successfully',\n        status: 'success',\n      })\n    } catch (error) {\n      if (error instanceof ZodError) {\n        return response.status(400).json({\n          message: 'Validation failed',\n        })\n      }\n      if (error instanceof InvalidImageException) {\n        return response.status(400).json({ message: 'Invalid image format' })\n      } else {\n        logger.error('Profile update failed:', error)\n      }\n      return response.status(500).json({ message: 'Profile update failed' })\n    }\n  }\n\n  private async updateProfileWithoutImage(userId: string, name: string, phoneNumber: string) {\n    await prisma.profile.upsert({\n      where: { userId },\n      update: { name, phoneNumber },\n      create: { name, phoneNumber, userId },\n    })\n  }\n\n  private updateProfileWithImage(\n    userId: string,\n    name: string,\n    phoneNumber: string,\n    multipart: Multipart\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      multipart.onFile('profileImg', {}, async (part) => {\n        try {\n          // validate if it is an image\n          if (!part.headers['content-type']?.startsWith('image/')) {\n            return reject(new InvalidImageException())\n          }\n          const buffer = await this.readFileBuffer(part)\n          const fileType = part.headers['content-type']\n\n          await prisma.$transaction(async (tx) => {\n            const { media } = await this.s3Facade.uploadFile(buffer, fileType, tx, 'profile-images')\n            await tx.profile.upsert({\n              where: { userId },\n              update: { name, phoneNumber, profileImg: media.url },\n              create: { userId, name, phoneNumber, profileImg: media.url },\n            })\n          })\n\n          resolve()\n        } catch (error) {\n          console.error('Profile image upload error:', error)\n          reject(error)\n        }\n      })\n\n      multipart.process()\n    })\n  }\n\n  private async readFileBuffer(part: any): Promise<Buffer> {\n    part.pause()\n    const chunks: Buffer[] = []\n    for await (const chunk of part) {\n      chunks.push(chunk)\n    }\n    return Buffer.concat(chunks)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\repos_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { z } from 'zod'\nimport { createRepoSchema, updateRepoSchema } from '#validators/repo'\nimport { Language, Visibility } from '@prisma/client'\nimport RepoService from '#services/repo_service'\nimport CodeCheckService from '#services/code_check_service'\nimport CodeRepoSearchService, { SearchCriteria } from '#services/repo_search_service'\nimport logger from '@adonisjs/core/services/logger'\nimport RepoAccessService from '#services/repo_access_service'\nimport { QUIZ_APP, QUIZ_APP_CSS } from '#database/seeders/constants'\n\nconst searchSchema = z.object({\n  query: z.string().optional(),\n  tags: z\n    .union([z.string(), z.array(z.string())])\n    .optional()\n    .transform((val) => (Array.isArray(val) ? val : val ? [val] : undefined)),\n  minPrice: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(0).optional()),\n  maxPrice: z\n    .string()\n    .optional()\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(0).optional()),\n  language: z.nativeEnum(Language).optional(),\n  page: z\n    .string()\n    .default('1')\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(1).optional()),\n  pageSize: z\n    .string()\n    .default('10')\n    .transform((val) => (val ? parseFloat(val) : undefined))\n    .pipe(z.number().min(1).optional()),\n})\n\n@inject()\nexport default class RepoController {\n  constructor(\n    protected repoService: RepoService,\n    protected codeRepoSearchService: CodeRepoSearchService,\n    protected repoAccessService: RepoAccessService,\n    protected codeCheckService: CodeCheckService\n  ) {}\n\n  /**\n   * Create a new Repo.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam {Object} data - The data for the new Repo.\n   * @responseBody 201 - { id: string, name: string, ... } - The created repo\n   * @responseBody 400 - { message: string, errors?: Object[] } - Validation error details\n   * @responseBody 401 - { message: string } - Unauthorized error\n   */\n  public async create({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n\n    try {\n      const data = createRepoSchema.parse(request.body())\n\n      const repo = await this.repoService.createRepo({\n        userId: request.user.id,\n        ...data,\n        sourceJs: QUIZ_APP,\n        sourceCss: QUIZ_APP_CSS,\n        status: 'pending',\n      })\n      return response.created(repo)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Validation error', errors: error.errors })\n      }\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve a Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @responseBody 200 - { repo: Object, repoCodeCheck: Object|null, hasAccess: boolean }\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getById({ params, request, response }: HttpContext) {\n    const user = request.user\n    if (!user) throw new UnAuthorizedException('User not found in request object')\n    const { id } = params\n    try {\n      return await prisma.$transaction(async (tx) => {\n        const repo = await this.repoService.getRepoById(id)\n        if (!repo) {\n          return response.notFound({ message: 'Repo not found' })\n        }\n\n        const hasAccess = await this.repoAccessService.hasAccess(user.id, id, tx)\n        const isOwner = repo.userId === user.id\n        const isAdmin = user.role === 'ADMIN'\n\n        if (!hasAccess && !isOwner && !isAdmin) {\n          return response.forbidden({ message: 'You do not have access to this repository' })\n        }\n\n        const repoCodeCheck = await tx.codeCheck.findFirst({\n          where: {\n            repoId: id,\n          },\n          orderBy: {\n            createdAt: 'desc',\n          },\n        })\n\n        return response.ok({\n          repo,\n          repoCodeCheck: repoCodeCheck ?? null,\n        })\n      })\n    } catch (error) {\n      console.error('Error retrieving repo:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving the repo',\n      })\n    }\n  }\n\n  public async getByIdServer({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      return await prisma.$transaction(async (tx) => {\n        const repo = await this.repoService.getRepoById(id)\n        if (!repo) {\n          return response.notFound({ message: 'Repo not found' })\n        }\n        const repoCodeCheck = await tx.codeCheck.findFirst({\n          where: {\n            repoId: id,\n          },\n          orderBy: {\n            createdAt: 'desc',\n          },\n        })\n\n        return response.ok({\n          repo,\n          repoCodeCheck: repoCodeCheck ?? null,\n        })\n      })\n    } catch (error) {\n      console.error('Error retrieving repo:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving the repo',\n      })\n    }\n  }\n\n  /**\n   * Retrieve a public Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @responseBody 200 - { repo: Object, repoCodeCheck: Object|null }\n   * @responseBody 404 - { message: string } - Not found error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getByIdPublic({ params, response }: HttpContext) {\n    const { id } = params\n    try {\n      const repo = await this.repoService.getRepoByIdPublic(id)\n      if (!repo) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n\n      const repoCodeCheck = await prisma.codeCheck.findFirst({\n        where: {\n          repoId: id,\n        },\n        orderBy: {\n          createdAt: 'desc',\n        },\n      })\n\n      // Transform the repo object to match the expected format\n      const transformedRepo = {\n        ...repo,\n        tags: repo.tags?.map(t => ({ tag: { name: t.tag.name } }))\n      }\n\n      return response.ok({\n        repo: transformedRepo,\n        repoCodeCheck: repoCodeCheck ?? null,\n      })\n    } catch (error) {\n      console.error('Error retrieving public repo:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving the repo',\n      })\n    }\n  }\n\n  /**\n   * Update a Repo.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo.\n   * @bodyParam {Object} data - The data to update the Repo.\n   * @responseBody 200 - { id: string, name: string, ... } - The updated repo\n   * @responseBody 400 - { message: string, errors?: Object[] } - Validation error details\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   */\n  public async update({ params, request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { id } = params\n\n    try {\n      const data = updateRepoSchema.parse(request.body())\n\n      const repo = await this.repoService.getRepoById(id, request.user.id)\n      if (!repo || repo.deletedAt) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n      if (repo.userId !== request.user.id) {\n        return response.forbidden({ message: 'You do not have permission to update this repo' })\n      }\n\n      const updatedRepo = await this.repoService.updateRepo(id, data)\n      return response.ok(updatedRepo)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Validation error', errors: error.errors })\n      }\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Delete a Repo by ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} id - The ID of the Repo to delete.\n   * @responseBody 200 - { message: string } - Success message\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   * @responseBody 404 - { message: string } - Not found error\n   */\n  public async delete({ request, params, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { id } = params\n    try {\n      const repo = await this.repoService.getRepoById(id, request.user.id)\n      if (!repo) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n\n      // For admin users, we'll allow deletion regardless of ownership\n      if (request.user.role !== 'ADMIN' && repo.userId !== request.user.id) {\n        return response.forbidden({ message: 'You do not have permission to delete this repo' })\n      }\n      await this.repoService.softDeleteRepo(id)\n      return response.ok({ message: 'Repo deleted successfully' })\n    } catch (error) {\n      console.error('Error in delete method:', error)\n      if (error instanceof Error && error.message === 'Repo not found') {\n        return response.notFound({ message: 'Repo not found' })\n      }\n      return response.internalServerError({ message: 'An unexpected error occurred' })\n    }\n  }\n\n  /**\n   * Retrieve Repos by user ID.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam {string} userId - The user ID to filter by.\n   * @responseBody 200 - Array of repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 403 - { message: string } - Forbidden error\n   */\n  public async getByUser({ params, request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n    const { userId } = params\n\n    if (userId !== request.user.id && request.user.role !== 'ADMIN') {\n      return response.forbidden({ message: 'You do not have permission to view these repos' })\n    }\n\n    try {\n      const repos = await this.repoService.getReposByUser(userId)\n      return response.ok(repos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve Repos for the authenticated user.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - Array of repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   * @responseBody 401 - { message: string } - Unauthorized error\n   */\n  public async getByUserSession({ request, response }: HttpContext) {\n    if (!request.user) throw new UnAuthorizedException('User not authenticated')\n\n    try {\n      const repos = await this.repoService.getReposByUser(request.user.id)\n      return response.ok(repos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve repos that the authenticated user has access to, including repo data.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { accessibleRepos: Object[] }\n   * @responseBody 401 - { message: string } - Unauthorized error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async getByUserAccessed({ request, response }: HttpContext) {\n    if (!request.user) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const accessibleRepos = await prisma.$transaction(async (tx) => {\n        const accessibleRepoIds = await this.repoAccessService.getUserAccessibleRepos(request.user!.id, tx)\n\n        return tx.codeRepo.findMany({\n          where: {\n            id: { in: accessibleRepoIds },\n            deletedAt: null,\n          },\n          select: {\n            id: true,\n            name: true,\n            description: true,\n            language: true,\n            price: true,\n            createdAt: true,\n            updatedAt: true,\n            sourceCss: true,\n            sourceJs: true,\n          }\n        })\n      })\n\n      return response.ok({ accessibleRepos })\n    } catch (error) {\n      logger.error('Error retrieving accessible repos:', error)\n      return response.internalServerError({\n        message: 'An error occurred while retrieving accessible repos',\n      })\n    }\n  }\n\n  public async publishRepo({ params, request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const publishedRepo = await this.repoService.publishRepo({ id: params.id, userId })\n      return response.ok({\n        message: 'Repo published successfully',\n        repo: publishedRepo\n      })\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid input data', errors: error.errors })\n      }\n      return response.internalServerError({ message: error.message, error: error.message })\n    }\n  }\n\n  public async submitCodeCheck({ params, request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const repo = await this.repoService.getRepoById(params.id, userId)\n      if (!repo) {\n        return response.notFound({ message: 'Repo not found' })\n      }\n\n      const checkedRepo = await this.repoService.submitCodeCheck(repo.id, userId)\n      return response.ok(checkedRepo)\n    } catch (error) {\n      return response.internalServerError({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve featured repos.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} [limit=5] - The number of featured repos to return.\n   * @responseBody 200 - Array of featured repo objects\n   * @responseBody 400 - { message: string } - Bad request error\n   */\n  public async getFeatured({ request, response }: HttpContext) {\n    const limit = request.input('limit', 5)\n\n    try {\n      const featuredRepos = await this.repoService.getFeaturedRepos(limit)\n      return response.ok(featuredRepos)\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * Search for code repositories based on various criteria.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {string} [query] - Search query for name and description\n   * @queryParam {string|string[]} [tags] - Array of tag names to filter by\n   * @queryParam {number} [minPrice] - Minimum price\n   * @queryParam {number} [maxPrice] - Maximum price\n   * @queryParam {Language} [language] - Filter by programming language\n   * @queryParam {number} [page=1] - Page number for pagination\n   * @queryParam {number} [pageSize=10] - Number of items per page\n   * @responseBody 200 - { data: Array<Object>, meta: { total: number, page: number, pageSize: number, lastPage: number } }\n   * @responseBody 400 - { message: string, errors?: Object[] } - Bad request or validation error\n   * @responseBody 500 - { message: string } - Internal server error\n   */\n  public async search({ request, response }: HttpContext) {\n    try {\n      const validatedData = searchSchema.parse(request.qs())\n\n      const searchCriteria: SearchCriteria = {\n        query: validatedData.query,\n        tags: validatedData.tags,\n        minPrice: validatedData.minPrice,\n        maxPrice: validatedData.maxPrice,\n        language: validatedData.language,\n      }\n\n      const userId = request.user?.id\n\n      const result = await this.codeRepoSearchService.search(\n        searchCriteria,\n        userId,\n        validatedData.page,\n        validatedData.pageSize\n      )\n\n      return response.ok(result)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.badRequest({ message: 'Invalid search criteria', errors: error.errors })\n      }\n      return response.internalServerError({\n        message: 'An error occurred while processing the search',\n      })\n    }\n  }\n\n\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\reviews_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport { ReviewService } from '#services/review_service'\nimport { z } from 'zod'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { VoteType } from '@prisma/client'\n\nconst createReviewSchema = z.object({\n  content: z.string().min(1).max(1000),\n  repoId: z.string(),\n  rating: z.number().int().min(1).max(5),\n})\n\nconst updateReviewSchema = z.object({\n  content: z.string().min(1).max(1000).optional(),\n  rating: z.number().int().min(1).max(5).optional(),\n})\n\nconst paginationSchema = z.object({\n  page: z.coerce.number().int().positive().default(1),\n  perPage: z.coerce.number().int().positive().max(100).default(10),\n})\n\n//const voteSchema = z.object({\n//  type: z.nativeEnum(VoteType),\n//})\n\n/**\n * Controller class for handling Review operations.\n */\n@inject()\nexport default class ReviewController {\n  constructor(protected reviewService: ReviewService) {}\n\n  /**\n   * @createReview\n   * @description Create a new review for a repository.\n   * @route POST /reviews\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"This is a great repository!\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5\n   * }\n   * @responseBody 201 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a great repository!\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\"\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async create({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const data = createReviewSchema.parse(request.all())\n      const review = await this.reviewService.createReview({ ...data, userId })\n      return response.status(201).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getReviewById\n   * @description Retrieve a review by its ID.\n   * @route GET /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a great repository!\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async getById({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.getReviewById(id)\n      return response.status(200).json(review)\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @getPaginatedReviewsByRepo\n   * @description Get paginated reviews for a specific repository.\n   * @route GET /repo/:repoId/reviews\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam {number} page - Page number for pagination.\n   * @queryParam {number} perPage - Number of items per page.\n   * @responseBody 200 - {\n   *   \"data\": [\n   *     {\n   *       \"id\": \"cuid0987654321\",\n   *       \"content\": \"This is a great repository!\",\n   *       \"userId\": \"user123\",\n   *       \"repoId\": \"cuid1234567890\",\n   *       \"rating\": 5,\n   *       \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *       \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *       \"upvotes\": 10,\n   *       \"downvotes\": 2\n   *     },\n   *     ...\n   *   ],\n   *   \"meta\": {\n   *     \"total\": 100,\n   *     \"page\": 1,\n   *     \"perPage\": 10,\n   *     \"lastPage\": 10\n   *   }\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async getPaginatedReviewsByRepo({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      if (!id) throw new Error('Invalid repo ID')\n      const { page, perPage } = paginationSchema.parse(request.qs())\n      const reviews = await this.reviewService.getPaginatedReviewsByRepo(id, page, perPage)\n      return response.status(200).json(reviews)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateReview\n   * @description Update a specific review.\n   * @route PUT /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"content\": \"Updated review content\",\n   *   \"rating\": 4\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"Updated review content\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 4,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   */\n  public async update({ params, request, response }: HttpContext) {\n    try {\n      const { id } = params\n      const data = updateReviewSchema.parse(request.all())\n      const review = await this.reviewService.updateReview(id, data)\n      return response.status(200).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @revertReviewFlag\n   * @description Revert the flag on a review to NONE.\n   * @route PUT /reviews/:id/revert\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a review\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"flag\": \"NONE\",\n   *   \"upvotes\": 10,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async revertFlag({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.revertFlag(id)\n      return response.status(200).json(review)\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @deleteReview\n   * @description Soft delete a specific review.\n   * @route DELETE /reviews/:id\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - { \"message\": \"Review deleted successfully\", \"review\": {...} }\n   * @responseBody 400 - { \"message\": \"Invalid ID\" }\n   */\n  public async delete({ params, response }: HttpContext) {\n    try {\n      const { id } = params\n      const review = await this.reviewService.deleteReview(id)\n      return response.status(200).json({ message: 'Review deleted successfully', review })\n    } catch (error) {\n      return response.status(400).json({ message: 'Invalid ID' })\n    }\n  }\n\n  /**\n   * @getAllFlaggedReviews\n   * @description Get all flagged reviews.\n   * @route GET /reviews/flagged\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @responseBody 200 - [\n   *   {\n   *     \"id\": \"cuid0987654321\",\n   *     \"content\": \"This is a flagged review\",\n   *     \"userId\": \"user123\",\n   *     \"repoId\": \"cuid1234567890\",\n   *     \"rating\": 5,\n   *     \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *     \"updatedAt\": \"2023-07-15T10:00:00Z\",\n   *     \"flag\": \"INAPPROPRIATE_LANGUAGE\"\n   *   },\n   *   ...\n   * ]\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const reviews = await this.reviewService.getAllFlaggedReviews()\n      return response.status(200).json(reviews)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @handleVote\n   * @description Handle upvote or downvote for a review.\n   * @route POST /reviews/:id/vote\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @requestBody {\n   *   \"type\": \"UPVOTE\" | \"DOWNVOTE\"\n   * }\n   * @responseBody 200 - {\n   *   \"id\": \"cuid0987654321\",\n   *   \"content\": \"This is a review\",\n   *   \"userId\": \"user123\",\n   *   \"repoId\": \"cuid1234567890\",\n   *   \"rating\": 5,\n   *   \"createdAt\": \"2023-07-15T10:00:00Z\",\n   *   \"updatedAt\": \"2023-07-15T11:00:00Z\",\n   *   \"upvotes\": 11,\n   *   \"downvotes\": 2\n   * }\n   * @responseBody 400 - { \"message\": \"Validation error\", \"errors\": [...] }\n   * @responseBody 401 - { \"message\": \"Unauthorized\" }\n   */\n  public async handleVote({ params, request, response }: HttpContext) {\n    try {\n      const { id, vote } = params\n      const userId = request.user?.id\n      if (!userId) {\n        throw new UnAuthorizedException('Unauthorized')\n      }\n      const voteType = vote === 'upvote' ? VoteType.UPVOTE : VoteType.DOWNVOTE\n      const review = await this.reviewService.handleVote(id, userId, voteType)\n      return response.status(200).json(review)\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return response.status(400).json({ message: 'Validation error', errors: error.errors })\n      }\n      if (error instanceof UnAuthorizedException) {\n        return response.status(401).json({ message: error.message })\n      }\n      return response.status(400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\seller_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport { inject } from '@adonisjs/core'\nimport SellerService from '#services/seller_service'\nimport {\n  createSellerProfileSchema,\n  updateSellerProfileSchema,\n  createPayoutRequestSchema,\n} from '#validators/seller'\n\n@inject()\nexport default class SellerController {\n  constructor(protected sellerService: SellerService) {}\n\n  /**\n   * @applyForSellerAccount\n   * @description Apply for a seller account including bank account details\n   * @requestBody {\n   *   \"businessName\": \"string\",\n   *   \"businessAddress\": \"string\",\n   *   \"businessPhone\": \"string\",\n   *   \"businessEmail\": \"string\",\n   *   \"accountHolderName\": \"string\",\n   *   \"accountNumber\": \"string\",\n   *   \"bankName\": \"string\",\n   *   \"swiftCode\": \"string\",\n   *   \"iban\": \"string\",\n   *   \"routingNumber\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Application submitted successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 401 - { \"message\": \"User not authenticated\" }\n   * @responseBody 500 - { \"message\": \"An error occurred while processing the request\" }\n   */\n  public async applyForSellerAccount({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const data = createSellerProfileSchema.parse(request.body())\n\n      const profile = await this.sellerService.applyForSellerAccount(userId, data)\n\n      return response.ok({\n        message: 'Application submitted successfully',\n        profile,\n      })\n    } catch (error) {\n      if (error.name === 'ZodError') {\n        return response.badRequest({\n          message: 'Invalid input data',\n          errors: error.errors,\n        })\n      }\n\n      console.error('Error in applyForSellerAccount:', error)\n      return response.internalServerError({\n        message: 'An error occurred while processing the request',\n      })\n    }\n  }\n\n  /**\n   * @updateProfile\n   * @description Update the current seller's profile\n   * @requestBody {\n   *   \"businessName\": \"string\",\n   *   \"businessAddress\": \"string\",\n   *   \"businessPhone\": \"string\",\n   *   \"businessEmail\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Profile updated successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async updateProfile({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const data = updateSellerProfileSchema.parse(request.body())\n      const profile = await this.sellerService.updateSellerProfile(userId, data)\n      return response.ok({ message: 'Profile updated successfully', profile })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * @getBalance\n   * @description Get the current seller's balance\n   * @responseBody 200 - { \"balance\": number }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async getBalance({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized('User not authenticated')\n    }\n\n    const balance = await this.sellerService.getSellerBalance(userId)\n    return response.ok({ balance })\n  }\n\n  /**\n   * @requestPayout\n   * @description Request a payout for the current seller\n   * @requestBody {\n   *   \"amount\": number\n   * }\n   * @responseBody 201 - { \"message\": \"Payout request submitted\", \"request\": PayoutRequest }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" or \"Insufficient balance\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async requestPayout({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const { amount } = createPayoutRequestSchema.parse(request.body())\n      const payoutRequest = await this.sellerService.requestPayout(userId, amount)\n      return response.created({ message: 'Payout request submitted', request: payoutRequest })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  /**\n   * @getPayoutHistory\n   * @description Get the payout history for the current seller\n   * @responseBody 200 - { \"payouts\": PayoutRequest[] }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async getPayoutHistory({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized('User not authenticated')\n    }\n\n    const payouts = await this.sellerService.getPayoutHistory(userId)\n    return response.ok({ payouts })\n  }\n\n  /**\n   * @uploadIdentityDocument\n   * @description Upload or update the identity document for the current seller\n   * @requestBody {\n   *   \"documentUrl\": \"string\"\n   * }\n   * @responseBody 200 - { \"message\": \"Document uploaded successfully\", \"profile\": SellerProfile }\n   * @responseBody 400 - { \"message\": \"Invalid input data\" }\n   * @responseBody 404 - { \"message\": \"Seller profile not found\" }\n   */\n  public async uploadIdentityDocument({ request, response }: HttpContext) {\n    try {\n      const userId = request.user?.id\n      if (!userId) {\n        return response.unauthorized('User not authenticated')\n      }\n\n      const { documentUrl } = request.body()\n      if (!documentUrl) {\n        return response.badRequest({ message: 'Document URL is required' })\n      }\n\n      const profile = await this.sellerService.uploadIdentityDocument(userId, documentUrl)\n      return response.ok({ message: 'Document uploaded successfully', profile })\n    } catch (error) {\n      return response.badRequest({ message: error.message })\n    }\n  }\n\n  public async getDashboardData({ request, response }: HttpContext) {\n    const userId = request.user?.id\n    if (!userId) {\n      return response.unauthorized({ message: 'User not authenticated' })\n    }\n\n    try {\n      const days = request.input('days', 30) // Allow specifying days, default to 30\n      const dashboardData = await this.sellerService.getDashboardData(userId, days)\n      return response.ok(dashboardData)\n    } catch (error) {\n      console.error('Error fetching dashboard data:', error)\n      return response.internalServerError({\n        message: 'An error occurred while fetching dashboard data',\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\supports_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport SupportTicketService from '#services/support_service'\nimport { inject } from '@adonisjs/core'\nimport { SupportTicketStatus } from '@prisma/client'\n\n@inject()\nexport default class SupportController {\n  constructor(protected supportTicketService: SupportTicketService) {}\n\n  /**\n   * @createTicket\n   * @description Create a new support ticket.\n   * @bodyParam email string - The user's email address.\n   * @bodyParam title string - The title of the support ticket.\n   * @bodyParam content string - The content of the support ticket.\n   * @bodyParam type string - The type of the support ticket.\n   * @responseBody 201 - { \"message\": \"Support ticket created successfully\", \"ticket\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async createTicket({ request, response }: HttpContext) {\n    try {\n      const { email, title, content, type } = request.only(['email', 'title', 'content', 'type'])\n      const ticket = await this.supportTicketService.createTicket(email, title, content, type)\n      return response.status(201).json({ message: 'Support ticket created successfully', ticket })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getPaginatedTickets\n   * @description Get paginated support tickets.\n   * @queryParam page number - The page number for pagination.\n   * @queryParam limit number - The number of tickets per page.\n   * @responseBody 200 - { \"data\": [...], \"meta\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  //async getPaginatedTickets({ request, response }: HttpContext) {\n  //  try {\n  //    const page = request.input('page', 1)\n  //    const limit = request.input('limit', 10)\n  //    const { data, meta } = await this.supportTicketService.getPaginatedTickets(Number(page), Number(limit))\n  //    return response.ok({ data, meta })\n  //  } catch (error) {\n  //    return response.status(400).json({ message: error.message })\n  //  }\n  //}\n\n  /**\n   * @getAllTickets\n   * @description Get all support tickets.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getAllTickets({ response }: HttpContext) {\n    try {\n      const tickets = await this.supportTicketService.getAllTickets()\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketById\n   * @description Get a support ticket by ID.\n   * @paramParam id string - The ID of the support ticket.\n   * @responseBody 200 - { \"ticket\": {...} }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketById({ params, response }: HttpContext) {\n    try {\n      const ticket = await this.supportTicketService.getTicketById(params.id)\n      if (!ticket) {\n        return response.notFound({ message: 'Ticket not found' })\n      }\n      return response.ok(ticket)\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByTitle\n   * @description Get support tickets by title.\n   * @queryParam title string - The title to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByTitle({ request, response }: HttpContext) {\n    try {\n      const title = request.input('title')\n      const tickets = await this.supportTicketService.getTicketsByTitle(title)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByEmail\n   * @description Get support tickets by email.\n   * @queryParam email string - The email to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByEmail({ request, response }: HttpContext) {\n    try {\n      const email = request.input('email')\n      const tickets = await this.supportTicketService.getTicketsByEmail(email)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @getTicketsByStatus\n   * @description Get support tickets by status.\n   * @queryParam status string - The status to search for.\n   * @responseBody 200 - { \"tickets\": [...] }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async getTicketsByStatus({ request, response }: HttpContext) {\n    try {\n      const status = request.input('status')\n      const tickets = await this.supportTicketService.getTicketsByStatus(status)\n      return response.ok({ tickets })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @updateTicket\n   * @description Update a support ticket status.\n   * @paramParam id string - The ID of the support ticket.\n   * @bodyParam status string - The new status of the support ticket.\n   * @responseBody 200 - { \"ticket\": {...} }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   */\n  async updateTicket({ params, request, response }: HttpContext) {\n    try {\n      const { status } = request.only(['status'])\n      if (!Object.values(SupportTicketStatus).includes(status)) {\n        return response.badRequest({ message: 'Invalid status provided' })\n      }\n      const ticket = await this.supportTicketService.updateTicket(params.id, status)\n      if (!ticket) {\n        return response.notFound({ message: 'Ticket not found' })\n      }\n      return response.ok({ ticket })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * @deleteTicket\n   * @description Delete a support ticket.\n   * @paramParam id string - The ID of the support ticket.\n   * @responseBody 200 - { \"message\": \"Ticket deleted successfully\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   * @responseBody 404 - { \"message\": \"Ticket not found\" }\n   */\n  //async deleteTicket({ params, response }: HttpContext) {\n  //  try {\n  //    const result = await this.supportTicketService.deleteTicket(params.id)\n  //    if (!result) {\n  //      return response.notFound({ message: 'Ticket not found' })\n  //    }\n  //    return response.ok({ message: 'Ticket deleted successfully' })\n  //  } catch (error) {\n  //    return response.status(400).json({ message: error.message })\n  //  }\n  //}\n\n  /**\n   * @sendDefaultEmail\n   * @description Send a default email notification.\n   * @bodyParam email string - The email address to send the notification to.\n   * @responseBody 200 - { \"message\": \"Email sent successfully\" }\n   * @responseBody 400 - { \"message\": \"Error message\" }\n   */\n  async sendDefaultEmail({ request, response }: HttpContext) {\n    try {\n      const { email } = request.only(['email'])\n      await this.supportTicketService.sendDefaultEmail(email)\n      return response.ok({ message: 'Email sent successfully' })\n    } catch (error) {\n      return response.status(400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\controllers\users_controller.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\n// import UserService from '#services/user_service';\nimport { inject } from '@adonisjs/core'\n// import { Exception } from '@adonisjs/core/exceptions';\nimport { UserService } from '#services/user_service'\n\n/**\n * Controller class for handling User operations.\n */\n@inject()\nexport default class UserController {\n  constructor(protected userService: UserService) {}\n\n  /**\n   * Create a new User.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam data - The data for the new User.\n   */\n  public async create({ request, response }: HttpContext) {\n    const data = request.only(['email', 'password', 'fullname', 'role'])\n\n    try {\n      const user = await this.userService.createUser(data)\n      return response.status(201).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve a User by email.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   */\n  public async getByEmail({ params, response }: HttpContext) {\n    const { email } = params\n\n    try {\n      const user = await this.userService.getUserByEmail(email)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a User.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   * @bodyParam data - The data to update the User.\n   */\n  public async update({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only(['email', 'password', 'fullname', 'role'])\n\n    try {\n      const user = await this.userService.updateUser(email, data)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Delete a User by email (soft delete).\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   */\n  public async delete({ params, response }: HttpContext) {\n    const { email } = params\n\n    try {\n      const user = await this.userService.deleteUser(email)\n      return response.status(200).json({ message: 'User deleted successfully', user })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve all Users.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   */\n  public async getAll({ response }: HttpContext) {\n    try {\n      const users = await this.userService.getAllUsers()\n      return response.status(200).json(users)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Retrieve paginated Users.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @queryParam page - The page number for pagination.\n   * @queryParam limit - The number of items per page.\n   */\n  public async getPaginated({ request, response }: HttpContext) {\n    const page = request.input('page', 1)\n    const limit = request.input('limit', 10)\n\n    try {\n      const { users, total } = await this.userService.getPaginatedUsers(page, limit)\n      return response.status(200).json({ users, total })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Update a User's profile.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @paramParam email - The email of the User.\n   * @bodyParam data - The profile data to update.\n   */\n  public async updateProfile({ params, request, response }: HttpContext) {\n    const { email } = params\n    const data = request.only([\n      'fullname',\n      'businessName',\n      'businessAddress',\n      'businessPhone',\n      'businessEmail',\n    ])\n\n    try {\n      const user = await this.userService.updateUserProfile(email, data)\n      return response.status(200).json(user)\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n\n  /**\n   * Ban a user by email.\n   *\n   * @param {HttpContext} ctx - The HTTP context object.\n   * @bodyParam email - The email of the user to ban.\n   */\n  public async ban({ request, response }: HttpContext) {\n    const { email } = request.only(['email'])\n\n    try {\n      const user = await this.userService.banUser(email)\n      return response.status(200).json({ message: 'User banned successfully', user })\n    } catch (error) {\n      return response.status(error.status ?? 400).json({ message: error.message })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\handler.ts</source>
<document_content>import app from '@adonisjs/core/services/app'\nimport { HttpContext, ExceptionHandler } from '@adonisjs/core/http'\n\nexport default class HttpExceptionHandler extends ExceptionHandler {\n  /**\n   * In debug mode, the exception handler will display verbose errors\n   * with pretty printed stack traces.\n   */\n  protected debug = !app.inProduction\n\n  /**\n   * The method is used for handling errors and returning\n   * response to the client\n   */\n  async handle(error: unknown, ctx: HttpContext) {\n    return super.handle(error, ctx)\n  }\n\n  /**\n   * The method is used to report error to the logging service or\n   * the third party error monitoring service.\n   *\n   * @note You should not attempt to send a response from this method.\n   */\n  async report(error: unknown, ctx: HttpContext) {\n    return super.report(error, ctx)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\invalid_image_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class InvalidImageException extends Exception {\n  static status = 400\n  static code = 'E_INVALID_IMAGE'\n  static message = 'Invalid image format'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\invalid_session_id_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class InvalidSessionIdException extends Exception {\n  static status = 500\n  static code = 'E_INVALID_SESSION_ID'\n  static message = 'Invalid session ID'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\media_not_found_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class MediaNotFoundException extends Exception {\n  static status = 404\n  static code = 'E_MEDIA_NOT_FOUND'\n  static message = 'The requested media file was not found'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\un_authorized_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class UnAuthorizedException extends Exception {\n  static status = 401\n  static code = 'E_UNAUTHORIZED'\n  static message = 'Unauthorized access'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\exceptions\user_not_verified_exception.ts</source>
<document_content>import { Exception } from '@adonisjs/core/exceptions'\n\nexport default class UserNotVerifiedException extends Exception {\n  static status = 403\n  static code = 'E_USER_NOT_VERIFIED'\n  static message = 'The user account is not verified'\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\factories\user_factory.ts</source>
<document_content>import { hash } from '@node-rs/argon2'\nimport { PrismaTransactionalClient, prisma } from '#services/prisma_service'\nimport { generateIdFromEntropySize } from 'lucia'\nimport {\n  BankAccount,\n  Role,\n  SellerVerificationStatus,\n  User,\n  Profile,\n  SellerProfile,\n  Prisma,\n  PrismaClient,\n} from '@prisma/client'\nimport { z } from 'zod'\n//import logger from '@adonisjs/core/services/logger'\nimport { PrismaPromise } from '@prisma/client/runtime/library'\n//import { logger } from '#services/logger_service'\n\n// Zod schemas for input validation\nconst userSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8),\n  fullname: z.string().min(2),\n})\n\nconst sellerSchema = userSchema.extend({\n  businessName: z.string().optional(),\n  businessAddress: z.string().optional(),\n  businessPhone: z.string().optional(),\n  identityDoc: z.string().optional(),\n})\n\nconst bankAccountSchema = z.object({\n  accountHolderName: z.string().min(1),\n  accountNumber: z.string().min(1),\n  bankName: z.string().min(1),\n  swiftCode: z.string().min(1),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n})\n\ntype UserFactoryData = z.infer<typeof userSchema>\ntype SellerFactoryData = z.infer<typeof sellerSchema>\ntype BankAccountData = z.infer<typeof bankAccountSchema>\n\nexport class UserFactory {\n  /**\n   * Create a regular user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createUser(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.USER }, tx)\n    } catch (error) {\n      console.error('Error creating user', error)\n      throw new Error('Failed to create user')\n    }\n  }\n\n  /**\n   * Create a seller user with associated regular profile and seller profile\n   * @param {SellerFactoryData} data - Seller data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile, sellerProfile: SellerProfile}>} Created user, regular profile, and seller profile\n   */\n  static async createSeller(\n    data: SellerFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile; sellerProfile: SellerProfile }> {\n    try {\n      const validatedData = sellerSchema.parse(data)\n\n      const createSellerOperation = async (ptx: PrismaTransactionalClient) => {\n        const { user, profile } = await this.createBaseUser(\n          { ...validatedData, role: Role.SELLER },\n          ptx\n        )\n        const sellerProfile = await ptx.sellerProfile.create({\n          data: {\n            userId: user.id,\n            businessName: validatedData.businessName ?? '',\n            businessAddress: validatedData.businessAddress ?? '',\n            businessPhone: validatedData.businessPhone ?? '',\n            businessEmail: validatedData.email ?? '',\n            identityDoc: validatedData.identityDoc,\n            verificationStatus: SellerVerificationStatus.IDLE,\n          },\n        })\n        return { user, profile, sellerProfile }\n      }\n\n      return tx ? createSellerOperation(tx) : prisma.$transaction(createSellerOperation)\n    } catch (error) {\n      console.error('Error creating seller', error)\n      throw new Error('Failed to create seller')\n    }\n  }\n\n  /**\n   * Add a bank account to a seller profile\n   * @param {string} sellerId - ID of the seller\n   * @param {BankAccountData} bankAccountData - Bank account data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<BankAccount>} Created bank account\n   */\n  static async addBankAccount(\n    sellerId: string,\n    bankAccountData: BankAccountData,\n    tx?: PrismaTransactionalClient\n  ): Promise<BankAccount> {\n    try {\n      const validatedData = bankAccountSchema.parse(bankAccountData)\n\n      const addBankAccountOperation = async (ptx: PrismaTransactionalClient) => {\n        const sellerProfile = await ptx.sellerProfile.findUnique({ where: { userId: sellerId } })\n        if (!sellerProfile) {\n          throw new Error('Seller profile not found')\n        }\n        return ptx.bankAccount.create({\n          data: {\n            ...validatedData,\n            sellerProfileId: sellerProfile.id,\n          },\n        })\n      }\n\n      return tx ? addBankAccountOperation(tx) : prisma.$transaction(addBankAccountOperation)\n    } catch (error) {\n      console.error('Error adding bank account', error, sellerId)\n      throw new Error('Failed to add bank account')\n    }\n  }\n\n  /**\n   * Create a moderator user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createModerator(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.MODERATOR }, tx)\n    } catch (error) {\n      console.error('Error creating moderator', error)\n      throw new Error('Failed to create moderator')\n    }\n  }\n\n  /**\n   * Create an admin user\n   * @param {UserFactoryData} data - User data\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  static async createAdmin(\n    data: UserFactoryData,\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    try {\n      const validatedData = userSchema.parse(data)\n      return this.createBaseUser({ ...validatedData, role: Role.ADMIN }, tx)\n    } catch (error) {\n      console.error('Error creating admin', error)\n      throw new Error('Failed to create admin')\n    }\n  }\n\n  /**\n   * Private method to create a base user with a profile\n   * @param {UserFactoryData & { role: Role }} data - User data with role\n   * @param {PrismaTransactionalClient} [tx] - Optional transaction client\n   * @returns {Promise<{user: User, profile: Profile}>} Created user and profile\n   */\n  private static async createBaseUser(\n    data: UserFactoryData & { role: Role },\n    tx?: PrismaTransactionalClient\n  ): Promise<{ user: User; profile: Profile }> {\n    const createUserOperation = async (ptx: PrismaTransactionalClient) => {\n      const existingUser = await ptx.user.findUnique({\n        where: { email: data.email },\n      })\n\n      if (existingUser) {\n        throw new Error(`User with email ${data.email} already exists`)\n      }\n\n      const passwordHash = await this.hashPassword(data.password)\n      const id = generateIdFromEntropySize(32)\n\n      const user = await ptx.user.create({\n        data: { id, email: data.email, passwordHash, role: data.role },\n      })\n      const profile = await ptx.profile.create({\n        data: { userId: id, name: data.fullname },\n      })\n\n      return { user, profile }\n    }\n\n    return tx ? createUserOperation(tx) : prisma.$transaction(createUserOperation)\n  }\n\n  /**\n   * Private method to hash a password\n   * @param {string} password - Plain text password\n   * @returns {Promise<string>} Hashed password\n   */\n  private static async hashPassword(password: string): Promise<string> {\n    return hash(password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\handlers\repo.ts</source>
<document_content>import CodeCheckService from \"#services/code_check_service\"\nimport { CodeRepo, CodeRepoStatus, Language } from \"@prisma/client\"\n\nexport interface RepoCheckContext {\n  repo: CodeRepo\n  userId: string\n  codeCheckResult?: Awaited<ReturnType<CodeCheckService['performCodeCheck']>>\n}\n\nexport abstract class RepoCheckHandler {\n  protected next: RepoCheckHandler | null = null\n\n  setNext(handler: RepoCheckHandler): RepoCheckHandler {\n    this.next = handler\n    return handler\n  }\n\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (this.next) {\n      return this.next.handle(context)\n    }\n  }\n}\n\n// Handler implementations\nexport class RepoExistenceHandler extends RepoCheckHandler {\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (!context.repo) {\n      throw new Error('Repo not found')\n    }\n    return super.handle(context)\n  }\n}\n\nexport class UserAuthorizationHandler extends RepoCheckHandler {\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (context.repo.userId !== context.userId) {\n      throw new Error('User is not authorized to perform this action on the repo')\n    }\n    return super.handle(context)\n  }\n}\n\nexport class RepoStatusHandler extends RepoCheckHandler {\n  constructor(private expectedStatus: CodeRepoStatus) {\n    super()\n  }\n\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (context.repo.status === this.expectedStatus) {\n      throw new Error(`Repo is already ${this.expectedStatus}`)\n    }\n    return super.handle(context)\n  }\n}\n\nexport class RepoContentHandler extends RepoCheckHandler {\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (!context.repo.sourceJs || !context.repo.sourceCss) {\n      throw new Error('Repo must have both JavaScript and CSS content')\n    }\n    return super.handle(context)\n  }\n}\n\nexport class CodeCheckHandler extends RepoCheckHandler {\n  constructor(private codeCheckService: CodeCheckService) {\n    super()\n  }\n\n  async handle(context: RepoCheckContext): Promise<void> {\n    context.codeCheckResult = await this.codeCheckService.performCodeCheck(\n      context.repo.sourceJs!,\n      context.repo.language as Language\n    )\n    return super.handle(context)\n  }\n}\n\nexport class CodeQualityHandler extends RepoCheckHandler {\n  async handle(context: RepoCheckContext): Promise<void> {\n    if (!context.codeCheckResult) {\n      throw new Error('Code check result not available')\n    }\n\n    const minAcceptableScore = 0\n    if (\n      context.codeCheckResult.securityScore < minAcceptableScore ||\n      context.codeCheckResult.maintainabilityScore < minAcceptableScore ||\n      context.codeCheckResult.readabilityScore < minAcceptableScore ||\n      context.codeCheckResult.eslintErrorCount > 10 ||\n      context.codeCheckResult.eslintFatalErrorCount > 0\n    ) {\n      throw new Error('Code quality does not meet the required standards')\n    }\n    return super.handle(context)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\document_reader.ts</source>
<document_content>// import { TextLoader } from \"langchain/document_loaders/fs/text\";\n// import { PDFLoader } from \"langchain/document_loaders/fs/pdf\";\nimport { PDFLoader } from '@langchain/community/document_loaders/fs/pdf'\n\nconst doc = 'code-guideline.pdf'\nconst loader = new PDFLoader(`./public/assets/${doc}`, {\n  splitPages: false,\n})\n\nexport const pdfDocReader = await loader.load()\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\openai.ts</source>
<document_content>import { ChatOpenAI } from '@langchain/openai'\nimport env from '#start/env'\n\nexport const openaiModel = new ChatOpenAI({\n  apiKey: env.get('OPENAI_API_KEY'),\n  model: 'gpt-4o-mini',\n  temperature: 0.3,\n  maxTokens: 1000,\n  topP: 0.9,\n  frequencyPenalty: 0.2,\n  presencePenalty: 0.2,\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\langchain\text_splitters.ts</source>
<document_content>import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter'\nimport { Document } from 'langchain/document'\n\nconst recursiveSplitter = new RecursiveCharacterTextSplitter({\n  chunkSize: 10,\n  chunkOverlap: 1,\n})\n\nexport const recursiveSplitterOutput = async (text: any) => {\n  return await recursiveSplitter.splitDocuments([new Document({ pageContent: text })])\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\rabbitmq\rabbitmq_service.ts</source>
<document_content>//import { inject } from '@adonisjs/core'\nimport amqp, { Connection, Channel, ConsumeMessage } from 'amqplib'\nimport env from '#start/env'\n\n//@inject()\nexport default class RabbitMQService {\n  private connection: Connection | null = null\n  private channel: Channel | null = null\n\n  constructor() {}\n\n  /**\n   * Initialize the RabbitMQ connection and channel\n   */\n  public async init() {\n    try {\n      this.connection = await amqp.connect(env.get('RABBITMQ_URL'))\n      this.channel = await this.connection.createChannel()\n      console.log('Connected to RabbitMQ')\n    } catch (error) {\n      console.error('Failed to connect to RabbitMQ:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Publish a message to a queue\n   * @param {string} queue - The name of the queue\n   * @param {object} message - The message to publish\n   */\n  public async publishMessage(queue: string, message: object) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    await this.channel.assertQueue(queue, { durable: true })\n    this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(message)), { persistent: true })\n  }\n\n  /**\n   * Consume messages from a queue\n   * @param {string} queue - The name of the queue\n   * @param {function} callback - The callback function to process messages\n   */\n  public async consume(queue: string, callback: (msg: ConsumeMessage | null) => void) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    await this.channel.assertQueue(queue, { durable: true })\n    await this.channel.consume(queue, callback, { noAck: false })\n  }\n\n  /**\n   * Acknowledge a message\n   * @param {ConsumeMessage} message - The message to acknowledge\n   */\n  public ack(message: ConsumeMessage) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    this.channel.ack(message)\n  }\n\n  /**\n   * Negatively acknowledge a message (requeue)\n   * @param {ConsumeMessage} message - The message to negatively acknowledge\n   */\n  public nack(message: ConsumeMessage) {\n    if (!this.channel) {\n      throw new Error('RabbitMQ channel not initialized')\n    }\n\n    this.channel.nack(message, false, true)\n  }\n\n  /**\n   * Close the RabbitMQ connection\n   */\n  public async close() {\n    if (this.channel) {\n      await this.channel.close()\n    }\n    if (this.connection) {\n      await this.connection.close()\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\rabbitmq\rabbitmq.ts</source>
<document_content>//import { inject } from '@adonisjs/core'\nimport amqp, { Connection, Channel, ConsumeMessage } from 'amqplib'\nimport env from '#start/env'\n\n//@inject()\nexport default class RabbitMQService {\n  private connection: Connection | null = null\n  private channel: Channel | null = null\n\n  constructor() {}\n\n  /**\n   * Initialize the RabbitMQ connection and channel\n   */\n  public async init() {\n    try {\n      this.connection = await amqp.connect(env.get('RABBITMQ_URL'))\n      this.channel = await this.connection.createChannel()\n      console.log('Connected to RabbitMQ')\n    } catch (error) {\n      console.error('Failed to connect to RabbitMQ:', error)\n      throw error\n    }\n  }\n\n  // ... (rest of the methods remain the same)\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\s3\s3_facade.ts</source>
<document_content>import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3'\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner'\nimport { randomUUID } from 'crypto'\nimport env from '#start/env'\n\nexport class S3Facade {\n  private s3Client: S3Client\n  private bucketName: string\n\n  constructor() {\n    this.s3Client = new S3Client({\n      region: env.get('AWS_REGION'),\n      credentials: {\n        accessKeyId: env.get('AWS_ACCESS_KEY_ID')!,\n        secretAccessKey: env.get('AWS_SECRET_ACCESS_KEY')!,\n        sessionToken: env.get('AWS_SESSION_TOKEN'),\n      },\n    })\n    this.bucketName = env.get('AWS_S3_BUCKET_NAME')!\n  }\n\n  /**\n   * @uploadFile\n   * @description Uploads a file to S3 and creates a Media record in the database.\n   * @param file The file to upload\n   * @param fileType The MIME type of the file\n   * @param tx The Prisma transaction object\n   * @returns The created Media object\n   */\n  async uploadFile(\n    file: Buffer,\n    fileType: string,\n    tx: any,\n    path?: string\n  ): Promise<{ media: any; signedUrl: string }> {\n    const fileKey = `${randomUUID()}-${Date.now()}`\n    const putObjectCommand = new PutObjectCommand({\n      Bucket: this.bucketName,\n      Key: `${path ? path + '/' : ''}${fileKey}`,\n      Body: file,\n      ContentType: fileType,\n    })\n\n    await this.s3Client.send(putObjectCommand)\n\n    const signedUrl = await getSignedUrl(this.s3Client, putObjectCommand, {\n      expiresIn: 3600,\n    })\n\n    const media = await tx.media.create({\n      data: {\n        url: `https://${this.bucketName}.s3.amazonaws.com/${path ? path + '/' : ''}${fileKey}`,\n        type: fileType,\n      },\n    })\n\n    return { media, signedUrl }\n  }\n\n  /**\n   * @getSignedUrl\n   * @description Generates a signed URL for accessing a file in S3.\n   * @param fileKey The key of the file in S3\n   * @returns The signed URL\n   */\n  async getSignedUrl(fileKey: string): Promise<string> {\n    const getObjectCommand = new PutObjectCommand({\n      Bucket: this.bucketName,\n      Key: fileKey,\n    })\n\n    return getSignedUrl(this.s3Client, getObjectCommand, { expiresIn: 3600 })\n  }\n}\n\nexport const s3Facade = new S3Facade()\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\integrations\stripe\stripe_facade.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport Stripe from 'stripe'\nimport env from '#start/env'\nimport { Exception } from '@adonisjs/core/exceptions'\n\n@inject()\nexport default class StripeFacade {\n  private stripe: Stripe\n\n  constructor() {\n    this.stripe = new Stripe(env.get('STRIPE_SECRET_KEY'), {\n      apiVersion: '2024-04-10', // Use the latest API version\n    })\n  }\n\n  /**\n   * Create a payment intent for a purchase\n   * @param amount The amount to charge (in cents)\n   * @param currency The currency to use (e.g., 'usd')\n   * @param customerId The Stripe Customer ID\n   * @param accountId The Stripe Connect account ID to receive the funds\n   * @returns The PaymentIntent object\n   */\n  async createPaymentIntent(amount: number, currency: string): Promise<Stripe.PaymentIntent> {\n    try {\n      const paymentIntent = await this.stripe.paymentIntents.create({\n        amount,\n        currency,\n      })\n      return paymentIntent\n    } catch (error) {\n      console.error('Stripe payment intent creation error:', error)\n      throw new Exception('Failed to create payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CREATION',\n        status: 500,\n      })\n    }\n  }\n\n  async createPaymentIntentForRepo(\n    amount: number,\n    currency: string,\n    sellerId: string,\n    repoId: string\n  ) {\n    try {\n      const paymentIntent = await this.createPaymentIntent(amount, currency)\n\n      // Update the payment intent with metadata\n      const updatedPaymentIntent = await this.stripe.paymentIntents.update(paymentIntent.id, {\n        metadata: { repoId, sellerId },\n      })\n\n      return updatedPaymentIntent\n    } catch (error) {\n      console.error('Error creating payment intent for repo:', error)\n      throw new Exception('Failed to create payment intent for repo', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CREATION',\n        status: 500,\n      })\n    }\n  }\n\n  async retrievePaymentIntent(paymentIntentId: string) {\n    try {\n      return await this.stripe.paymentIntents.retrieve(paymentIntentId)\n    } catch (error) {\n      console.error('Error retrieving payment intent:', error)\n      throw new Exception('Failed to retrieve payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_RETRIEVAL',\n        status: 500,\n      })\n    }\n  }\n\n  async confirmPaymentIntent(paymentIntentId: string) {\n    try {\n      return await this.stripe.paymentIntents.confirm(paymentIntentId)\n    } catch (error) {\n      console.error('Error confirming payment intent:', error)\n      throw new Exception('Failed to confirm payment intent', {\n        code: 'E_STRIPE_PAYMENT_INTENT_CONFIRMATION',\n        status: 500,\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\auth_guard_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n//import lucia from '#services/lucia_service';\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { Role } from '@prisma/client'\nimport UserNotVerifiedException from '#exceptions/user_not_verified_exception'\n\nexport default class AuthGuardMiddleware {\n  async handle(ctx: HttpContext, next: NextFn, options: { role: Role }) {\n    const user = ctx.request.user\n    if (!user) {\n      throw new UnAuthorizedException('User not authenticated')\n    }\n\n    const userRole = user.role\n    const requiredRole = options.role\n\n    if (!this.hasAccess(userRole, requiredRole)) {\n      throw new UnAuthorizedException('Insufficient permissions')\n    }\n\n    if (!user.emailVerified) {\n      throw new UserNotVerifiedException()\n    }\n\n    if (user?.bannedUntil && user?.bannedUntil > new Date()) {\n      throw new UnAuthorizedException('User is banned')\n    }\n\n    if (user?.deletedAt) {\n      throw new UnAuthorizedException('User account is deleted')\n    }\n\n    // If the user has the required role or higher, allow access\n    await next()\n  }\n\n  private hasAccess(userRole: Role, requiredRole: Role): boolean {\n    const roleHierarchy = {\n      [Role.USER]: 1,\n      [Role.SELLER]: 2,\n      [Role.MODERATOR]: 3,\n      [Role.ADMIN]: 4,\n    }\n\n    return roleHierarchy[userRole] >= roleHierarchy[requiredRole]\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\check_database_connection_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\nimport { prisma } from '#services/prisma_service'\n\nexport default class CheckDatabaseConnection  {\n  async handle(ctx: HttpContext, next: NextFn) {\n    try {\n      await prisma.$connect()\n      await next()\n    }\n    catch (e) {\n      ctx.response.abort({\n        message: \"Unable to connect to database\"\n      })\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\container_bindings_middleware.ts</source>
<document_content>import { Logger } from '@adonisjs/core/logger'\nimport { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\n/**\n * The container bindings middleware binds classes to their request\n * specific value using the container resolver.\n *\n * - We bind \"HttpContext\" class to the \"ctx\" object\n * - And bind \"Logger\" class to the \"ctx.logger\" object\n */\nexport default class ContainerBindingsMiddleware {\n  handle(ctx: HttpContext, next: NextFn) {\n    ctx.containerResolver.bindValue(HttpContext, ctx)\n    ctx.containerResolver.bindValue(Logger, ctx.logger)\n\n    return next()\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\force_json_response_middleware.ts</source>
<document_content>import type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\n/**\n * Updating the \"Accept\" header to always accept \"application/json\" response\n * from the server. This will force the internals of the framework like\n * validator errors or auth errors to return a JSON response.\n */\nexport default class ForceJsonResponseMiddleware {\n  async handle({ request }: HttpContext, next: NextFn) {\n    const headers = request.headers()\n    headers.accept = 'application/json'\n\n    return next()\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\middleware\get_user_session_middleware.ts</source>
<document_content>import UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport lucia from '#services/lucia_service'\nimport type { HttpContext } from '@adonisjs/core/http'\nimport type { NextFn } from '@adonisjs/core/types/http'\n\nexport default class GetUserSessionMiddleware {\n  async handle(ctx: HttpContext, next: NextFn) {\n    /**\n     * Middleware logic goes here (before the next call)\n     */\n    const sessionId = lucia.readSessionCookie(ctx.request.headers().cookie ?? '')\n    if (!sessionId) {\n      //console.log('no session')\n      ctx.request.user = null\n      ctx.request.session = null\n      const output = await next()\n      return output\n    } else {\n      const { session, user } = await lucia.validateSession(sessionId)\n      if (session && session.fresh) {\n        ctx.response.header('Set-Cookie', lucia.createSessionCookie(session.id).serialize())\n      }\n\n      if (!session) {\n        ctx.response.header('Set-Cookie', lucia.createBlankSessionCookie().serialize())\n      }\n\n      if (session && session.fresh) {\n        ctx.response.header('Set-Cookie', lucia.createSessionCookie(session.id).serialize())\n      }\n\n      // if there is no user found but a role prop exist\n      //if (!user) {\n      //  console.log('no user')\n      //  throw new UnAuthorizedException()\n      //}\n\n      ctx.request.user = user\n      ctx.request.session = session\n\n      /**\n       * Call next method in the pipeline and return its output\n       */\n      await next()\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\admin_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport SalesService from '#services/sales_service'\nimport { CodeRepoStatus, OrderStatus, Role, SupportTicketStatus, UserCommentFlag, Language, SellerVerificationStatus } from '@prisma/client'\nimport SupportTicketService from './support_service.js'\nimport logger from '@adonisjs/core/services/logger'\nimport { Prisma } from '@prisma/client'\nimport { z } from 'zod'\n\nconst languageEnum = z.enum(['JSX', 'TSX', 'Unknown']);\n\nconst topSellingRepoSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  language: languageEnum,\n  totalRevenue: z.number()\n});\n\nconst financialInsightsSchema = z.object({\n  currentMonthRevenue: z.number(),\n  previousMonthRevenue: z.number(),\n  revenueGrowth: z.number(),\n  pendingPayouts: z.number(),\n  processedPayouts: z.number(),\n  topSellingRepos: z.array(topSellingRepoSchema),\n  revenueByLanguage: z.record(languageEnum, z.number())\n});\n\ntype SalesAggregateItem = {\n  id: string\n  sellerId: string\n  date: Date\n  revenue: number\n  salesCount: number\n}\n\ntype DashboardData = {\n  salesOverview: {\n    totalRevenue: number\n    totalSales: number\n    averageOrderValue: number\n    dailySales: { revenue: number; salesCount: number }\n    weeklySales: { revenue: number; salesCount: number }\n    monthlySales: { revenue: number; salesCount: number }\n  }\n  userStatistics: {\n    totalUsers: number\n    userTypeCounts: Record<Role, number>\n    newUsers: number\n  }\n  repoMetrics: {\n    totalRepos: number\n    pendingApprovalRepos: number\n    popularRepos: { id: string; name: string; _count: { orders: number } }[]\n    recentRepos: { id: string; name: string; createdAt: Date }[]\n  }\n  sellerPerformance: {\n    topSellers: {\n      id: string\n      email: string\n      sellerProfile: { verificationStatus: SellerVerificationStatus; balance: number } | null\n      profile: { name: string | null } | null\n      _count: { orders: number }\n    }[]\n    newSellerApplications: number\n  }\n  orderManagement: {\n    recentOrders: {\n      id: string\n      userId: string\n      codeRepoId: string\n      createdAt: Date\n      updatedAt: Date\n      deletedAt: Date | null\n      status: OrderStatus\n      totalAmount: number\n      stripePaymentIntentId: string | null\n      stripePaymentMethodId: string | null\n      payoutRequestId: string | null\n      user: { email: string }\n      codeRepo: { name: string }\n    }[]\n    orderStatusCounts: Record<OrderStatus, number>\n  }\n  financialInsights: {\n    currentMonthRevenue: number\n    previousMonthRevenue: number\n    revenueGrowth: number\n    pendingPayouts: number\n    processedPayouts: number\n    topSellingRepos: { id: string; name: string; language: Language; totalRevenue: number }[]\n  }\n  supportTickets: {\n    openTicketsCount: number\n    averageResponseTime: number | null\n    ticketStatusCounts: Record<SupportTicketStatus, number>\n  }\n  contentModeration: {\n    flaggedReviews: number\n    flaggedComments: number\n    totalFlaggedContent: number\n  }\n}\n\n@inject()\nexport default class AdminDashboardService {\n  constructor(\n    private salesService: SalesService,\n    private supportTicketService: SupportTicketService\n  ) {}\n\n  public async getDashboardData(): Promise<DashboardData> {\n    try {\n      const now = DateTime.now()\n      const startOfDay = now.startOf('day').toJSDate()\n      const startOfWeek = now.startOf('week').toJSDate()\n      const startOfMonth = now.startOf('month').toJSDate()\n\n      const [\n        salesOverview,\n        userStatistics,\n        repoMetrics,\n        sellerPerformance,\n        orderManagement,\n        financialInsights,\n        supportTickets,\n        contentModeration\n      ] = await Promise.all([\n        this.getSalesOverview(startOfDay, startOfWeek, startOfMonth),\n        this.getUserStatistics(),\n        this.getRepoMetrics(),\n        this.getSellerPerformance(),\n        this.getOrderManagement(),\n        this.getFinancialInsights(),\n        this.getSupportTickets(),\n        this.getContentModeration()\n      ])\n\n      return {\n        salesOverview,\n        userStatistics,\n        repoMetrics,\n        sellerPerformance,\n        orderManagement,\n        financialInsights,\n        supportTickets,\n        contentModeration\n      }\n    } catch (error) {\n      logger.error('Error in getDashboardData:', error)\n      throw new Error('Failed to retrieve dashboard data')\n    }\n  }\n\n  private async getSalesOverview(startOfDay: Date, startOfWeek: Date, startOfMonth: Date) {\n    try {\n      const [sellers, totalRevenue, totalSales] = await Promise.all([\n        prisma.user.findMany({\n          where: { role: Role.SELLER },\n          select: { id: true }\n        }),\n        prisma.order.aggregate({\n          _sum: { totalAmount: true },\n          where: { status: OrderStatus.SUCCEEDED }\n        }),\n        prisma.order.count({ where: { status: OrderStatus.SUCCEEDED } })\n      ])\n\n      const now = new Date()\n\n      const salesPromises = sellers.flatMap(seller => [\n        this.salesService.getSalesAggregate(seller.id, startOfDay, now),\n        this.salesService.getSalesAggregate(seller.id, startOfWeek, now),\n        this.salesService.getSalesAggregate(seller.id, startOfMonth, now)\n      ])\n\n      const allSalesData = await Promise.all(salesPromises)\n\n      const [dailySales, weeklySales, monthlySales] = [\n        allSalesData.filter((_, index) => index % 3 === 0),\n        allSalesData.filter((_, index) => index % 3 === 1),\n        allSalesData.filter((_, index) => index % 3 === 2)\n      ]\n\n      const aggregateSales = (sales: SalesAggregateItem[][]) => {\n        return sales.reduce((acc, sellerSales) => {\n          const totalRevenue = sellerSales.reduce((sum, sale) => sum + sale.revenue, 0)\n          const totalSalesCount = sellerSales.reduce((sum, sale) => sum + sale.salesCount, 0)\n          return {\n            revenue: acc.revenue + totalRevenue,\n            salesCount: acc.salesCount + totalSalesCount\n          }\n        }, { revenue: 0, salesCount: 0 })\n      }\n\n      return {\n        totalRevenue: totalRevenue._sum.totalAmount ?? 0,\n        totalSales,\n        averageOrderValue: totalSales > 0 ? (totalRevenue._sum.totalAmount ?? 0) / totalSales : 0,\n        dailySales: aggregateSales(dailySales),\n        weeklySales: aggregateSales(weeklySales),\n        monthlySales: aggregateSales(monthlySales)\n      }\n    } catch (error) {\n      logger.error('Error in getSalesOverview:', error)\n      throw new Error('Failed to retrieve sales overview')\n    }\n  }\n\n  private async getUserStatistics() {\n    try {\n      const [totalUsers, userTypeCounts, newUsers] = await Promise.all([\n        prisma.user.count(),\n        prisma.user.groupBy({\n          by: ['role'],\n          _count: true\n        }),\n        prisma.user.count({\n          where: {\n            createdAt: {\n              gte: DateTime.now().minus({ days: 30 }).toJSDate()\n            }\n          }\n        })\n      ])\n\n      return {\n        totalUsers,\n        userTypeCounts: userTypeCounts.reduce((acc, { role, _count }) => {\n          acc[role as Role] = _count\n          return acc\n        }, {} as Record<Role, number>),\n        newUsers\n      }\n    } catch (error) {\n      logger.error('Error in getUserStatistics:', error)\n      throw new Error('Failed to retrieve user statistics')\n    }\n  }\n\n  private async getRepoMetrics() {\n    try {\n      const [totalRepos, pendingApprovalRepos, popularRepos, recentRepos] = await Promise.all([\n        prisma.codeRepo.count(),\n        prisma.codeRepo.count({\n          where: { status: CodeRepoStatus.pending }\n        }),\n        prisma.codeRepo.findMany({\n          take: 5,\n          orderBy: { orders: { _count: 'desc' } },\n          select: { id: true, name: true, _count: { select: { orders: true } } }\n        }),\n        prisma.codeRepo.findMany({\n          take: 5,\n          orderBy: { createdAt: 'desc' },\n          select: { id: true, name: true, createdAt: true }\n        })\n      ])\n\n      return {\n        totalRepos,\n        pendingApprovalRepos,\n        popularRepos,\n        recentRepos\n      }\n    } catch (error) {\n      logger.error('Error in getRepoMetrics:', error)\n      throw new Error('Failed to retrieve repo metrics')\n    }\n  }\n\n  private async getSellerPerformance() {\n    try {\n      const [topSellers, newSellerApplications] = await Promise.all([\n        prisma.user.findMany({\n          where: { role: Role.SELLER },\n          take: 5,\n          orderBy: { orders: { _count: 'desc' } },\n          select: {\n            id: true,\n            email: true,\n            profile: { select: { name: true } },\n            _count: { select: { orders: true } },\n            sellerProfile: {\n              select: {\n                balance: true,\n                verificationStatus: true\n              }\n            }\n          }\n        }),\n        prisma.sellerProfile.count({\n          where: { verificationStatus: 'PENDING' }\n        })\n      ])\n\n      return {\n        topSellers,\n        newSellerApplications\n      }\n    } catch (error) {\n      logger.error('Error in getSellerPerformance:', error)\n      throw new Error('Failed to retrieve seller performance data')\n    }\n  }\n\n  private async getOrderManagement() {\n    try {\n      const [recentOrders, orderStatusCounts] = await Promise.all([\n        prisma.order.findMany({\n          take: 10,\n          orderBy: { createdAt: 'desc' },\n          include: {\n            user: { select: { email: true } },\n            codeRepo: { select: { name: true } }\n          }\n        }),\n        prisma.order.groupBy({\n          by: ['status'],\n          _count: true\n        })\n      ])\n\n      return {\n        recentOrders,\n        orderStatusCounts: orderStatusCounts.reduce((acc, { status, _count }) => {\n          acc[status as OrderStatus] = _count\n          return acc\n        }, {} as Record<OrderStatus, number>)\n      }\n    } catch (error) {\n      logger.error('Error in getOrderManagement:', error)\n      throw new Error('Failed to retrieve order management data')\n    }\n  }\n\n  private async getFinancialInsights() {\n    try {\n      const now = DateTime.now()\n      const startOfMonth = now.startOf('month').toJSDate()\n      const startOfPreviousMonth = now.minus({ months: 1 }).startOf('month').toJSDate()\n\n      const [\n        currentMonthRevenue,\n        previousMonthRevenue,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      ] = await Promise.all([\n        this.getMonthlyRevenue(startOfMonth),\n        this.getMonthlyRevenue(startOfPreviousMonth, startOfMonth),\n        this.getPendingPayouts(),\n        this.getProcessedPayouts(),\n        this.getTopSellingRepos(),\n      ])\n\n      const revenueGrowth = this.calculateRevenueGrowth(currentMonthRevenue, previousMonthRevenue)\n\n      logger.info('Financial Insights:', {\n        currentMonthRevenue,\n        previousMonthRevenue,\n        revenueGrowth,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      })\n\n      return {\n        currentMonthRevenue,\n        previousMonthRevenue,\n        revenueGrowth,\n        pendingPayouts,\n        processedPayouts,\n        topSellingRepos,\n      }\n    } catch (error) {\n      logger.error('Error in getFinancialInsights:', error)\n      return {\n        currentMonthRevenue: 0,\n        previousMonthRevenue: 0,\n        revenueGrowth: 0,\n        pendingPayouts: 0,\n        processedPayouts: 0,\n        topSellingRepos: [],\n        revenueByLanguage: {}\n      }\n    }\n  }\n\n  private async getMonthlyRevenue(startDate: Date, endDate: Date = new Date()) {\n    const result = await prisma.order.aggregate({\n      _sum: { totalAmount: true },\n      where: {\n        status: OrderStatus.SUCCEEDED,\n        createdAt: {\n          gte: startDate,\n          lt: endDate\n        }\n      }\n    })\n    return result._sum.totalAmount ?? 0\n  }\n\n  private calculateRevenueGrowth(currentRevenue: number, previousRevenue: number) {\n    if (previousRevenue === 0) return currentRevenue > 0 ? 100 : 0\n    return ((currentRevenue - previousRevenue) / previousRevenue) * 100\n  }\n\n  private async getPendingPayouts() {\n    return prisma.payoutRequest.aggregate({\n      _sum: { totalAmount: true },\n      where: { status: 'PENDING' }\n    }).then(result => result._sum.totalAmount ?? 0)\n  }\n\n  private async getProcessedPayouts() {\n    return prisma.payout.aggregate({\n      _sum: { totalAmount: true }\n    }).then(result => result._sum.totalAmount ?? 0)\n  }\n\n  private async getTopSellingRepos(limit: number = 5) {\n    const repos = await prisma.codeRepo.findMany({\n      take: limit,\n      select: {\n        id: true,\n        name: true,\n        language: true,\n        orders: {\n          where: { status: OrderStatus.SUCCEEDED },\n          select: { totalAmount: true }\n        }\n      },\n      orderBy: {\n        orders: {\n          _count: 'desc'\n        }\n      }\n    })\n\n    return repos.map(repo => ({\n      id: repo.id,\n      name: repo.name,\n      language: repo.language,\n      totalRevenue: repo.orders.reduce((sum, order) => sum + order.totalAmount, 0)\n    }))\n  }\n\n  private async getRevenueByLanguage() {\n    const revenueByRepo = await prisma.order.groupBy({\n      by: ['codeRepoId'],\n      _sum: { totalAmount: true },\n      where: { status: OrderStatus.SUCCEEDED }\n    })\n\n    const repoLanguages = await prisma.codeRepo.findMany({\n      where: { id: { in: revenueByRepo.map(r => r.codeRepoId) } },\n      select: { id: true, language: true }\n    })\n\n    const languageMap = new Map(repoLanguages.map(r => [r.id, r.language]))\n\n    return revenueByRepo.reduce((acc, { codeRepoId, _sum }) => {\n      const language = languageMap.get(codeRepoId) ?? 'Unknown'\n      acc[language] = (acc[language] ?? 0) + (_sum.totalAmount ?? 0)\n      return acc\n    }, {} as Record<Language | 'Unknown', number>)\n  }\n\n  private async getSupportTickets() {\n    try {\n      const [openTickets, ticketStatusCounts, completedTickets] = await Promise.all([\n        this.supportTicketService.getTicketsByStatus(SupportTicketStatus.todo),\n        prisma.supportTicket.groupBy({\n          by: ['status'],\n          _count: true\n        }),\n        prisma.supportTicket.findMany({\n          where: {\n            status: {\n              in: [SupportTicketStatus.inProgress, SupportTicketStatus.done]\n            }\n          },\n          select: {\n            createdAt: true,\n            updatedAt: true\n          }\n        })\n      ])\n\n      const totalResponseTime = completedTickets.reduce((total, ticket) => {\n        return total + ticket.updatedAt.getTime() - ticket.createdAt.getTime()\n      }, 0)\n\n      const averageResponseTime = completedTickets.length > 0\n        ? totalResponseTime / completedTickets.length / (1000 * 60 * 60) // Convert to hours\n        : null\n\n      return {\n        openTicketsCount: openTickets.length,\n        averageResponseTime,\n        ticketStatusCounts: ticketStatusCounts.reduce((acc, { status, _count }) => {\n          acc[status as SupportTicketStatus] = _count\n          return acc\n        }, {} as Record<SupportTicketStatus, number>)\n      }\n    } catch (error) {\n      logger.error('Error in getSupportTickets:', error)\n      throw new Error('Failed to retrieve support ticket data')\n    }\n  }\n\n  private async getContentModeration() {\n    try {\n      const [flaggedReviews, flaggedComments] = await Promise.all([\n        prisma.review.count({\n          where: { flag: { not: UserCommentFlag.NONE } }\n        }),\n        prisma.comment.count({\n          where: { flag: { not: UserCommentFlag.NONE } }\n        })\n      ])\n\n      return {\n        flaggedReviews,\n        flaggedComments,\n        totalFlaggedContent: flaggedReviews + flaggedComments\n      }\n    } catch (error) {\n      logger.error('Error in getContentModeration:', error)\n      throw new Error('Failed to retrieve content moderation data')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\auth_service.ts</source>
<document_content>import { createDate, TimeSpan, isWithinExpirationDate } from 'oslo'\nimport { verify } from '@node-rs/argon2'\nimport { hash } from '@node-rs/argon2'\nimport { Cookie, User, generateIdFromEntropySize } from 'lucia'\nimport { encodeHex } from 'oslo/encoding'\nimport { sha256 } from 'oslo/crypto'\nimport UserVerificationService from '#services/user_verification_service'\nimport lucia from '#services/lucia_service'\nimport { prisma } from '#services/prisma_service'\n// import { User } from \"lucia\";\n// import { AuthValidator, ZodLoginAuthStrategy, PrismaEmailExistsAuthStrategy, ZodRegistrationAuthStrategy, PrismaEmailUniqueAuthStrategy } from \"#validators/auth\";\nimport { inject } from '@adonisjs/core'\nimport mailConfig from '#config/mail'\nimport { Exception } from '@adonisjs/core/exceptions'\nimport logger from '@adonisjs/core/services/logger'\nimport UnAuthorizedException from '#exceptions/un_authorized_exception'\nimport { UserFactory } from '#factories/user_factory'\nimport { registrationSchema } from '#validators/auth'\nimport { z } from 'zod'\n\n@inject()\nexport default class AuthService {\n  constructor(private userVerificationService: UserVerificationService) {}\n\n  /**\n   * Handles logging in a user with the given email and password.\n   *\n   * @param {string} email - The user's email.\n   * @param {string} password - The user's password.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handleLogin(email: string, password: string): Promise<Response | Cookie> {\n    const user = await prisma.user.findUnique({ where: { email } })\n\n    if (!user) {\n      // return new Response(\"Invalid email or password\", { status: 400 });\n      throw new Exception('Invalid email or password')\n    }\n\n    const validPassword = await verify(user.passwordHash, password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n\n    if (!validPassword) {\n      throw new Exception('Invalid credentials', { status: 400 })\n    }\n\n    const session = await lucia.createSession(user.id.toString(), {})\n    const sessionCookie = lucia.createSessionCookie(session.id.toString())\n    return sessionCookie\n  }\n\n  /**\n   * Handles registering a new user with the given email, password, and full name.\n   *\n   * @param {string} email - The user's email.\n   * @param {string} password - The user's password.\n   * @param {string} fullname - The user's full name.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  /**\n   * Handles registering a new user with the given data.\n   *\n   * @param {z.infer<typeof registrationFormSchema>} data - The registration data.\n   * @returns {Promise<{ user: User, sessionCookie: string }>} - The created user and session cookie.\n   */\n  public async handleRegistration(data: z.infer<typeof registrationSchema>): Promise<{ user: User; sessionCookie: string }> {\n    try {\n      let result;\n      if (data.userType === 'seller') {\n        result = await UserFactory.createSeller({\n          email: data.email,\n          password: data.password,\n          fullname: data.fullname,\n        })\n      } else {\n        result = await UserFactory.createUser({\n          email: data.email,\n          password: data.password,\n          fullname: data.fullname\n        })\n      }\n\n      const { user } = result;\n      const session = await lucia.createSession(user.id, {})\n      const sessionCookie = lucia.createSessionCookie(session.id)\n      const token = sessionCookie.serialize()\n      logger.info(token)\n\n      const code = await this.userVerificationService.generateEmailVerificationCode(user.id, user.email)\n      await this.userVerificationService.sendVerificationCode(user.email, code, token)\n\n      return { user, sessionCookie: token }\n    } catch (e) {\n      logger.error('Failed to register user: ', e)\n      throw new Exception('Failed to register user')\n    }\n  }\n\n  /**\n   * Handles logging out a user by invalidating their session.\n   *\n   * @param {string} sessionId - The session ID to invalidate.\n   * @returns {Promise<void>}\n   */\n  public async handleLogout(sessionId: string): Promise<void> {\n    return await lucia.invalidateSession(sessionId)\n  }\n\n  /**\n   * Handles verifying a user's email with a verification code.\n   *\n   * @param {string} sessionId - The session ID of the user.\n   * @param {string} code - The verification code.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handleVerifyEmail(sessionId: string, code: string): Promise<string | Response> {\n    const { user } = await lucia.validateSession(sessionId)\n\n    if (!user) {\n      throw new UnAuthorizedException('Invalid User', { status: 401 })\n    }\n\n    const validCode = await this.userVerificationService.verifyVerificationCode(user, code)\n\n    if (!validCode) {\n      return new Response('Invalid code', { status: 400 })\n    }\n\n    await lucia.invalidateUserSessions(user.id)\n    await prisma.user.update({\n      where: { id: user.id },\n      data: { emailVerified: true },\n    })\n\n    const session = await lucia.createSession(user.id, {})\n    const sessionCookie = lucia.createSessionCookie(session.id)\n    return sessionCookie.serialize()\n  }\n\n  /**\n   * Handles creating a password reset token for a user.\n   *\n   * @param {string} userId - The user's ID.\n   * @returns {Promise<string>} - The password reset token.\n   */\n  public async handleCreatePasswordResetToken(userId: string): Promise<string | Response> {\n    await prisma.passwordResetToken.deleteMany({ where: { userId } })\n\n    const tokenId = generateIdFromEntropySize(25)\n    const tokenHash = encodeHex(await sha256(new TextEncoder().encode(tokenId)))\n\n    await prisma.passwordResetToken.create({\n      data: {\n        tokenHash,\n        userId,\n        expiresAt: createDate(new TimeSpan(2, 'h')),\n      },\n    })\n\n    return tokenId\n  }\n\n  /**\n   * Handles verifying if a user exists and their email is verified.\n   *\n   * @param {string} email - The user's email.\n   * @returns {Promise<boolean>} - True if user exists and email is verified, false otherwise.\n   */\n  public async handleVerifyUserExistAndEmailVerified(email: string): Promise<boolean> {\n    const user = await prisma.user.findUnique({ where: { email } })\n    return !!user && user.emailVerified\n  }\n\n  /**\n   * Handles password reset for a user with the given token and new password.\n   *\n   * @param {string} token - The password reset token.\n   * @param {string} password - The new password.\n   * @returns {Promise<string>} - A session cookie if successful.\n   */\n  public async handlePasswordReset(token: string, password: string): Promise<Cookie | Response> {\n    const tokenHash = encodeHex(await sha256(new TextEncoder().encode(token)))\n\n    const tokenData = await prisma.passwordResetToken.findUnique({ where: { tokenHash } })\n\n    if (!tokenData || !isWithinExpirationDate(tokenData.expiresAt)) {\n      await prisma.passwordResetToken.delete({ where: { tokenHash } })\n      return new Response('Invalid or expired token', { status: 400 })\n    }\n\n    await lucia.invalidateUserSessions(tokenData.userId.toString())\n\n    const passwordHash = await hash(password, {\n      memoryCost: 19456,\n      timeCost: 3,\n      parallelism: 1,\n      outputLen: 64,\n    })\n\n    await prisma.user.update({\n      where: { id: tokenData.userId },\n      data: { passwordHash },\n    })\n\n    await prisma.passwordResetToken.delete({ where: { tokenHash } })\n\n    const session = await lucia.createSession(tokenData.userId.toString(), {})\n    return lucia.createSessionCookie(session.id)\n  }\n\n  public async sendVerifyEmailCode(user: User) {\n    if (!user.email) {\n      throw new Exception('User does not have an email in the system', { status: 400 })\n    }\n    logger.info('sending email verification code to ' + user.email)\n    if (user.emailVerified) {\n      throw new Exception('Email already verified', { status: 400 })\n    }\n    const session = await lucia.createSession(user.id.toString(), {})\n    const token = lucia.createSessionCookie(session.id).serialize()\n\n    const code = await this.userVerificationService.generateEmailVerificationCode(\n      user.id,\n      user.email\n    )\n    await this.userVerificationService.sendVerificationCode(user.email, code, token)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\checkout_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { PrismaTransactionalClient, prisma } from '#services/prisma_service'\nimport StripeFacade from '#integrations/stripe/stripe_facade'\nimport RepoService from '#services/repo_service'\nimport OrderService from '#services/order_service'\nimport SellerService from '#services/seller_service'\nimport SalesService from '#services/sales_service'\nimport { OrderStatus } from '@prisma/client'\nimport { z } from 'zod'\nimport RepoAccessService from '#services/repo_access_service'\n\nconst processPaymentSchema = z.object({\n  paymentIntentId: z.string(),\n})\n\n@inject()\nexport default class CheckoutService {\n  constructor(\n    protected stripeFacade: StripeFacade,\n    protected repoService: RepoService,\n    protected orderService: OrderService,\n    protected sellerService: SellerService,\n    protected salesService: SalesService,\n    protected repoAccessService: RepoAccessService\n  ) {}\n\n  /**\n   * Initialize the checkout process for a repo\n   * @param repoId - The ID of the repo being accessed\n   * @param userId - The ID of the user requesting access\n   * @returns An object containing either the Stripe client secret or a success message for free repos\n   */\n  public async initCheckout(repoId: string, userId: string) {\n    const repoInfo = await this.repoService.getRepoById(repoId)\n    if (!repoInfo) {\n      throw new Error('Repo not found')\n    }\n\n    const isSellerVerified = await this.sellerService.checkIfSellerVerified(repoInfo.userId)\n    if (!isSellerVerified) {\n      throw new Error('Seller profile not available')\n    }\n\n    if (repoInfo.userId === userId) {\n      throw new Error('You cannot access your own repo through checkout')\n    }\n\n    // Handle free repos\n    if (repoInfo.price === 0) {\n      return this.processFreeRepo(repoId, userId)\n    }\n\n    // Proceed with paid repo checkout\n    const paymentIntent = await this.stripeFacade.createPaymentIntentForRepo(\n      repoInfo.price,\n      'MYR',\n      repoInfo.userId,\n      repoInfo.id\n    )\n\n    await this.orderService.createOrder({\n      userId: userId,\n      repoId: paymentIntent.metadata.repoId,\n      amount: paymentIntent.amount,\n      status: OrderStatus.REQUIRESACTION,\n      stripePaymentIntentId: paymentIntent.id,\n    })\n\n    return { clientSecret: paymentIntent.client_secret }\n  }\n\n  /**\n   * Process a free repo access\n   * @param repoId - The ID of the free repo\n   * @param userId - The ID of the user requesting access\n   * @returns An object indicating success and the order ID\n   */\n  private async processFreeRepo(repoId: string, userId: string) {\n    const order = await this.orderService.createOrder({\n      userId: userId,\n      repoId: repoId,\n      amount: 0,\n      status: OrderStatus.SUCCEEDED,\n      stripePaymentIntentId: '', // Use an empty string instead of null\n    })\n\n    const tx = await prisma.$transaction(async (prismaClient) => {\n      const accessGranted = await this.repoAccessService.grantAccess(\n        userId,\n        repoId,\n        order.id,\n        prismaClient as PrismaTransactionalClient\n      )\n      if (!accessGranted) {\n        throw new Error('Failed to grant access to the free repo')\n      }\n      return accessGranted\n    })\n\n    if (!tx) {\n      throw new Error('Transaction failed while processing free repo')\n    }\n\n    return { success: true, orderId: order.id, message: 'Access granted to free repo' }\n  }\n\n  /**\n   * Process a successful payment\n   * @param userId - The ID of the user making the payment\n   * @param paymentIntentId - The ID of the Stripe payment intent\n   * @param tx - Prisma transaction client\n   * @returns An object indicating success and the order ID\n   */\n  public async processPayment(userId: string, paymentIntentId: string, tx: PrismaTransactionalClient) {\n    const { paymentIntentId: validatedPaymentIntentId } = processPaymentSchema.parse({\n      paymentIntentId,\n    })\n\n    const paymentIntent = await this.stripeFacade.retrievePaymentIntent(validatedPaymentIntentId)\n    if (!paymentIntent) {\n      throw new Error('Payment intent not found')\n    }\n\n    const order = await this.orderService.getOrderByStripePaymentIntentId(paymentIntentId)\n    if (!order) {\n      throw new Error('Order not found')\n    }\n\n    const repo = await this.repoService.getRepoById(order.codeRepoId)\n    if (!repo) {\n      throw new Error('Repo not found')\n    }\n\n    const sellerProfile = await this.sellerService.getSellerProfile(repo.userId)\n    if (sellerProfile === null) {\n      throw new Error('Seller not available')\n    }\n\n    await this.orderService.updateOrderStatus(order.id, OrderStatus.SUCCEEDED, tx)\n    await this.sellerService.updateBalance(sellerProfile.id, order.totalAmount, tx)\n    await this.salesService.updateSalesAggregate(repo.userId, order.totalAmount, tx)\n\n    const accessGranted = await this.repoAccessService.grantAccess(userId, order.codeRepoId, order.id, tx)\n    if (!accessGranted) {\n      throw new Error('Failed to grant access to the repo')\n    }\n\n    return { success: true, orderId: order.id }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\code_check_service.ts</source>
<document_content>import { OpenAIEmbeddings } from '@langchain/openai'\nimport { HNSWLib } from '@langchain/community/vectorstores/hnswlib'\nimport { formatDocumentsAsString } from 'langchain/util/document'\nimport { PromptTemplate } from '@langchain/core/prompts'\nimport { RunnableSequence, RunnablePassthrough } from '@langchain/core/runnables'\nimport { StringOutputParser } from '@langchain/core/output_parsers'\nimport { codeCheckSchema } from '#validators/code_check'\nimport logger from '@adonisjs/core/services/logger'\nimport { pdfDocReader } from '../integrations/langchain/document_reader.js'\nimport { prisma } from '#services/prisma_service'\nimport { openaiModel } from '../integrations/langchain/openai.js'\nimport { ESLint } from 'eslint'\n\ninterface CodeCheckResult {\n  securityScore: number\n  maintainabilityScore: number\n  readabilityScore: number\n  securitySuggestion: string\n  maintainabilitySuggestion: string\n  readabilitySuggestion: string\n  overallDescription: string\n  eslintErrorCount: number\n  eslintFatalErrorCount: number\n}\n\nexport default class CodeCheckService {\n  private vectorStore: HNSWLib | null = null\n  private readonly condenseQuestionPrompt: PromptTemplate\n  private readonly answerPrompt: PromptTemplate\n  private readonly jsonSchema: object\n  private eslint: ESLint\n\n  constructor() {\n    this.condenseQuestionPrompt = PromptTemplate.fromTemplate(`\n      Given the following code, analyze it for security, maintainability, and readability:\n      Code: {question}\n      Provide a concise summary of the main concerns in each area.\n    `)\n\n    this.answerPrompt = PromptTemplate.fromTemplate(`\n      Based on the following context and code, provide a comprehensive analysis:\n      Context: {context}\n      Code: {question}\n\n      1. Overall Description: Summarize the code quality, considering security, maintainability, and readability in one or two sentences.\n\n      2. Security Analysis:\n         - Score the code's security on a scale of 0 to 100, where 0 is extremely insecure and 100 is highly secure.\n         - Provide specific suggestions for improving security.\n\n      3. Maintainability Analysis:\n         - Score the code's maintainability on a scale of 0 to 100, where 0 is very difficult to maintain and 100 is easily maintainable.\n         - Provide specific suggestions for improving maintainability.\n\n      4. Readability Analysis:\n         - Score the code's readability on a scale of 0 to 100, where 0 is very difficult to read and 100 is easily readable.\n         - Provide specific suggestions for improving readability.\n\n      Please ensure all suggestions are based solely on the given code, and ensure all fields mentioned above are fulfilled.\n    `)\n\n    this.jsonSchema = {\n      title: 'CodeCheckResult',\n      type: 'object',\n      properties: {\n        securityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        maintainabilityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        readabilityScore: { type: 'integer', minimum: 0, maximum: 100 },\n        securitySuggestion: { type: 'string' },\n        maintainabilitySuggestion: { type: 'string' },\n        readabilitySuggestion: { type: 'string' },\n        overallDescription: { type: 'string' },\n      },\n      required: [\n        'securityScore',\n        'maintainabilityScore',\n        'readabilityScore',\n        'securitySuggestion',\n        'maintainabilitySuggestion',\n        'readabilitySuggestion',\n        'overallDescription',\n      ],\n    }\n\n    // Initialize ESLint with settings for JSX and TSX\n    this.eslint = new ESLint({\n      useEslintrc: false,\n      overrideConfig: {\n        parser: '@typescript-eslint/parser',\n        parserOptions: {\n          ecmaVersion: 2021,\n          sourceType: 'module',\n          ecmaFeatures: {\n            jsx: true,\n          },\n        },\n        plugins: ['react', '@typescript-eslint'],\n        extends: [\n          'eslint:recommended',\n          'plugin:react/recommended',\n          'plugin:@typescript-eslint/recommended',\n        ],\n        rules: {\n          // Add any specific rules you want to enforce\n          'react/prop-types': 'off', // Example: Turn off prop-types rule\n        },\n      },\n    })\n  }\n\n  private async initializeVectorStore(): Promise<void> {\n    if (!this.vectorStore) {\n      this.vectorStore = await HNSWLib.fromTexts(\n        pdfDocReader.map((doc) => doc.pageContent),\n        pdfDocReader.map((_, index) => ({ id: index + 1 })),\n        new OpenAIEmbeddings()\n      )\n    }\n  }\n\n  private createStandaloneQuestionChain(): RunnableSequence {\n    return RunnableSequence.from([\n      {\n        question: (input: { question: string; chat_history: [string, string][] }) => input.question,\n        chat_history: (input: { question: string; chat_history: [string, string][] }) =>\n          this.formatChatHistory(input.chat_history),\n      },\n      this.condenseQuestionPrompt,\n      openaiModel,\n      new StringOutputParser(),\n    ])\n  }\n\n  private formatChatHistory(chatHistory: [string, string][]): string {\n    return chatHistory\n      .map(([human, assistant]) => `Human: ${human}\nAssistant: ${assistant}`)\n      .join('\n')\n  }\n\n  private async lintCode(\n    code: string,\n    language: 'JSX' | 'TSX'\n  ): Promise<{ errorCount: number; fatalErrorCount: number }> {\n    const extension = language === 'JSX' ? '.jsx' : '.tsx'\n    const results = await this.eslint.lintText(code, { filePath: `temp${extension}` })\n    return {\n      errorCount: results[0].errorCount,\n      fatalErrorCount: results[0].fatalErrorCount,\n    }\n  }\n\n  public async performCodeCheck(code: string, language: 'JSX' | 'TSX'): Promise<CodeCheckResult> {\n    try {\n      await this.initializeVectorStore()\n\n      if (!this.vectorStore) {\n        throw new Error('Vector store initialization failed')\n      }\n\n      const retriever = this.vectorStore.asRetriever()\n      const standaloneQuestionChain = this.createStandaloneQuestionChain()\n\n      const answerChain = RunnableSequence.from([\n        {\n          context: retriever.pipe(formatDocumentsAsString),\n          question: new RunnablePassthrough(),\n        },\n        this.answerPrompt,\n        openaiModel.withStructuredOutput(this.jsonSchema),\n      ])\n\n      const conversationalRetrievalQAChain = standaloneQuestionChain.pipe(answerChain)\n\n      const result = await conversationalRetrievalQAChain.invoke({\n        question: `Analyze the following ${language} code for overall description, security, maintainability, and readability:\n\n${code}`,\n        chat_history: [],\n      })\n\n      const { errorCount, fatalErrorCount } = await this.lintCode(code, language)\n\n      logger.info({ message: 'Code check result', result })\n      logger.info({ message: 'ESLint error counts', errorCount, fatalErrorCount })\n\n      const finalResult: CodeCheckResult = {\n        ...codeCheckSchema.parse(result),\n        eslintErrorCount: errorCount,\n        eslintFatalErrorCount: fatalErrorCount,\n      }\n\n      logger.info({ message: 'Code check completed', result: finalResult })\n      return finalResult\n    } catch (error) {\n      logger.error({ message: 'Error performing code check', error })\n      throw new Error(\n        `Code check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  public async performAndStoreCodeCheck(\n    repoId: string,\n    code: string,\n    language: 'JSX' | 'TSX'\n  ): Promise<CodeCheckResult> {\n    try {\n      const result = await this.performCodeCheck(code, language)\n\n      await this.storeCodeCheckResult(repoId, result)\n\n      return result\n    } catch (error) {\n      logger.error({ message: 'Error performing and storing code check', error, repoId })\n      throw new Error(\n        `Code check failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  private async storeCodeCheckResult(repoId: string, result: CodeCheckResult): Promise<void> {\n    try {\n      await prisma.codeCheck.create({\n        data: {\n          repoId,\n          securityScore: result.securityScore,\n          maintainabilityScore: result.maintainabilityScore,\n          readabilityScore: result.readabilityScore,\n          securitySuggestion: result.securitySuggestion,\n          maintainabilitySuggestion: result.maintainabilitySuggestion,\n          readabilitySuggestion: result.readabilitySuggestion,\n          overallDescription: result.overallDescription,\n          eslintErrorCount: result.eslintErrorCount,\n          eslintFatalErrorCount: result.eslintFatalErrorCount,\n        },\n      })\n\n      logger.info({ message: 'Code check result stored successfully', repoId })\n    } catch (error) {\n      logger.error({ message: 'Error storing code check result', error, repoId })\n      throw new Error(\n        `Failed to store code check result: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n\n  public async getLatestCodeCheck(repoId: string, userId: string): Promise<CodeCheckResult | null> {\n    try {\n      const latestCodeCheck = await prisma.codeCheck.findFirst({\n        where: { repoId },\n        orderBy: { createdAt: 'desc' },\n      })\n\n      if (!latestCodeCheck) {\n        return null\n      }\n\n      // Fetch user and repo information\n      const user = await prisma.user.findUnique({ where: { id: userId } })\n      const repo = await prisma.codeRepo.findUnique({ where: { id: repoId } })\n\n      if (!user || !repo) {\n        throw new Error('User or repository not found')\n      }\n\n      // Check if user is admin or repo owner\n      const isAdmin = user.role === 'ADMIN'\n      const isOwner = repo.userId === userId\n\n      // Prepare the result object\n      const result: Partial<CodeCheckResult> = {\n        securityScore: latestCodeCheck.securityScore,\n        maintainabilityScore: latestCodeCheck.maintainabilityScore,\n        readabilityScore: latestCodeCheck.readabilityScore,\n        eslintErrorCount: latestCodeCheck.eslintErrorCount,\n        eslintFatalErrorCount: latestCodeCheck.eslintFatalErrorCount,\n      }\n\n      // Include detailed descriptions only for admin or repo owner\n      if (isAdmin || isOwner) {\n        result.securitySuggestion = latestCodeCheck.securitySuggestion\n        result.maintainabilitySuggestion = latestCodeCheck.maintainabilitySuggestion\n        result.readabilitySuggestion = latestCodeCheck.readabilitySuggestion\n        result.overallDescription = latestCodeCheck.overallDescription\n      }\n\n      return result as CodeCheckResult\n    } catch (error) {\n      logger.error({ message: 'Error retrieving latest code check', error, repoId, userId })\n      throw new Error(\n        `Failed to retrieve latest code check: ${error instanceof Error ? error.message : 'Unknown error'}`\n      )\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\comment_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { Comment, UserCommentFlag, VoteType } from '@prisma/client'\nimport { RegExpMatcher, englishDataset, englishRecommendedTransformers } from 'obscenity'\n\ninterface CommentCreationData {\n  content: string\n  userId: string\n  reviewId: string\n}\n\ninterface CommentUpdateData {\n  content?: string\n}\n\ninterface CommentResponse {\n  id: string\n  content: string\n  userId: string\n  reviewId: string\n  createdAt?: Date\n  updatedAt?: Date\n  upvotes?: number\n  downvotes?: number\n  flag: UserCommentFlag\n}\n\nexport class CommentService {\n  private matcher: RegExpMatcher\n\n  constructor() {\n    this.matcher = new RegExpMatcher({\n      ...englishDataset.build(),\n      ...englishRecommendedTransformers,\n    })\n  }\n\n  private checkContent(content: string): UserCommentFlag {\n    return this.matcher.hasMatch(content) ? 'INAPPROPRIATE_LANGUAGE' : 'NONE'\n  }\n\n  private sanitizeComment(comment: Comment): CommentResponse {\n    const { id, content, userId, reviewId, createdAt, updatedAt, upvotes, downvotes, flag } =\n      comment\n    return { id, content, userId, reviewId, createdAt, updatedAt, upvotes, downvotes, flag }\n  }\n\n  async createComment(data: CommentCreationData): Promise<CommentResponse> {\n    const flag = this.checkContent(data.content)\n    const comment = await prisma.comment.create({ data: { ...data, flag } })\n    return this.sanitizeComment(comment)\n  }\n\n  async getCommentById(id: string): Promise<CommentResponse | null> {\n    const comment = await prisma.comment.findUnique({ where: { id, deletedAt: null } })\n    return comment ? this.sanitizeComment(comment) : null\n  }\n\n  async updateComment(id: string, data: CommentUpdateData): Promise<CommentResponse> {\n    const flag = data.content ? this.checkContent(data.content) : undefined\n    const comment = await prisma.comment.update({\n      where: { id, deletedAt: null },\n      data: { ...data, flag },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async revertFlag(id: string): Promise<CommentResponse> {\n    const comment = await prisma.comment.update({\n      where: { id },\n      data: { flag: UserCommentFlag.NONE },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async deleteComment(id: string): Promise<CommentResponse> {\n    const comment = await prisma.comment.update({\n      where: { id },\n      data: { deletedAt: new Date() },\n    })\n    return this.sanitizeComment(comment)\n  }\n\n  async getAllFlaggedComments(): Promise<\n    Omit<CommentResponse, 'upvotes' | 'downvotes' | 'createdAt'>[]\n  > {\n    const comments = await prisma.comment.findMany({\n      where: {\n        flag: { not: UserCommentFlag.NONE },\n      },\n      include: { user: true },\n    })\n\n    return comments.map(({ upvotes, downvotes, createdAt, ...rest }) => {\n      return {\n        ...rest,\n        user: {\n          email: rest.user.email,\n        },\n      }\n    })\n  }\n\n  async handleVote(\n    commentId: string,\n    userId: string,\n    voteType: VoteType\n  ): Promise<CommentResponse> {\n    const existingVote = await prisma.vote.findUnique({\n      where: {\n        userId_commentId: {\n          userId,\n          commentId,\n        },\n      },\n    })\n\n    await prisma.$transaction(async (tx) => {\n      if (!existingVote) {\n        await tx.vote.create({\n          data: {\n            userId,\n            commentId,\n            type: voteType,\n          },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { increment: 1 },\n          },\n        })\n      } else if (existingVote.type !== voteType) {\n        await tx.vote.update({\n          where: { id: existingVote.id },\n          data: { type: voteType },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { increment: 1 },\n            [voteType === VoteType.UPVOTE ? 'downvotes' : 'upvotes']: { decrement: 1 },\n          },\n        })\n      } else {\n        await tx.vote.delete({\n          where: { id: existingVote.id },\n        })\n        await tx.comment.update({\n          where: { id: commentId },\n          data: {\n            [voteType === VoteType.UPVOTE ? 'upvotes' : 'downvotes']: { decrement: 1 },\n          },\n        })\n      }\n    })\n\n    const updatedComment = await prisma.comment.findUnique({\n      where: { id: commentId },\n    })\n\n    if (!updatedComment) {\n      throw new Error('Comment not found after vote operation')\n    }\n\n    return this.sanitizeComment(updatedComment)\n  }\n\n  async getPaginatedCommentsByReview(reviewId: string, page: number, perPage: number) {\n    const skip = (page - 1) * perPage\n    const [comments, total] = await prisma.$transaction([\n      prisma.comment.findMany({\n        where: { reviewId },\n        skip,\n        take: perPage,\n        orderBy: { createdAt: 'desc' },\n        include: {\n          user: {\n            select: {\n              id: true,\n              email: true,\n              profile: {\n                select: {\n                  name: true,\n                  profileImg: true,\n                },\n              },\n            },\n          },\n        },\n      }),\n      prisma.comment.count({ where: { reviewId } }),\n    ])\n\n    return {\n      data: comments,\n      meta: {\n        total,\n        page,\n        perPage,\n        lastPage: Math.ceil(total / perPage),\n      },\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\lucia_service.ts</source>
<document_content>import { Lucia } from 'lucia'\nimport { PrismaAdapter } from '@lucia-auth/adapter-prisma'\nimport { Role } from '@prisma/client'\nimport { prisma } from './prisma_service.js'\n\nimport {\n  HttpContext,\n  // Response,\n} from '@adonisjs/core/http'\nimport logger from '@adonisjs/core/services/logger'\n\n// import type { Session, User } from 'lucia'\n\nconst client = prisma\nconst adapter = new PrismaAdapter(client.session, client.user)\n\nconst env = process.env.NODE_ENV\n\nexport const lucia = new Lucia(adapter, {\n  sessionCookie: {\n    attributes: {\n      secure: env === 'PRODUCTION', // set `Secure` flag in HTTPS\n    },\n  },\n  getUserAttributes: (attributes) => {\n    // get profile attributes from the user\n    return {\n      email: attributes.email,\n      emailVerified: attributes.emailVerified,\n      // avatar: attributes.avatar,\n      role: attributes.role,\n      bannedUntil: attributes.bannedUntil,\n      deletedAt: attributes.deletedAt,\n    }\n  },\n})\n\nexport const validateRequestFromMiddleware = async (ctx: HttpContext) => {\n  const sessionId = lucia.readSessionCookie(ctx.request.headers().cookie ?? '')\n  if (!sessionId)\n    return {\n      user: null,\n      session: null,\n    }\n\n  const result = await lucia.validateSession(sessionId)\n  try {\n    if (result.session && result.session.fresh) {\n      const sessionCookie = lucia.createSessionCookie(result.session.id)\n      ctx.request.headers().SetCookie = sessionCookie.serialize()\n    }\n  } catch (error) {\n    logger.error(error)\n  }\n  return result\n}\n\ndeclare module 'lucia' {\n  interface Register {\n    Lucia: typeof lucia\n    DatabaseUserAttributes: {\n      email: string\n      avatar: string\n      emailVerified: boolean\n      role: Role\n      bannedUntil?: Date | null\n      deletedAt?: Date | null\n    }\n  }\n}\n\nexport default lucia\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\moderator_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport { UserCommentFlag, Role } from '@prisma/client'\n\n@inject()\nexport default class ModeratorDashboardService {\n  /**\n   * Get moderator dashboard data\n   * @param moderatorId - The ID of the moderator\n   * @returns Promise<object> Dashboard data\n   */\n  public async getDashboardData(moderatorId: string): Promise<object> {\n    const now = DateTime.now()\n    const startOfDay = now.startOf('day').toJSDate()\n    const startOfWeek = now.startOf('week').toJSDate()\n    const startOfMonth = now.startOf('month').toJSDate()\n\n    const [\n      contentModerationOverview,\n      moderationActivity,\n      userReportManagement,\n      contentAnalytics,\n      userManagement,\n      reviewAndCommentMetrics,\n      moderationQueue,\n      moderatorPerformance\n    ] = await Promise.all([\n      this.getContentModerationOverview(),\n      this.getModerationActivity(moderatorId, startOfDay, startOfWeek, startOfMonth),\n      this.getUserReportManagement(),\n      this.getContentAnalytics(),\n      this.getUserManagement(),\n      this.getReviewAndCommentMetrics(),\n      this.getModerationQueue(),\n      this.getModeratorPerformance(moderatorId)\n    ])\n\n    return {\n      contentModerationOverview,\n      moderationActivity,\n      userReportManagement,\n      contentAnalytics,\n      userManagement,\n      reviewAndCommentMetrics,\n      moderationQueue,\n      moderatorPerformance\n    }\n  }\n\n  private async getContentModerationOverview() {\n    const flaggedReviews = await prisma.review.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const flaggedComments = await prisma.comment.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const awaitingModeration = await prisma.review.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    }) + await prisma.comment.count({\n      where: { flag: { not: UserCommentFlag.NONE } }\n    })\n\n    const recentFlaggedContent = await prisma.review.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 5,\n      orderBy: { updatedAt: 'desc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    return {\n      totalFlaggedContent: flaggedReviews + flaggedComments,\n      awaitingModeration,\n      recentFlaggedContent\n    }\n  }\n\n  private async getModerationActivity(moderatorId: string, startOfDay: Date, startOfWeek: Date, startOfMonth: Date) {\n    const moderatedLast24Hours = await this.getModeratedCount(moderatorId, startOfDay)\n    const moderatedLast7Days = await this.getModeratedCount(moderatorId, startOfWeek)\n    const moderatedLast30Days = await this.getModeratedCount(moderatorId, startOfMonth)\n\n    return {\n      moderatedLast24Hours,\n      moderatedLast7Days,\n      moderatedLast30Days\n    }\n  }\n\n  private async getModeratedCount(moderatorId: string, startDate: Date) {\n    const reviewCount = await prisma.review.count({\n      where: {\n        votes: {\n          some: {\n            userId: moderatorId,\n            createdAt: { gte: startDate }\n          }\n        }\n      }\n    })\n\n    const commentCount = await prisma.comment.count({\n      where: {\n        votes: {\n          some: {\n            userId: moderatorId,\n            createdAt: { gte: startDate }\n          }\n        }\n      }\n    })\n\n    return reviewCount + commentCount\n  }\n\n  private async getUserReportManagement() {\n    // Note: This method assumes you have a UserReport model. If not, you may need to adjust this.\n    const recentReports = await prisma.supportTicket.findMany({\n      where: { type: 'USER_REPORT' },\n      take: 10,\n      orderBy: { createdAt: 'desc' },\n      include: {\n        user: { select: { email: true } }\n      }\n    })\n\n    const openReports = await prisma.supportTicket.count({\n      where: { \n        type: 'USER_REPORT',\n        status: 'todo'\n      }\n    })\n\n    return { recentReports, openReports }\n  }\n\n  private async getContentAnalytics() {\n    const activeDiscussions = await prisma.codeRepo.findMany({\n      take: 5,\n      orderBy: { reviews: { _count: 'desc' } },\n      select: {\n        id: true,\n        name: true,\n        _count: { select: { reviews: true } }\n      }\n    })\n\n    // Trending topics would require more complex text analysis\n    // This is a simplified version looking at frequent words in recent reviews\n    const recentReviews = await prisma.review.findMany({\n      take: 100,\n      orderBy: { createdAt: 'desc' },\n      select: { content: true }\n    })\n\n    const words = recentReviews.flatMap(review => review.content.split(/\s+/))\n    const wordFrequency = words.reduce((acc, word) => {\n      acc[word] = (acc[word] || 0) + 1\n      return acc\n    }, {} as Record<string, number>)\n\n    const trendingTopics = Object.entries(wordFrequency)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([word]) => word)\n\n    return { activeDiscussions, trendingTopics }\n  }\n\n  private async getUserManagement() {\n    const recentBans = await prisma.user.findMany({\n      where: { bannedUntil: { not: null } },\n      take: 5,\n      orderBy: { bannedUntil: 'desc' },\n      select: { id: true, email: true, bannedUntil: true }\n    })\n\n    const usersWithMultipleFlags = await prisma.user.findMany({\n      where: {\n        OR: [\n          { reviews: { some: { flag: { not: UserCommentFlag.NONE } } } },\n          { comments: { some: { flag: { not: UserCommentFlag.NONE } } } }\n        ]\n      },\n      take: 10,\n      select: {\n        id: true,\n        email: true,\n        _count: {\n          select: {\n            reviews: { where: { flag: { not: UserCommentFlag.NONE } } },\n            comments: { where: { flag: { not: UserCommentFlag.NONE } } }\n          }\n        }\n      },\n      orderBy: {\n        reviews: { _count: 'desc' }\n      }\n    })\n\n    return { recentBans, usersWithMultipleFlags }\n  }\n\n  private async getReviewAndCommentMetrics() {\n    const totalReviews = await prisma.review.count()\n    const totalComments = await prisma.comment.count()\n\n    const averageRating = await prisma.review.aggregate({\n      _avg: { rating: true }\n    })\n\n    const ratingDistribution = await prisma.review.groupBy({\n      by: ['rating'],\n      _count: true\n    })\n\n    return {\n      totalReviews,\n      totalComments,\n      averageRating: averageRating._avg.rating || 0,\n      ratingDistribution: ratingDistribution.reduce((acc, { rating, _count }) => {\n        acc[rating] = _count\n        return acc\n      }, {} as Record<number, number>)\n    }\n  }\n\n  private async getModerationQueue() {\n    const pendingReviews = await prisma.review.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 10,\n      orderBy: { createdAt: 'asc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    const pendingComments = await prisma.comment.findMany({\n      where: { flag: { not: UserCommentFlag.NONE } },\n      take: 10,\n      orderBy: { createdAt: 'asc' },\n      include: { user: { select: { email: true } } }\n    })\n\n    return { pendingReviews, pendingComments }\n  }\n\n  private async getModeratorPerformance(moderatorId: string) {\n    const moderatedReviews = await prisma.vote.findMany({\n      where: {\n        userId: moderatorId,\n        review: { isNot: null }\n      },\n      select: { createdAt: true, review: { select: { createdAt: true } } }\n    })\n\n    const moderatedComments = await prisma.vote.findMany({\n      where: {\n        userId: moderatorId,\n        comment: { isNot: null }\n      },\n      select: { createdAt: true, comment: { select: { createdAt: true } } }\n    })\n\n    const allModeratedItems = [\n      ...moderatedReviews.map(r => ({ moderatedAt: r.createdAt, createdAt: r.review!.createdAt })),\n      ...moderatedComments.map(c => ({ moderatedAt: c.createdAt, createdAt: c.comment!.createdAt }))\n    ]\n\n    const totalResponseTime = allModeratedItems.reduce((total, item) => {\n      return total + (item.moderatedAt.getTime() - item.createdAt.getTime())\n    }, 0)\n\n    const averageResponseTime = allModeratedItems.length > 0\n      ? totalResponseTime / allModeratedItems.length / (1000 * 60 * 60) // Convert to hours\n      : 0\n\n    return {\n      totalModeratedItems: allModeratedItems.length,\n      averageResponseTime\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\order_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Prisma, OrderStatus } from '@prisma/client'\n\n@inject()\nexport default class OrderService {\n  async createOrder(\n    data: {\n      userId: string\n      repoId: string\n      amount: number\n      status: OrderStatus\n      stripePaymentIntentId: string\n    },\n    tx?: Prisma.TransactionClient\n  ) {\n    const db = tx || prisma\n    return await db.order.create({\n      data: {\n        userId: data.userId,\n        codeRepoId: data.repoId,\n        totalAmount: data.amount,\n        status: data.status,\n        stripePaymentIntentId: data.stripePaymentIntentId,\n      },\n    })\n  }\n\n  async getOrderById(orderId: string) {\n    return await prisma.order.findUnique({\n      where: { id: orderId },\n    })\n  }\n\n  async updateOrderStatus(orderId: string, status: OrderStatus, tx?: Prisma.TransactionClient) {\n    const db = tx || prisma\n    return await db.order.update({\n      where: { id: orderId },\n      data: { status },\n    })\n  }\n\n  async getOrderByStripePaymentIntentId(paymentIntentId: string) {\n    return await prisma.order.findFirst({\n      where: { stripePaymentIntentId: paymentIntentId },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\payout_request_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { PayoutRequest, PayoutRequestStatus, SellerProfile, SellerVerificationStatus, Payout, Prisma, BankAccount, Order } from '@prisma/client'\nimport { DateTime } from 'luxon'\nimport { z } from 'zod'\n\nconst MINIMUM_PAYOUT_AMOUNT = 50\nconst COOLDOWN_PERIOD_DAYS = 7\n\nconst createPayoutRequestSchema = z.object({\n  totalAmount: z.number().positive(),\n})\n\ntype CreatePayoutRequestData = z.infer<typeof createPayoutRequestSchema>\n\n@inject()\nexport default class PayoutRequestService {\n  /**\n   * Create a new payout request.\n   * @param {string} userId - The user ID of the seller.\n   * @param {CreatePayoutRequestData} data - The payout request data.\n   * @returns {Promise<PayoutRequest>} The created payout request.\n   * @throws {Error} If the seller profile is not found, not verified, or other validation errors.\n   */\n  public async createPayoutRequest(userId: string, data: CreatePayoutRequestData): Promise<PayoutRequest> {\n    const validatedData = createPayoutRequestSchema.parse(data)\n\n    return prisma.$transaction(async (tx) => {\n      const sellerProfile = await tx.sellerProfile.findUnique({\n        where: { userId },\n        include: { user: true },\n      })\n      if (!sellerProfile) {\n        throw new Error('Seller profile not found')\n      }\n\n      if (sellerProfile.verificationStatus !== SellerVerificationStatus.APPROVED) {\n        throw new Error('Seller is not verified')\n      }\n\n      const lastPayoutDate = sellerProfile.lastPayoutDate || new Date(0)\n      const cooldownPeriod = DateTime.fromJSDate(lastPayoutDate).plus({ days: COOLDOWN_PERIOD_DAYS }).startOf('day')\n      const now = DateTime.utc().startOf('day')\n\n      if (now < cooldownPeriod) {\n        throw new Error('Cooldown period has not elapsed since last payout request')\n      }\n\n      if (validatedData.totalAmount < MINIMUM_PAYOUT_AMOUNT) {\n        throw new Error(`Minimum payout amount is $${MINIMUM_PAYOUT_AMOUNT}`)\n      }\n\n      if (validatedData.totalAmount > sellerProfile.balance) {\n        throw new Error('Requested amount exceeds available balance')\n      }\n\n      const payoutRequest = await tx.payoutRequest.create({\n        data: {\n          sellerProfileId: sellerProfile.id,\n          totalAmount: validatedData.totalAmount,\n          status: PayoutRequestStatus.PENDING,\n        },\n      })\n\n      await tx.sellerProfile.update({\n        where: { id: sellerProfile.id },\n        data: {\n          lastPayoutDate: now.toJSDate(),\n          balance: {\n            decrement: validatedData.totalAmount,\n          },\n        },\n      })\n\n      return payoutRequest\n    })\n  }\n\n  /**\n   * Get the balance and last payout request date for a seller.\n   * @param {string} userId - The user ID of the seller.\n   * @returns {Promise<{ balance: number; lastPayoutRequestDate: Date | null }>} The seller's balance and last payout request date.\n   * @throws {Error} If the seller profile is not found.\n   */\n  public async getSellerBalance(userId: string): Promise<{ balance: number; lastPayoutRequestDate: Date | null }> {\n    const sellerProfile = await prisma.sellerProfile.findUnique({\n      where: { userId },\n      select: { balance: true, lastPayoutDate: true },\n    })\n\n    if (!sellerProfile) {\n      throw new Error('Seller profile not found')\n    }\n\n    return {\n      balance: sellerProfile.balance,\n      lastPayoutRequestDate: sellerProfile.lastPayoutDate,\n    }\n  }\n\n  /**\n   * Get a payout request by its ID.\n   * @param {string} id - The payout request ID.\n   * @returns {Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }>} The payout request with related data.\n   * @throws {Error} If the payout request is not found.\n   */\n  public async getPayoutRequestById(id: string): Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }> {\n    const payoutRequest = await prisma.payoutRequest.findUnique({\n      where: { id },\n      include: {\n        sellerProfile: {\n          include: { bankAccount: true },\n        },\n        orders: true,\n      },\n    })\n    if (!payoutRequest) {\n      throw new Error('PayoutRequest not found')\n    }\n    return payoutRequest\n  }\n\n  /**\n   * Update a payout request's status.\n   * @param {string} id - The payout request ID.\n   * @param {Partial<PayoutRequestStatus>} data - The updated status data.\n   * @returns {Promise<PayoutRequest>} The updated payout request.\n   */\n  public async updatePayoutRequest(id: string, data: Partial<PayoutRequestStatus>): Promise<PayoutRequest> {\n    return prisma.payoutRequest.update({\n      where: { id },\n      data: {\n        status: data,\n      },\n    })\n  }\n\n  /**\n   * Delete a payout request.\n   * @param {string} id - The payout request ID.\n   * @returns {Promise<PayoutRequest>} The deleted payout request.\n   */\n  public async deletePayoutRequest(id: string): Promise<PayoutRequest> {\n    return prisma.payoutRequest.delete({ where: { id } })\n  }\n\n  /**\n   * Get paginated payout requests.\n   * @param {number} page - The page number.\n   * @param {number} limit - The number of items per page.\n   * @returns {Promise<{ data: PayoutRequest[]; meta: { total: number; page: number; limit: number } }>} Paginated payout requests.\n   */\n  public async getPaginatedPayoutRequests(page: number, limit: number): Promise<{ data: PayoutRequest[]; meta: { total: number; page: number; limit: number } }> {\n    const totalCount = await prisma.payoutRequest.count()\n    const payoutRequests = await prisma.payoutRequest.findMany({\n      skip: (page - 1) * limit,\n      take: limit,\n      include: {\n        sellerProfile: {\n          include: { user: true },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    })\n\n    return {\n      data: payoutRequests,\n      meta: {\n        total: totalCount,\n        page,\n        limit,\n      },\n    }\n  }\n\n  /**\n   * Get all payout requests for approved sellers.\n   * @returns {Promise<PayoutRequest[]>} All payout requests for approved sellers.\n   */\n  public async getAllPayoutRequests(): Promise<PayoutRequest[]> {\n    return await prisma.payoutRequest.findMany({\n      where: {\n        sellerProfile: {\n          verificationStatus: SellerVerificationStatus.APPROVED,\n        },\n      },\n      include: {\n        sellerProfile: {\n          include: {\n            user: {\n              select: { email: true, role: true, bannedUntil: true, deletedAt: true },\n            },\n            bankAccount: true,\n          },\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Get payout requests for a specific user.\n   * @param {string} userId - The user ID.\n   * @returns {Promise<PayoutRequest[]>} Payout requests for the user.\n   * @throws {Error} If the seller profile is not found.\n   */\n  public async getPayoutRequestsByUser(userId: string): Promise<PayoutRequest[]> {\n    const sellerProfile = await prisma.sellerProfile.findUnique({ where: { userId } })\n    if (!sellerProfile) {\n      throw new Error('Seller profile not found')\n    }\n\n    return prisma.payoutRequest.findMany({\n      where: { sellerProfileId: sellerProfile.id },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Process a payout request.\n   * @param {string} id - The payout request ID.\n   * @param {'approve' | 'reject'} action - The action to take.\n   * @param {string} adminId - The ID of the admin processing the request.\n   * @returns {Promise<PayoutRequest>} The processed payout request.\n   * @throws {Error} If the payout request is not found or not in a pending state.\n   */\n  public async processPayoutRequest(id: string, action: 'approve' | 'reject', adminId: string): Promise<PayoutRequest> {\n    return prisma.$transaction(async (tx) => {\n      const payoutRequest = await tx.payoutRequest.findUnique({\n        where: { id },\n        include: { sellerProfile: true },\n      })\n\n      if (!payoutRequest) {\n        throw new Error('PayoutRequest not found')\n      }\n\n      if (payoutRequest.status !== PayoutRequestStatus.PENDING) {\n        throw new Error('PayoutRequest is not in a pending state')\n      }\n\n      if (action === 'approve') {\n        await tx.payout.create({\n          data: {\n            sellerProfileId: payoutRequest.sellerProfileId,\n            payoutRequestId: payoutRequest.id,\n            totalAmount: payoutRequest.totalAmount,\n            currency: 'MYR',\n          },\n        })\n\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: PayoutRequestStatus.PROCESSED,\n            processedAt: DateTime.utc().toJSDate(),\n          },\n        })\n      } else {\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: PayoutRequestStatus.REJECTED,\n            processedAt: DateTime.utc().toJSDate(),\n          },\n        })\n\n        // Refund the amount back to the seller's balance\n        await tx.sellerProfile.update({\n          where: { id: payoutRequest.sellerProfileId },\n          data: {\n            balance: {\n              increment: payoutRequest.totalAmount,\n            },\n          },\n        })\n      }\n\n      return tx.payoutRequest.findUnique({\n        where: { id },\n        include: {\n          sellerProfile: {\n            include: { bankAccount: true },\n          },\n          orders: true,\n        },\n      }) as Promise<PayoutRequest & { sellerProfile: SellerProfile & { bankAccount: BankAccount | null }; orders: Order[] }>\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\payout_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Payout, PayoutRequest, Prisma } from '@prisma/client'\nimport { z } from 'zod'\n\nconst createPayoutSchema = z.object({\n  payoutRequestId: z.string().cuid(),\n  sellerProfileId: z.string().cuid(),\n  amount: z.number().positive(),\n  currency: z.string().default('MYR'),\n})\n\ntype CreatePayoutData = z.infer<typeof createPayoutSchema>\n\n@inject()\nexport default class PayoutService {\n  /**\n   * Create a new payout.\n   * @param {CreatePayoutData} data - The payout data.\n   * @returns {Promise<Payout>} The created payout.\n   */\n  public async createPayout(data: CreatePayoutData): Promise<Payout> {\n    const validatedData = createPayoutSchema.parse(data)\n    return prisma.payout.create({\n      data: {\n        payoutRequestId: validatedData.payoutRequestId,\n        sellerProfileId: validatedData.sellerProfileId,\n        totalAmount: validatedData.amount,\n        currency: validatedData.currency,\n      },\n    })\n  }\n\n  /**\n   * Get a payout by its ID.\n   * @param {string} id - The payout ID.\n   * @returns {Promise<Payout>} The payout.\n   * @throws {Error} If the payout is not found.\n   */\n  public async getPayoutById(id: string): Promise<Payout> {\n    const payout = await prisma.payout.findUnique({ where: { id } })\n    if (!payout) {\n      throw new Error('Payout not found')\n    }\n    return payout\n  }\n\n  /**\n   * Get all payouts for a specific seller profile.\n   * @param {string} sellerProfileId - The seller profile ID.\n   * @returns {Promise<Payout[]>} An array of payouts.\n   */\n  public async getPayoutsBySellerProfile(sellerProfileId: string): Promise<Payout[]> {\n    return prisma.payout.findMany({\n      where: { sellerProfileId },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Process a payout request.\n   * @param {string} id - The payout request ID.\n   * @param {'approve' | 'reject'} action - The action to take.\n   * @returns {Promise<Payout | null>} The processed payout or null if rejected.\n   * @throws {Error} If the payout request is not found or not in a pending state.\n   */\n  public async processPayoutRequest(id: string, action: 'approve' | 'reject'): Promise<Payout | null> {\n    return prisma.$transaction(async (tx) => {\n      const payoutRequest = await tx.payoutRequest.findUnique({\n        where: { id },\n        include: { sellerProfile: true },\n      })\n\n      if (!payoutRequest) {\n        throw new Error('Payout request not found')\n      }\n\n      if (payoutRequest.status !== 'PENDING') {\n        throw new Error('Payout request is not in a pending state')\n      }\n\n      if (action === 'approve') {\n        const payout = await tx.payout.create({\n          data: {\n            sellerProfileId: payoutRequest.sellerProfileId,\n            payoutRequestId: payoutRequest.id,\n            totalAmount: payoutRequest.totalAmount,\n            currency: 'MYR',\n          },\n        })\n\n        await tx.sellerProfile.update({\n          where: { id: payoutRequest.sellerProfileId },\n          data: {\n            lastPayoutDate: new Date(),\n            balance: {\n              decrement: payoutRequest.totalAmount,\n            },\n          },\n        })\n\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: 'PROCESSED',\n            processedAt: new Date(),\n          },\n        })\n\n        return payout\n      } else {\n        await tx.payoutRequest.update({\n          where: { id },\n          data: {\n            status: 'REJECTED',\n            processedAt: new Date(),\n          },\n        })\n\n        return null\n      }\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\prisma_service.ts</source>
<document_content>import { PrismaClient } from '@prisma/client'\nimport pg from 'pg'\nimport { PrismaPg } from '@prisma/adapter-pg'\nimport env from '#start/env'\n\nconst { Pool } = pg\n\nconst connectionString = `${env.get('DATABASE_URL')}`\n\nconst pool = new Pool({ connectionString })\n\nconst adapter = new PrismaPg(pool)\nexport const prisma = new PrismaClient({ adapter })\n\nexport type PrismaTransactionalClient = Parameters<Parameters<PrismaClient['$transaction']>[0]>[0]\n// export const prisma = new PrismaClient({});\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\profile_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { z } from 'zod'\nimport { s3Facade } from '#integrations/s3/s3_facade'\nimport { MultipartFile } from '@adonisjs/core/bodyparser'\nimport { Request } from '@adonisjs/core/http'\n\nconst createProfileSchema = z.object({\n  name: z.string().optional(),\n  phoneNumber: z.string().optional(),\n})\n\nexport class ProfileService {\n  /**\n   * @createProfile\n   * @description Create a new user profile\n   * @param {string} userId - The ID of the user\n   * @param {object} profileData - The profile data to be created\n   * @returns {Promise<object>} The created profile and signed URL for the profile image\n   */\n  async createProfile(userId: string, profileData: z.infer<typeof createProfileSchema>) {\n    const validatedData = createProfileSchema.parse(profileData)\n\n    return await prisma.$transaction(async (tx) => {\n      const existingProfile = await tx.profile.findUnique({ where: { userId } })\n      if (existingProfile) {\n        throw new Error('Profile already exists for this user')\n      }\n\n      let mediaId: string | undefined\n      let signedUrl: string | undefined\n\n      const profile = await tx.profile.create({\n        data: {\n          name: validatedData.name,\n          phoneNumber: validatedData.phoneNumber,\n          profileImg: mediaId ?? null,\n          user: { connect: { id: userId } },\n        },\n      })\n\n      return { profile, signedUrl }\n    })\n  }\n\n  /**\n   * @getProfile\n   * @description Get a user's profile\n   * @param {string} userId - The ID of the user\n   * @returns {Promise<object | null>} The user's profile or null if not found\n   */\n  async getProfile(userId: string) {\n    const profile = await prisma.profile.findUnique({\n      where: { userId },\n      include: { user: true },\n    })\n\n    if (profile && profile.profileImg) {\n      const media = await prisma.media.findUnique({ where: { id: profile.profileImg } })\n      if (media) {\n        const signedUrl = await s3Facade.getSignedUrl(media.url.split('/').pop()!)\n        return { ...profile, profileImgUrl: signedUrl }\n      }\n    }\n\n    return profile\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_access_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { PrismaTransactionalClient } from '#services/prisma_service'\nimport { OrderStatus, UserRepoAccess, Role } from '@prisma/client'\nimport { generateIdFromEntropySize } from 'lucia'\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class RepoAccessService {\n  /**\n   * Check if a user has access to a specific repo\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param tx - Prisma transactional client\n   * @returns A boolean indicating whether the user has access\n   */\n  public async hasAccess(\n    userId: string,\n    repoId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<boolean> {\n    const user = await tx.user.findUnique({ where: { id: userId } })\n    if (!user) {\n      return false\n    }\n\n    if (user.role === Role.ADMIN) {\n      return true\n    }\n\n    const access = await tx.userRepoAccess.findUnique({\n      where: {\n        userId_repoId: {\n          userId,\n          repoId,\n        },\n      },\n    })\n\n    if (!access) {\n      return false\n    }\n\n    // Check if access has expired\n    if (access.expiresAt && access.expiresAt < new Date()) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Grant access to a repo for a user based on a successful order\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param orderId - The ID of the completed order\n   * @param tx - Prisma transactional client\n   * @returns A boolean indicating whether access was successfully granted\n   */\n  public async grantAccess(\n    userId: string,\n    repoId: string,\n    orderId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<boolean> {\n    try {\n      const order = await tx.order.findUnique({\n        where: { id: orderId },\n        include: { codeRepo: true },\n      })\n\n      if (!order || order.status !== OrderStatus.SUCCEEDED) {\n        console.error(`Invalid order or order not completed: ${orderId}`)\n        return false\n      }\n\n      if (order.codeRepoId !== repoId || order.userId !== userId) {\n        console.error(`Order ${orderId} does not match the provided user and repo`)\n        return false\n      }\n\n      await this.upsertUserRepoAccess(userId, repoId, orderId, tx)\n      return true\n    } catch (error) {\n      console.error(`Error granting access for order ${orderId}:`, error)\n      return false\n    }\n  }\n\n  /**\n   * Create or update a UserRepoAccess entry\n   * @param userId - The ID of the user\n   * @param repoId - The ID of the repo\n   * @param orderId - The ID of the order\n   * @param tx - Prisma transactional client\n   * @returns The created or updated UserRepoAccess entry\n   */\n  private async upsertUserRepoAccess(\n    userId: string,\n    repoId: string,\n    orderId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<UserRepoAccess> {\n    return tx.userRepoAccess.upsert({\n      where: {\n        userId_repoId: {\n          userId,\n          repoId,\n        },\n      },\n      update: {\n        orderId,\n        grantedAt: new Date(),\n        expiresAt: null, // Reset expiration if updating\n      },\n      create: {\n        id: generateIdFromEntropySize(32),\n        userId,\n        repoId,\n        orderId,\n        grantedAt: new Date(),\n      },\n    })\n  }\n\n\n  /**\n   * Get all repos a user has access to\n   * @param userId - The ID of the user\n   * @param tx - Prisma transactional client\n   * @returns An array of repo IDs the user has access to\n   */\n  public async getUserAccessibleRepos(\n    userId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<string[]> {\n    try {\n      const accesses = await tx.userRepoAccess.findMany({\n        where: {\n          userId,\n          OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],\n        },\n        select: { repoId: true },\n      })\n\n      return accesses.map((access) => access.repoId)\n    } catch (error) {\n      logger.error(`Error retrieving accessible repos for user ${userId}:`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Get all users who have access to a specific repo\n   * @param repoId - The ID of the repo\n   * @param tx - Prisma transactional client\n   * @returns An array of user IDs who have access to the repo\n   */\n  public async getRepoAccessibleUsers(\n    repoId: string,\n    tx: PrismaTransactionalClient\n  ): Promise<string[]> {\n    const accesses = await tx.userRepoAccess.findMany({\n      where: {\n        repoId,\n        OR: [{ expiresAt: null }, { expiresAt: { gt: new Date() } }],\n      },\n      select: { userId: true },\n    })\n\n    return accesses.map((access) => access.userId)\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_search_service.ts</source>
<document_content>import { Kysely, sql, SelectQueryBuilder, Expression, SqlBool } from 'kysely'\nimport { Language, Visibility, SellerVerificationStatus, CodeRepoStatus } from '@prisma/client'\nimport { DB } from '#database/kysely/types'\nimport { kyselyDb } from '#database/kysely'\nimport logger from '@adonisjs/core/services/logger'\nimport { generateIdFromEntropySize } from 'lucia'\n\nexport interface SearchCriteria {\n  query?: string\n  tags?: string[]\n  minPrice?: number\n  maxPrice?: number\n  language?: Language\n  visibility?: Visibility\n}\n\ninterface CodeRepoSearchResult {\n  id: string\n  name: string\n  description: string | null\n  language: Language\n  price: number\n  visibility: Visibility\n  tags: string[]\n  createdAt: Date\n}\n\ntype CodeRepoSearchQuery = SelectQueryBuilder<\n  DB,\n  'CodeRepo' | 'TagsOnRepos' | 'Tag' | 'User' | 'SellerProfile',\n  any\n>\n\nexport class CodeRepoSearchBuilder {\n  private db: Kysely<DB>\n  private searchCriteria: SearchCriteria\n  private query: CodeRepoSearchQuery\n  private userId?: string\n\n  constructor(db: Kysely<DB>) {\n    this.db = db\n    this.searchCriteria = {}\n    this.query = this.db\n      .selectFrom('CodeRepo')\n      .leftJoin('TagsOnRepos', 'CodeRepo.id', 'TagsOnRepos.codeRepoId')\n      .leftJoin('Tag', 'TagsOnRepos.tagId', 'Tag.id')\n      .innerJoin('User', 'CodeRepo.userId', 'User.id')\n      .innerJoin('SellerProfile', 'User.id', 'SellerProfile.userId')\n      .select([\n        'CodeRepo.id',\n        'CodeRepo.name',\n        'CodeRepo.description',\n        'CodeRepo.language',\n        'CodeRepo.price',\n        'CodeRepo.visibility',\n        'CodeRepo.createdAt',\n        'CodeRepo.status',\n        sql<string[]>`array_agg(DISTINCT \"Tag\".\"name\")`.as('tags'),\n      ])\n      .where('SellerProfile.verificationStatus', '=', SellerVerificationStatus.APPROVED)\n      .where('CodeRepo.deletedAt', 'is', null) // Exclude soft-deleted repos\n      .where('CodeRepo.status', '=', CodeRepoStatus.active)\n      .groupBy([\n        'CodeRepo.id',\n        'CodeRepo.name',\n        'CodeRepo.description',\n        'CodeRepo.language',\n        'CodeRepo.price',\n        'CodeRepo.visibility',\n        'CodeRepo.createdAt',\n      ])\n  }\n\n  withQuery(query?: string): this {\n    if (query) {\n      this.searchCriteria.query = query\n      const searchTerms = query.split(' ').filter((term) => term.length > 0)\n      this.query = this.query.where((eb) => {\n        const conditions = searchTerms.map((term) =>\n          eb.or([\n            eb('CodeRepo.name', 'ilike', `%${term}%`),\n            eb('CodeRepo.description', 'ilike', `%${term}%`),\n          ])\n        )\n        return eb.and(conditions)\n      })\n    }\n    return this\n  }\n\n  withTags(tags?: string[]): this {\n    if (tags && tags.length > 0) {\n      this.searchCriteria.tags = tags\n      this.query = this.query.where('Tag.name', 'in', tags)\n    }\n    return this\n  }\n\n  withPriceRange(minPrice?: number, maxPrice?: number): this {\n    if (minPrice !== undefined) {\n      this.searchCriteria.minPrice = minPrice\n      this.query = this.query.where('CodeRepo.price', '>=', minPrice)\n    }\n    if (maxPrice !== undefined) {\n      this.searchCriteria.maxPrice = maxPrice\n      this.query = this.query.where('CodeRepo.price', '<=', maxPrice)\n    }\n    return this\n  }\n\n  withLanguage(language?: Language): this {\n    if (language) {\n      this.searchCriteria.language = language\n      this.query = this.query.where('CodeRepo.language', '=', language)\n    }\n    return this\n  }\n\n  withVisibility(visibility?: Visibility): this {\n    if (visibility) {\n      this.searchCriteria.visibility = visibility\n      this.query = this.query.where('CodeRepo.visibility', '=', visibility)\n    }\n    return this\n  }\n\n  withUserId(userId?: string): this {\n    if (userId) this.userId = userId\n    return this\n  }\n\n  private async saveSearchHistory(): Promise<void> {\n    if (!this.userId || !this.searchCriteria.query) {\n      return\n    }\n\n    try {\n      const test = new Date()\n      await this.db\n        .insertInto('SearchHistory')\n        .values({\n          id: generateIdFromEntropySize(32),\n          userId: this.userId,\n          tag: this.searchCriteria.query,\n          createdAt: test,\n        })\n        .execute()\n    } catch (error) {\n      logger.error({ error }, 'Error saving search history')\n    }\n  }\n\n  build(): CodeRepoSearchQuery {\n    this.saveSearchHistory().catch((error) => {\n      logger.error({ error }, 'Error saving search history')\n    })\n\n    return this.query\n  }\n}\n\nexport default class CodeRepoSearchService {\n  private db: Kysely<DB>\n\n  constructor() {\n    this.db = kyselyDb\n  }\n\n  async search(criteria: SearchCriteria, userId?: string, page: number = 1, pageSize: number = 10) {\n    const offset = (page - 1) * pageSize\n\n    const builder = new CodeRepoSearchBuilder(this.db)\n      .withQuery(criteria.query)\n      .withTags(criteria.tags)\n      .withPriceRange(criteria.minPrice, criteria.maxPrice)\n      .withLanguage(criteria.language)\n      .withVisibility('public' as Visibility)\n      .withUserId(userId)\n\n    try {\n      const query = builder.build()\n\n      // Create a separate count query without GROUP BY\n      const countQuery = this.db\n        .selectFrom('CodeRepo')\n        .leftJoin('TagsOnRepos', 'CodeRepo.id', 'TagsOnRepos.codeRepoId')\n        .leftJoin('Tag', 'TagsOnRepos.tagId', 'Tag.id')\n        .innerJoin('User', 'CodeRepo.userId', 'User.id')\n        .innerJoin('SellerProfile', 'User.id', 'SellerProfile.userId')\n        .select(sql<number>`count(distinct \"CodeRepo\".\"id\")`.as('count'))\n        .where((eb) => {\n          const conditions: Expression<SqlBool>[] = [\n            eb('SellerProfile.verificationStatus', '=', SellerVerificationStatus.APPROVED),\n            eb('CodeRepo.deletedAt', 'is', null), // Exclude soft-deleted repos\n          ]\n\n          if (criteria.tags && criteria.tags.length > 0) {\n            conditions.push(eb('Tag.name', 'in', criteria.tags))\n          }\n          if (criteria.query) {\n            const searchTerms = criteria.query.split(' ').filter((term) => term.length > 0)\n            const searchConditions = searchTerms.map((term) =>\n              eb.or([\n                eb('CodeRepo.name', 'ilike', `%${term}%`),\n                eb('CodeRepo.description', 'ilike', `%${term}%`),\n              ])\n            )\n            conditions.push(eb.and(searchConditions))\n          }\n          if (criteria.minPrice !== undefined) {\n            conditions.push(eb('CodeRepo.price', '>=', criteria.minPrice))\n          }\n          if (criteria.maxPrice !== undefined) {\n            conditions.push(eb('CodeRepo.price', '<=', criteria.maxPrice))\n          }\n          if (criteria.language) {\n            conditions.push(eb('CodeRepo.language', '=', criteria.language))\n          }\n          conditions.push(eb('CodeRepo.visibility', '=', 'public' as Visibility))\n\n          return eb.and(conditions)\n        })\n\n      const resultsQuery = query.limit(pageSize).offset(offset)\n\n      const [totalCountResult, results] = await Promise.all([\n        countQuery.executeTakeFirst(),\n        resultsQuery.execute() as Promise<CodeRepoSearchResult[]>,\n      ])\n\n      const total = Number(totalCountResult?.count || 0)\n\n      // Process the results to format tags\n      const formattedResults = results.map((repo) => ({\n        ...repo,\n        tags: repo.tags?.filter(Boolean) || [], // Remove null values and ensure it's an array\n      }))\n\n      return {\n        data: formattedResults,\n        meta: {\n          total,\n          page,\n          pageSize,\n          lastPage: Math.ceil(total / pageSize),\n        },\n      }\n    } catch (error) {\n      logger.error({ error, stack: error.stack }, 'Error executing search query')\n      throw new Error('An error occurred while executing the search query')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\repo_service.ts</source>
<document_content>import { sql } from 'kysely'\nimport { inject } from '@adonisjs/core'\nimport { CodeRepo, CodeRepoStatus, OrderStatus, Tag, Visibility } from '@prisma/client'\nimport { kyselyDb } from '#database/kysely'\nimport { prisma } from './prisma_service.js'\nimport { publishRepoSchema } from '#validators/repo'\nimport { z } from 'zod'\nimport CodeCheckService from './code_check_service.js'\nimport { RepoExistenceHandler, UserAuthorizationHandler, RepoStatusHandler, RepoContentHandler, CodeCheckHandler, CodeQualityHandler, RepoCheckHandler, RepoCheckContext } from '../handlers/repo.js'\n\ntype PartialCodeRepo = Omit<CodeRepo, 'sourceJs' | 'sourceCss' | 'userId'> & {\n  sourceJs?: string\n  sourceCss?: string\n  tags?: { tag: Tag }[];\n}\n\ntype RepoCheckoutInfo = {\n  repo: PartialCodeRepo\n  sellerProfileId: string | null\n}\n\ntype CreateRepoData = Omit<CodeRepo, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'> & { tags: string[] }\n\n@inject()\nexport default class RepoService {\n  constructor(protected codeCheckService: CodeCheckService) {}\n\n  private createPublishChain(): RepoCheckHandler {\n    const repoExistenceHandler = new RepoExistenceHandler()\n    const userAuthorizationHandler = new UserAuthorizationHandler()\n    const repoStatusHandler = new RepoStatusHandler(CodeRepoStatus.active)\n    const repoContentHandler = new RepoContentHandler()\n    const codeCheckHandler = new CodeCheckHandler(this.codeCheckService)\n\n    repoExistenceHandler\n      .setNext(userAuthorizationHandler)\n      .setNext(repoStatusHandler)\n      .setNext(repoContentHandler)\n      .setNext(codeCheckHandler)\n\n    return repoExistenceHandler\n  }\n\n  private createSubmitCodeCheckChain(): RepoCheckHandler {\n    const repoExistenceHandler = new RepoExistenceHandler()\n    const userAuthorizationHandler = new UserAuthorizationHandler()\n    const repoContentHandler = new RepoContentHandler()\n    const codeCheckHandler = new CodeCheckHandler(this.codeCheckService)\n    const codeQualityHandler = new CodeQualityHandler()\n\n    repoExistenceHandler\n      .setNext(userAuthorizationHandler)\n      .setNext(repoContentHandler)\n      .setNext(codeCheckHandler)\n      .setNext(codeQualityHandler)\n\n    return repoExistenceHandler\n  }\n\n  public async createRepo(\n    data: CreateRepoData & { userId: string }\n  ): Promise<CodeRepo> {\n    const { userId, tags, ...repoData } = data\n\n    // Validate the input data\n    return await prisma.$transaction(async (tx) => {\n      // Check if the user already has a repo with the same name\n      const existingRepo = await tx.codeRepo.findFirst({\n        where: {\n          userId: userId,\n          name: repoData.name,\n          deletedAt: null // Ensure we don't count deleted repos\n        }\n      })\n\n      if (existingRepo) {\n        throw new Error(`You already have a repo named \"${repoData.name}\"`)\n      }\n\n      // If no existing repo with the same name, create the new repo\n      const repo = await tx.codeRepo.create({\n        data: {\n          ...repoData,\n          userId,\n          tags: {\n            create: tags.map((tagName) => ({\n              tag: {\n                connectOrCreate: {\n                  where: { name: tagName },\n                  create: { name: tagName },\n                },\n              },\n            })),\n          },\n        },\n        include: { tags: true },\n      })\n\n      return repo\n    })\n  }\n\n public async getRepoById(id: string, _userId?: string | null): Promise<CodeRepo | null> {\n    const repo = await prisma.codeRepo.findUnique({\n      where: {\n        id,\n        deletedAt: null // Only return non-deleted repos\n      },\n      include: {\n        tags: true, // Include tags to match the test expectations\n      }\n    })\n    return repo\n  }\n\n  public async updateRepo(\n    id: string,\n    data: Partial<CodeRepo> & { tags?: string[] }\n  ): Promise<CodeRepo> {\n    const { tags, ...otherData } = data\n\n    const updatedRepo = await prisma.codeRepo.update({\n      where: { id },\n      data: {\n        ...otherData,\n        tags: tags\n          ? {\n              deleteMany: {},\n              create: tags.map((tagName) => ({\n                tag: {\n                  connectOrCreate: {\n                    where: { name: tagName },\n                    create: { name: tagName },\n                  },\n                },\n              })),\n            }\n          : undefined,\n      },\n      include: { tags: { include: { tag: true } } },\n    })\n\n    return updatedRepo\n  }\n\n  /**\n   * @getRepoByIdPublic\n   * @description Get a public repo by ID, excluding soft deleted repos.\n   * @param id - The ID of the Repo to retrieve.\n   * @returns Promise<PartialCodeRepo | null> - The partial CodeRepo object or null if not found.\n   */\n  public async getRepoByIdPublic(id: string): Promise<PartialCodeRepo | null> {\n    const repo = await prisma.codeRepo.findFirst({\n      where: {\n        id,\n        deletedAt: null,\n        visibility: 'public'\n      },\n      select: {\n        id: true,\n        name: true,\n        description: true,\n        language: true,\n        price: true,\n        visibility: true,\n        status: true,\n        createdAt: true,\n        updatedAt: true,\n        deletedAt: true,\n        tags: {\n          select: {\n            tag: true\n          }\n        }\n      }\n    })\n\n    if (!repo) return null\n\n    return repo;\n  }\n\n\n  /**\n   * Check if a user has purchased a repo.\n   *\n   * @param userId - The ID of the user.\n   * @param repoId - The ID of the repo.\n   * @returns Promise<boolean> - True if the user has purchased the repo, false otherwise.\n   */\n  private async hasPurchased(userId: string, repoId: string): Promise<boolean> {\n    const count = await prisma.order.count({\n      where: {\n        userId,\n        codeRepoId: repoId,\n        status: 'completed' as OrderStatus,\n      },\n    })\n    return count > 0\n  }\n  /**\n   * @softDeleteRepo\n   * @description Soft delete a Repo by ID by setting the deletedAt timestamp.\n   * @param id - The ID of the Repo to soft delete.\n   * @returns Promise<CodeRepo> - The soft deleted CodeRepo object.\n   * @throws Error if the repo is not found or if the operation fails.\n   */\n  public async softDeleteRepo(id: string): Promise<CodeRepo> {\n    return await prisma.$transaction(async (tx) => {\n      const repo = await tx.codeRepo.findUnique({ where: { id } })\n      if (!repo) {\n        throw new Error('Repo not found')\n      }\n\n      // Always update the repo, even if it's already deleted\n      const softDeletedRepo = await tx.codeRepo.update({\n        where: { id },\n        data: {\n          deletedAt: new Date(),\n          visibility: 'private'\n        },\n      })\n      return softDeletedRepo\n    })\n  }\n\n  /**\n   * @publishRepo\n   * @description Publish a repo by updating its status to active, performing necessary checks, and running a code check.\n   * @param data - Object containing repo id and user id.\n   * @returns Promise<CodeRepo> - The updated CodeRepo.\n   * @throws Error if the repo is not found, user is not authorized, or if the operation fails.\n   */\n public async publishRepo(data: z.infer<typeof publishRepoSchema>): Promise<CodeRepo> {\n    const { id, userId } = publishRepoSchema.parse(data)\n\n    const repo = await prisma.codeRepo.findUnique({\n      where: { id },\n      include: { user: true }\n    })\n\n    if (!repo) {\n      throw new Error('Repo not found')\n    }\n\n    const context: RepoCheckContext = { repo, userId }\n    const chain = this.createPublishChain()\n\n    try {\n      await chain.handle(context)\n    } catch (error) {\n      throw new Error(`Failed to publish repo: ${error.message}`)\n    }\n\n    return await prisma.$transaction(async (tx) => {\n      const updatedRepo = await tx.codeRepo.update({\n        where: { id },\n        data: {\n          status: CodeRepoStatus.active,\n          visibility: Visibility.public,\n          updatedAt: new Date()\n        }\n      })\n\n      await tx.codeCheck.create({\n        data: {\n          repoId: id,\n          ...context.codeCheckResult!\n        }\n      })\n\n      return updatedRepo\n    })\n  }\n\n  public async submitCodeCheck(repoId: string, userId: string): Promise<CodeRepo> {\n    const repo = await prisma.codeRepo.findUnique({\n      where: { id: repoId },\n      include: { user: true }\n    })\n\n    if (!repo) {\n      throw new Error('Repo not found')\n    }\n\n    const context: RepoCheckContext = { repo, userId }\n    const chain = this.createSubmitCodeCheckChain()\n\n    try {\n      await chain.handle(context)\n    } catch (error) {\n      throw new Error(`Failed to submit code check: ${error.message}`)\n    }\n\n    return await prisma.$transaction(async (tx) => {\n      const updatedRepo = await tx.codeRepo.update({\n        where: { id: repoId },\n        data: {\n          status: CodeRepoStatus.active,\n          visibility: Visibility.public,\n          updatedAt: new Date()\n        }\n      })\n\n      await tx.codeCheck.create({\n        data: {\n          repoId: repoId,\n          ...context.codeCheckResult!\n        }\n      })\n\n      return updatedRepo\n    })\n  }\n\n  /**\n   * Retrieve paginated Repos with public visibility.\n   *\n   * @param page - The page number for pagination.\n   * @param limit - The number of items per page.\n   * @param userId - The ID of the user requesting the pagination (can be null for guests).\n   * @returns Promise<{ data: PartialCodeRepo[]; total: number; page: number; limit: number }> - Paginated results.\n   */\n\n  public async getPaginatedRepos(\n    page: number = 1,\n    limit: number = 10,\n    userId: string | null\n  ): Promise<{ data: PartialCodeRepo[]; total: number; page: number; limit: number }> {\n    const offset = (page - 1) * limit\n\n    let query = kyselyDb\n      .selectFrom('CodeRepo as cr')\n      .leftJoin('TagsOnRepos as tor', 'cr.id', 'tor.codeRepoId')\n      .leftJoin('Tag as t', 'tor.tagId', 't.id')\n      .selectAll('cr')\n      .select('t.name as tagName')\n      .where('cr.visibility', '=', 'public')\n      .where('cr.status', '=', 'active')\n      .distinctOn('cr.id')\n      .limit(limit)\n      .offset(offset)\n\n    if (userId) {\n      // Fetch user's recent search tags\n      const recentTags = await prisma.searchHistory.findMany({\n        where: { userId },\n        orderBy: { createdAt: 'desc' },\n        take: 10, // Adjust as needed\n      })\n\n      const recentTagNames = recentTags.map((tag) => tag.tag)\n\n      // Prioritize repos that match recent search tags\n      query = query\n        .orderBy(\n          sql`CASE WHEN t.name IN (${recentTagNames.map((tag) => `'${tag}'`).join(', ')}) THEN 1 ELSE 2 END`\n        )\n        .orderBy('cr.createdAt', 'desc')\n    }\n\n    const repos = await query.execute()\n    const total = await prisma.codeRepo.count({\n      where: {\n        visibility: 'public',\n        status: 'active',\n      },\n    })\n\n    // Filter out source code for unauthorized users\n    const filteredRepos = await Promise.all(\n      repos.map(async (repo) => {\n        const partialRepo: PartialCodeRepo = { ...repo }\n        if (userId) {\n          const user = await prisma.user.findUnique({ where: { id: userId } })\n          const hasAccess =\n            repo.userId === userId ||\n            user?.role === 'ADMIN' ||\n            (await this.hasPurchased(userId, repo.id))\n\n          if (!hasAccess) {\n            delete partialRepo.sourceJs\n            delete partialRepo.sourceCss\n          }\n        } else {\n          delete partialRepo.sourceJs\n          delete partialRepo.sourceCss\n        }\n        return partialRepo\n      })\n    )\n\n    return { data: filteredRepos, total, page, limit }\n  }\n\n  /**\n   * Record search tag for a user.\n   *\n   * @param userId - The ID of the user.\n   * @param tag - The searched tag.\n   */\n  public async recordSearch(userId: string, tag: string): Promise<void> {\n    await prisma.searchHistory.create({\n      data: {\n        userId,\n        tag,\n      },\n    })\n  }\n\n/**\n * Retrieve Repos by user ID.\n *\n * @param userId - The user ID to filter by.\n * @returns Promise<CodeRepo[]> - Array of CodeRepo objects belonging to the user.\n */\n  public async getReposByUser(userId: string): Promise<CodeRepo[]> {\n  try {\n    const repos = await prisma.codeRepo.findMany({\n      where: {\n        userId: userId,\n        deletedAt: null // Only return non-deleted repos\n      },\n      include: {\n        tags: true // Include tags to match the previous implementation\n      }\n    })\n    return repos\n  } catch (error) {\n    console.error('Error fetching repos by user:', error)\n    throw new Error('Failed to fetch repos by user')\n  }\n}\n\n  public async getFeaturedRepos(limit: number = 5): Promise<CodeRepo[]> {\n    const featuredRepos = await prisma.codeRepo.findMany({\n      where: {\n        visibility: 'public',\n        status: 'active',\n        deletedAt: null,\n      },\n      include: {\n        reviews: true,\n        user: {\n          select: {\n            id: true,\n            email: true,\n            profile: true,\n          },\n        },\n      },\n      orderBy: [{ reviews: { _count: 'desc' } }, { updatedAt: 'desc' }],\n      take: limit,\n    })\n\n    // Calculate average rating for each repo\n    const reposWithRatings = featuredRepos.map((repo) => {\n      const avgRating =\n        repo.reviews.reduce((sum, review) => sum + review.rating, 0) / repo.reviews.length || 0\n      return { ...repo, avgRating }\n    })\n\n    // Sort by average rating and then by number of reviews\n    return reposWithRatings.sort(\n      (a, b) => b.avgRating - a.avgRating || b.reviews.length - a.reviews.length\n    )\n  }\n\n  /**\n   * Get a repo by its ID, including necessary related data for checkout.\n   *\n   * @param id - The ID of the repo.\n   * @returns Promise<RepoCheckoutInfo | null> - The repo data and seller info, or null if not found.\n   */\n  public async getRepoForCheckout(id: string): Promise<RepoCheckoutInfo | null> {\n    const repo = await prisma.codeRepo.findUnique({\n      where: { id },\n      include: {\n        user: {\n          select: {\n            sellerProfile: {\n              select: {\n                id: true,\n              },\n            },\n          },\n        },\n      },\n    })\n\n    if (!repo) return null\n\n    const { sourceJs, sourceCss, user, ...safeRepo } = repo\n    return {\n      repo: safeRepo,\n      sellerProfileId: user?.sellerProfile?.id ?? null,\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\review_service.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport type { Review, Vote, VoteType } from '@prisma/client'\nimport logger from '@adonisjs/core/services/logger'\n\ninterface ReviewCreationData {\n  content: string\n  userId: string\n  repoId: string\n  rating: number\n}\n\ninterface ReviewUpdateData {\n  content?: string\n  rating?: number\n}\n\nexport class ReviewService {\n  /**\n   * Create a new review.\n   * @param data - The data to create a review.\n   * @returns The created review.\n   */\n  async createReview(data: ReviewCreationData): Promise<Review> {\n    return prisma.review.create({\n      data,\n    })\n  }\n\n  async getPaginatedReviewsByRepo(\n    repoId: string,\n    page: number,\n    perPage: number\n  ): Promise<{\n    data: Review[]\n    meta: {\n      total: number\n      page: number\n      perPage: number\n      lastPage: number\n    }\n  }> {\n    const reviews = await prisma.review.findMany({\n      where: { repoId, deletedAt: null },\n      skip: (page - 1) * perPage,\n      take: perPage,\n      include: {\n        user: {\n          select: {\n            id: true,\n            email: true,\n            profile: {\n              select: {\n                name: true,\n                profileImg: true,\n              },\n            },\n          },\n        },\n      },\n    })\n    const total = await prisma.review.count({\n      where: { repoId, deletedAt: null },\n    })\n    return {\n      data: reviews,\n      meta: {\n        total,\n        page,\n        perPage,\n        lastPage: Math.ceil(total / perPage),\n      },\n    }\n  }\n\n  /**\n   * Retrieve a review by ID.\n   * @param id - The ID of the review to retrieve.\n   * @returns The retrieved review.\n   */\n  async getReviewById(id: string): Promise<Review | null> {\n    return prisma.review.findUnique({ where: { id, deletedAt: null } })\n  }\n\n  /**\n   * Update a review by ID.\n   * @param id - The ID of the review to update.\n   * @param data - The data to update the review.\n   * @returns The updated review.\n   */\n  async updateReview(id: string, data: ReviewUpdateData): Promise<Review> {\n    return prisma.review.update({ where: { id, deletedAt: null }, data })\n  }\n\n  /**\n   * Soft delete a review by ID.\n   * @param id - The ID of the review to delete.\n   * @returns The deleted review.\n   */\n  async deleteReview(id: string): Promise<Review> {\n    return prisma.review.update({\n      where: { id },\n      data: { deletedAt: new Date() },\n    })\n  }\n\n  /**\n   * Retrieve all flagged reviews.\n   * @returns All flagged reviews.\n   */\n  async getAllFlaggedReviews(): Promise<Review[]> {\n    const reviews = await prisma.review.findMany({\n      where: { deletedAt: null, flag: { not: 'NONE' } },\n      include: { user: true },\n    })\n\n    return reviews.map((r) => ({\n      ...r,\n      user: {\n        email: r.user.email,\n      },\n    }))\n  }\n\n  async revertFlag(id: string): Promise<Review> {\n    return prisma.review.update({\n      where: { id },\n      data: { flag: 'NONE' },\n    })\n  }\n\n  /**\n   * Handle voting on a review.\n   * @param reviewId - The ID of the review to vote on.\n   * @param userId - The ID of the user voting.\n   * @param voteType - The type of vote (UPVOTE or DOWNVOTE).\n   * @returns The updated review.\n   */\n  async handleVote(reviewId: string, userId: string, voteType: VoteType): Promise<Review> {\n    const existingVote = await prisma.vote.findUnique({\n      where: {\n        userId_reviewId: {\n          userId,\n          reviewId,\n        },\n      },\n    })\n\n    return prisma.$transaction(async (tx) => {\n      if (!existingVote) {\n        await tx.vote.create({\n          data: {\n            userId,\n            reviewId,\n            type: voteType,\n          },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { increment: 1 },\n          },\n        })\n      } else if (existingVote.type !== voteType) {\n        await tx.vote.update({\n          where: { id: existingVote.id },\n          data: { type: voteType },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { increment: 1 },\n            [voteType === 'UPVOTE' ? 'downvotes' : 'upvotes']: { decrement: 1 },\n          },\n        })\n      } else {\n        await tx.vote.delete({\n          where: { id: existingVote.id },\n        })\n        return tx.review.update({\n          where: { id: reviewId },\n          data: {\n            [voteType === 'UPVOTE' ? 'upvotes' : 'downvotes']: { decrement: 1 },\n          },\n        })\n      }\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\sales_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport { Prisma } from '@prisma/client'\n\n@inject()\nexport default class SalesService {\n  async updateSalesAggregate(sellerId: string, amount: number, tx?: Prisma.TransactionClient) {\n    const db = tx || prisma\n    const today = new Date()\n    today.setHours(0, 0, 0, 0)\n\n    const existingAggregate = await db.salesAggregate.findUnique({\n      where: {\n        sellerId_date: {\n          sellerId,\n          date: today,\n        },\n      },\n    })\n\n    if (existingAggregate) {\n      return await db.salesAggregate.update({\n        where: { id: existingAggregate.id },\n        data: {\n          revenue: { increment: amount },\n          salesCount: { increment: 1 },\n        },\n      })\n    } else {\n      return await db.salesAggregate.create({\n        data: {\n          sellerId,\n          date: today,\n          revenue: amount,\n          salesCount: 1,\n        },\n      })\n    }\n  }\n\n  async getSalesAggregate(sellerId: string, startDate: Date, endDate: Date) {\n    return await prisma.salesAggregate.findMany({\n      where: {\n        sellerId,\n        date: {\n          gte: startDate,\n          lte: endDate,\n        },\n      },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\seller_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport {\n  SellerProfile,\n  //User,\n  SellerVerificationStatus,\n  PayoutRequest,\n  PayoutRequestStatus,\n} from '@prisma/client'\nimport { PrismaTransactionalClient, prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\nimport {\n  createSellerProfileSchema,\n  updateSellerProfileSchema,\n  createPayoutRequestSchema,\n  UpdateSellerProfileDto,\n} from '#validators/seller'\nimport { S3Facade } from '#integrations/s3/s3_facade'\n\ninterface SalesDataPoint {\n  date: string\n  revenue: number\n  salesCount: number\n}\n\ninterface RecentReview {\n  id: string\n  content: string\n  rating: number\n  createdAt: Date\n  repoName: string\n  userName: string\n}\n\ninterface DashboardData {\n  salesData: SalesDataPoint[]\n  recentReviews: RecentReview[]\n}\nimport logger from '@adonisjs/core/services/logger'\n\n@inject()\nexport default class SellerService {\n  constructor(protected s3Facade: S3Facade) {}\n  /**\n   * Apply for a seller account\n   * @param userId - The ID of the user applying to be a seller\n   * @param profileData - The seller profile and bank account data\n   */\n  public async applyForSellerAccount(userId: string, profileData: any): Promise<SellerProfile> {\n    const validatedData = createSellerProfileSchema.parse(profileData)\n\n    return await prisma.$transaction(async (trx) => {\n      // Update the existing seller profile\n      const updatedProfile = await trx.sellerProfile.update({\n        where: { userId },\n        data: {\n          businessName: validatedData.businessName,\n          businessAddress: validatedData.businessAddress,\n          businessPhone: validatedData.businessPhone,\n          businessEmail: validatedData.businessEmail,\n          verificationStatus: SellerVerificationStatus.PENDING,\n        },\n      })\n\n      // Create or update the bank account\n      await trx.bankAccount.upsert({\n        where: { sellerProfileId: updatedProfile.id },\n        create: {\n          sellerProfileId: updatedProfile.id,\n          accountHolderName: validatedData.accountHolderName,\n          accountNumber: validatedData.accountNumber,\n          bankName: validatedData.bankName,\n          swiftCode: validatedData.swiftCode,\n          iban: validatedData.iban,\n          routingNumber: validatedData.routingNumber,\n        },\n        update: {\n          accountHolderName: validatedData.accountHolderName,\n          accountNumber: validatedData.accountNumber,\n          bankName: validatedData.bankName,\n          swiftCode: validatedData.swiftCode,\n          iban: validatedData.iban,\n          routingNumber: validatedData.routingNumber,\n        },\n      })\n\n      return updatedProfile\n    })\n  }\n\n  /**\n   * Get a seller's profile\n   * @param userId - The ID of the user or seller\n   */\n  public async getSellerProfile(userId: string): Promise<SellerProfile | null> {\n    return await prisma.sellerProfile.findUnique({\n      where: { userId },\n    })\n  }\n\n  /**\n   * Update a seller's profile including bank account details and verification status\n   * @param userId - The ID of the user or seller\n   * @param profileData - The updated profile data\n   */\n  public async updateSellerProfile(\n    userId: string,\n    profileData: UpdateSellerProfileDto\n  ): Promise<SellerProfile> {\n    const validatedData = updateSellerProfileSchema.parse(profileData)\n    const user = await prisma.user.findUnique({ where: { id: userId } })\n    if (!user) {\n      throw new Error('User not found')\n    }\n    try {\n      const updatedProfile = await prisma.sellerProfile.update({\n        where: { userId: user.id },\n        data: {\n          ...(validatedData.businessName && { businessName: validatedData.businessName }),\n          ...(validatedData.businessAddress && { businessAddress: validatedData.businessAddress }),\n          ...(validatedData.businessPhone && { businessPhone: validatedData.businessPhone }),\n          ...(validatedData.businessEmail && { businessEmail: validatedData.businessEmail }),\n          ...(validatedData.verificationStatus && {\n            verificationStatus: validatedData.verificationStatus,\n            ...(validatedData.verificationStatus === 'APPROVED' && {\n              verificationDate: new Date(),\n            }),\n          }),\n          bankAccount: {\n            upsert: {\n              create: {\n                accountHolderName: validatedData.accountHolderName || '',\n                accountNumber: validatedData.accountNumber || '',\n                bankName: validatedData.bankName || '',\n                swiftCode: validatedData.swiftCode || '',\n                iban: validatedData.iban,\n                routingNumber: validatedData.routingNumber,\n              },\n              update: {\n                ...(validatedData.accountHolderName && {\n                  accountHolderName: validatedData.accountHolderName,\n                }),\n                ...(validatedData.accountNumber && { accountNumber: validatedData.accountNumber }),\n                ...(validatedData.bankName && { bankName: validatedData.bankName }),\n                ...(validatedData.swiftCode && { swiftCode: validatedData.swiftCode }),\n                ...(validatedData.iban && { iban: validatedData.iban }),\n                ...(validatedData.routingNumber && { routingNumber: validatedData.routingNumber }),\n              },\n            },\n          },\n        },\n        include: { bankAccount: true },\n      })\n      return updatedProfile\n    } catch (error) {\n      throw new Error(`Failed to update seller profile: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get all seller applications\n   * @param status - Optional filter for verification status\n   */\n  public async getSellerApplications(status?: SellerVerificationStatus): Promise<SellerProfile[]> {\n    return await prisma.sellerProfile.findMany({\n      where: status ? { verificationStatus: status } : undefined,\n      include: { user: true },\n    })\n  }\n\n  /**\n   * Update seller application status\n   * @param sellerId - The ID of the seller profile\n   * @param status - The new verification status\n   */\n  public async updateSellerApplicationStatus(\n    sellerId: string,\n    status: SellerVerificationStatus\n  ): Promise<SellerProfile> {\n    return await prisma.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        verificationStatus: status,\n        verificationDate: status === SellerVerificationStatus.APPROVED ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Get seller's balance\n   * @param userId - The ID of the user or seller\n   */\n  public async getSellerBalance(userId: string): Promise<number> {\n    const profile = await this.getSellerProfile(userId)\n    return profile?.balance ?? 0\n  }\n\n  /**\n   * Request a payout\n   * @param userId - The ID of the user or seller\n   * @param amount - The amount to request for payout\n   */\n  public async requestPayout(userId: string, amount: number): Promise<PayoutRequest> {\n    const validatedData = createPayoutRequestSchema.parse({ amount })\n\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n    if (profile.balance < amount) throw new Error('Insufficient balance')\n\n    return await prisma.payoutRequest.create({\n      data: {\n        sellerProfileId: profile.id,\n        totalAmount: validatedData.amount,\n        status: PayoutRequestStatus.PENDING,\n      },\n    })\n  }\n\n  /**\n   * Get payout history for a seller\n   * @param userId - The ID of the user or seller\n   */\n  public async getPayoutHistory(userId: string): Promise<PayoutRequest[]> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n\n    return await prisma.payoutRequest.findMany({\n      where: { sellerProfileId: profile.id },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Upload or update identity document\n   * @param userId - The ID of the user or seller\n   * @param documentUrl - The URL of the uploaded document\n   */\n  //public async uploadIdentityDocument(userId: string, documentUrl: string): Promise<SellerProfile> {\n  //  return await prisma.sellerProfile.update({\n  //    where: { userId },\n  //    data: {\n  //      identityDoc: documentUrl,\n  //      verificationStatus: SellerVerificationStatus.PENDING,\n  //    },\n  //  })\n  //}\n\n  /**\n   * Verify seller's identity document\n   * @param sellerId - The ID of the seller profile\n   * @param isVerified - Whether the document is verified\n   */\n  public async verifySellerDocument(sellerId: string, isVerified: boolean): Promise<SellerProfile> {\n    return await prisma.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        verificationStatus: isVerified\n          ? SellerVerificationStatus.APPROVED\n          : SellerVerificationStatus.REJECTED,\n        verificationDate: isVerified ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Get all payout requests\n   * @param status - Optional filter for payout request status\n   */\n  public async getPayoutRequests(status?: PayoutRequestStatus): Promise<PayoutRequest[]> {\n    return await prisma.payoutRequest.findMany({\n      where: status ? { status } : undefined,\n      include: { sellerProfile: true },\n      orderBy: { createdAt: 'desc' },\n    })\n  }\n\n  /**\n   * Update payout request status\n   * @param requestId - The ID of the payout request\n   * @param status - The new status of the payout request\n   */\n  public async updatePayoutRequestStatus(\n    requestId: string,\n    status: PayoutRequestStatus\n  ): Promise<PayoutRequest> {\n    return await prisma.payoutRequest.update({\n      where: { id: requestId },\n      data: {\n        status,\n        processedAt: status === PayoutRequestStatus.PROCESSED ? new Date() : null,\n      },\n    })\n  }\n\n  /**\n   * Upload identity document for a seller\n   * @param userId - The ID of the user or seller\n   * @param file - The PDF file to upload\n   */\n  public async uploadIdentityDocument(userId: string, file: Buffer): Promise<SellerProfile> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile) throw new Error('Seller profile not found')\n\n    try {\n      const { media } = await this.s3Facade.uploadFile(\n        file,\n        'application/pdf',\n        prisma,\n        'identity-documents'\n      )\n\n      return await prisma.sellerProfile.update({\n        where: { userId },\n        data: {\n          identityDoc: media.url,\n          verificationStatus: SellerVerificationStatus.PENDING,\n        },\n      })\n    } catch (error) {\n      throw new Error(`Failed to upload identity document: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get the signed URL for a seller's identity document\n   * @param userId - The ID of the user or seller\n   */\n  public async getIdentityDocumentUrl(userId: string): Promise<string | null> {\n    const profile = await this.getSellerProfile(userId)\n    if (!profile || !profile.identityDoc) return null\n\n    const fileKey = profile.identityDoc.split('/').pop()\n    if (!fileKey) return null\n\n    try {\n      return await this.s3Facade.getSignedUrl(fileKey)\n    } catch (error) {\n      throw new Error(`Failed to get signed URL: ${error.message}`)\n    }\n  }\n\n  /**\n   * Get dashboard data including sales analytics and recent reviews\n   * @param userId - The ID of the user or seller\n   * @param days - Number of days to fetch sales data for (default: 30)\n   */\n  public async getDashboardData(userId: string, days: number = 180): Promise<DashboardData> {\n    const endDate = DateTime.now().endOf('day')\n    const startDate = endDate.minus({ days: days - 1 }).startOf('day')\n\n    // Fetch sales data\n    const salesData = await prisma.salesAggregate.findMany({\n      where: {\n        sellerId: userId,\n        date: {\n          gte: startDate.toJSDate(),\n          lte: endDate.toJSDate(),\n        },\n      },\n      orderBy: { date: 'asc' },\n    })\n\n    // Fill in missing dates with zero values\n    const filledSalesData: SalesDataPoint[] = []\n    let currentDate = startDate\n    while (currentDate <= endDate) {\n      const existingData = salesData.find((d) =>\n        DateTime.fromJSDate(d.date).hasSame(currentDate, 'day')\n      )\n      filledSalesData.push({\n        date: currentDate.toFormat('yyyy-MM-dd'),\n        revenue: existingData?.revenue ?? 0,\n        salesCount: existingData?.salesCount ?? 0,\n      })\n      currentDate = currentDate.plus({ days: 1 })\n    }\n\n    // Fetch recent reviews\n    const recentReviews = await prisma.review.findMany({\n      where: {\n        repo: {\n          userId: userId,\n        },\n      },\n      orderBy: { createdAt: 'desc' },\n      take: 5,\n      include: {\n        repo: {\n          select: { name: true },\n        },\n        user: {\n          select: { email: true },\n        },\n      },\n    })\n\n    const formattedReviews: RecentReview[] = recentReviews.map((review) => ({\n      id: review.id,\n      content: review.content,\n      rating: review.rating,\n      createdAt: review.createdAt,\n      repoName: review.repo.name,\n      userName: review.user.email, // Using email as userName for privacy\n    }))\n\n    return {\n      salesData: filledSalesData,\n      recentReviews: formattedReviews,\n    }\n  }\n\n  public async checkIfSellerVerified(userId: string): Promise<boolean> {\n    const profile = await this.getSellerProfile(userId)\n    return profile?.verificationStatus === SellerVerificationStatus.APPROVED\n  }\n\n  public async updateBalance(sellerId: string, amount: number, tx?: PrismaTransactionalClient) {\n    const db = tx || prisma\n\n    return await db.sellerProfile.update({\n      where: { id: sellerId },\n      data: {\n        balance: {\n          increment: amount,\n        },\n      },\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\support_service.ts</source>
<document_content>import { SupportTicketType, SupportTicketStatus } from '@prisma/client'\nimport { prisma } from './prisma_service.js'\nimport { kyselyDb } from '#database/kysely'\nimport { z } from 'zod'\nimport mail from '@adonisjs/mail/services/main'\nimport { render } from '@react-email/components'\nimport env from '#start/env'\nimport KortexSupportTicketReceived from '#resources/mail-templates/support-received.mail'\n\nexport const ticketSchema = z.object({\n  id: z.string().cuid(),\n  email: z.string().email(),\n  title: z.string().min(1),\n  content: z.string().min(1),\n  status: z.nativeEnum(SupportTicketStatus),\n  type: z.nativeEnum(SupportTicketType),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n})\n\nexport const newTicketSchema = z.object({\n  email: z.string().email(),\n  title: z.string().min(1),\n  content: z.string().min(1),\n  type: z.nativeEnum(SupportTicketType),\n})\n\n/**\n * Service class for handling support ticket operations.\n */\nexport default class SupportTicketService {\n  /**\n   * Creates a new support ticket.\n   *\n   * @param email - The email address of the user.\n   * @param title - The title of the support ticket.\n   * @param content - The content of the support ticket.\n   * @param type - The type of the support ticket.\n   * @returns The created support ticket.\n   */\n  public async createTicket(\n    email: string,\n    title: string,\n    content: string,\n    type: SupportTicketType\n  ) {\n    const validatedData = newTicketSchema.parse({ email, title, content, type })\n\n    try {\n      const ticket = await prisma.supportTicket.create({\n        data: validatedData,\n      })\n      return ticket\n    } catch (error: any) {\n      throw new Error(`Failed to create ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves paginated support tickets.\n   *\n   * @param page - The page number for pagination.\n   * @param limit - The number of tickets per page.\n   * @returns An object containing the tickets and pagination metadata.\n   */\n  //public async getPaginatedTickets(page: number = 1, limit: number = 10) {\n  //  const offset = (page - 1) * limit\n  //  try {\n  //    const [tickets, total] = await Promise.all([\n  //      prisma.supportTicket.findMany({\n  //        skip: offset,\n  //        take: limit,\n  //        orderBy: { createdAt: 'desc' },\n  //      }),\n  //      prisma.supportTicket.count(),\n  //    ])\n  //\n  //    return {\n  //      data: tickets,\n  //      meta: {\n  //        total,\n  //        page,\n  //        limit,\n  //        lastPage: Math.ceil(total / limit),\n  //      },\n  //    }\n  //  } catch (error: any) {\n  //    throw new Error(`Failed to retrieve paginated tickets: ${error.message}`)\n  //  }\n  //}\n\n  /**\n   * Retrieves all support tickets.\n   *\n   * @returns An array of all support tickets.\n   */\n  public async getAllTickets() {\n    try {\n      return await prisma.supportTicket.findMany({\n        orderBy: { createdAt: 'desc' },\n      })\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve all tickets: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves a support ticket by its ID.\n   *\n   * @param id - The ID of the support ticket.\n   * @returns The support ticket or null if not found.\n   */\n  public async getTicketById(id: string) {\n    try {\n      return await prisma.supportTicket.findUnique({ where: { id } })\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by title using full text search.\n   *\n   * @param title - The title to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByTitle(title: string) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('title', 'ilike', `%${title}%`)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by title: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by email.\n   *\n   * @param email - The email address to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByEmail(email: string) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('email', '=', email)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by email: ${error.message}`)\n    }\n  }\n\n  /**\n   * Retrieves support tickets by status.\n   *\n   * @param status - The status to search for.\n   * @returns An array of matching support tickets.\n   */\n  public async getTicketsByStatus(status: SupportTicketStatus) {\n    try {\n      const result = await kyselyDb\n        .selectFrom('SupportTicket')\n        .selectAll()\n        .where('status', '=', status)\n        .execute()\n\n      return result\n    } catch (error: any) {\n      throw new Error(`Failed to retrieve tickets by status: ${error.message}`)\n    }\n  }\n\n  /**\n   * Updates the status of a support ticket.\n   *\n   * @param id - The ID of the support ticket.\n   * @param status - The new status of the support ticket.\n   * @returns The updated support ticket or null if not found.\n   */\n  public async updateTicket(id: string, status: SupportTicketStatus) {\n    try {\n      return await prisma.supportTicket.update({\n        where: { id },\n        data: { status },\n      })\n    } catch (error: any) {\n      if (error.code === 'P2025') {\n        return null\n      }\n      throw new Error(`Failed to update ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Deletes a support ticket.\n   *\n   * @param id - The ID of the support ticket to delete.\n   * @returns True if the ticket was deleted, false if not found.\n   */\n  public async deleteTicket(id: string) {\n    try {\n      await prisma.supportTicket.delete({\n        where: { id },\n      })\n      return true\n    } catch (error: any) {\n      if (error.code === 'P2025') {\n        return false\n      }\n      throw new Error(`Failed to delete ticket: ${error.message}`)\n    }\n  }\n\n  /**\n   * Sends a default email notification.\n   *\n   * @param email - The email address to send the notification to.\n   */\n  public async sendDefaultEmail(email: string) {\n    try {\n      await mail.send((message) => {\n        message\n          .to(email)\n          .from(env.get('SMTP_HOST') ?? '')\n          .subject('Support Ticket Received')\n          .html(render(KortexSupportTicketReceived()))\n      })\n\n      return {\n        success: true,\n        message: 'Email sent successfully',\n      }\n    } catch (error: any) {\n      throw new Error(`Failed to send email: ${error.message}`)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_dashboard_service.ts</source>
<document_content>import { inject } from '@adonisjs/core'\nimport { prisma } from '#services/prisma_service'\nimport RepoAccessService from '#services/repo_access_service'\nimport { OrderStatus } from '@prisma/client'\n\n@inject()\nexport default class UserDashboardService {\n  /**\n   * Get user dashboard data\n   * @param userId - The ID of the user\n   * @returns Promise<object> Dashboard data\n   */\n  public async getDashboardData(userId: string): Promise<object> {\n    try {\n      const [\n        purchaseHistory,\n        accountInfo,\n        usageStatistics,\n        recommendations,\n      ] = await Promise.all([\n        this.getPurchaseHistory(userId),\n        this.getAccountInfo(userId),\n        this.getUsageStatistics(userId),\n        this.getRecommendations(userId),\n      ])\n\n      return {\n        purchaseHistory,\n        accountInfo,\n        usageStatistics,\n        recommendations,\n      }\n    } catch (error) {\n      console.error('Error in getDashboardData:', error)\n      throw new Error('Failed to retrieve dashboard data')\n    }\n  }\n\n  private async getPurchaseHistory(userId: string) {\n    try {\n      const recentPurchases = await prisma.order.findMany({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        take: 5,\n        orderBy: { createdAt: 'desc' },\n        include: { codeRepo: { select: { name: true } } }\n      })\n\n      const totalSpent = await prisma.order.aggregate({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        _sum: { totalAmount: true }\n      })\n\n      const componentsBought = await prisma.order.count({\n        where: { userId, status: OrderStatus.SUCCEEDED }\n      })\n\n      return {\n        recentPurchases,\n        totalSpent: totalSpent._sum.totalAmount || 0,\n        componentsBought\n      }\n    } catch (error) {\n      console.error('Error in getPurchaseHistory:', error)\n      throw new Error('Failed to retrieve purchase history')\n    }\n  }\n\n  private async getAccountInfo(userId: string) {\n    try {\n      return await prisma.user.findUnique({\n        where: { id: userId },\n        select: {\n          email: true,\n          emailVerified: true,\n          profile: true,\n          createdAt: true\n        }\n      })\n    } catch (error) {\n      console.error('Error in getAccountInfo:', error)\n      throw new Error('Failed to retrieve account info')\n    }\n  }\n\n  private async getUsageStatistics(userId: string) {\n    try {\n      const frequentlyPurchased = await prisma.order.groupBy({\n        by: ['codeRepoId'],\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        _count: { codeRepoId: true },\n        orderBy: { _count: { codeRepoId: 'desc' } },\n        take: 5\n      })\n\n      const repoIds = frequentlyPurchased.map(fp => fp.codeRepoId)\n      const repoDetails = await prisma.codeRepo.findMany({\n        where: { id: { in: repoIds } },\n        select: { id: true, name: true }\n      })\n\n      return {\n        mostUsedComponents: frequentlyPurchased.map(fp => ({\n          ...repoDetails.find(rd => rd.id === fp.codeRepoId),\n          usageCount: fp._count.codeRepoId\n        }))\n      }\n    } catch (error) {\n      console.error('Error in getUsageStatistics:', error)\n      throw new Error('Failed to retrieve usage statistics')\n    }\n  }\n\n  private async getRecommendations(userId: string) {\n    try {\n      const userPurchases = await prisma.order.findMany({\n        where: { userId, status: OrderStatus.SUCCEEDED },\n        select: { codeRepoId: true }\n      })\n\n      const purchasedRepoIds = userPurchases.map(p => p.codeRepoId)\n\n      const popularComponents = await prisma.codeRepo.findMany({\n        where: {\n          id: { notIn: purchasedRepoIds },\n          status: 'active',\n          visibility: 'public'\n        },\n        orderBy: { orders: { _count: 'desc' } },\n        take: 5,\n        select: { id: true, name: true }\n      })\n\n      return { recommendations: popularComponents }\n    } catch (error) {\n      console.error('Error in getRecommendations:', error)\n      throw new Error('Failed to retrieve recommendations')\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_service.ts</source>
<document_content>// user_service.ts\nimport { prisma } from '#services/prisma_service'\nimport { hash } from '@node-rs/argon2'\nimport { UserFactory } from '../factories/user_factory.js'\nimport type { Role, SellerProfile, Profile } from '@prisma/client'\nimport type { User } from 'lucia'\n\ninterface UserCreationData {\n  email: string\n  password: string\n  fullname: string\n  role: Role\n}\n\ninterface UserProfileUpdateData {\n  email?: string\n  password?: string\n  fullname?: string\n  businessName?: string\n  businessAddress?: string\n  businessPhone?: string\n  businessEmail?: string\n}\n\n/**\n * Service class for managing users.\n */\nexport class UserService {\n  /**\n   * Creates a user with the specified role.\n   *\n   * @param {UserCreationData} data - The user creation data.\n   * @returns {Promise<User>} - The created user.\n   * @throws {Error} - If an invalid role is provided.\n   */\n  async createUser(data: UserCreationData): Promise<User> {\n    const { role, ...userData } = data\n    switch (role) {\n      case 'USER':\n        return (await UserFactory.createUser(userData)).user\n      case 'SELLER':\n        return (await UserFactory.createSeller(userData)).user\n      case 'MODERATOR':\n        return (await UserFactory.createModerator(userData)).user\n      case 'ADMIN':\n        return (await UserFactory.createAdmin(userData)).user\n      default:\n        throw new Error(`Invalid role: ${role}`)\n    }\n  }\n\n  /**\n   * Retrieves a user by their email.\n   *\n   * @param {string} email - The email of the user.\n   * @returns {Promise<User>} - The user.\n   * @throws {Error} - If the user is not found.\n   */\n  async getUserByEmail(email: string): Promise<User> {\n    const user = await prisma.user.findUnique({\n      where: { email, deletedAt: null },\n      include: {\n        profile: true,\n        sellerProfile: {\n          include: {\n            bankAccount: true,\n          },\n        },\n      },\n    })\n\n    if (!user) {\n      throw new Error(`User with email ${email} not found.`)\n    }\n\n    return user\n  }\n\n  /**\n   * Retrieves all users.\n   *\n   * @returns {Promise<User[]>} - All users.\n   */\n  async getAllUsers(): Promise<{ id: string; email: string; role: Role }[]> {\n    // only return the ncessary data\n    return prisma.user.findMany({\n      select: {\n        id: true,\n        email: true,\n        bannedUntil: true,\n        //fullname: true,\n        role: true,\n        sellerProfile: {\n          include: {\n            bankAccount: true,\n          },\n          //select: {\n          //  businessName: true,\n          //  businessAddress: true,\n          //  businessPhone: true,\n          //  businessEmail: true,\n          //  identityDoc: true,\n          //\n          //  bankAccount: true,\n          //  verificationStatus: true,\n          //},\n        },\n      },\n    })\n  }\n\n  /**\n   * Retrieves paginated users.\n   *\n   * @param {number} page - The page number.\n   * @param {number} pageSize - The number of users per page.\n   * @returns {Promise<{ users: User[], total: number }>} - The paginated users and total count.\n   */\n  async getPaginatedUsers(\n    page: number,\n    pageSize: number\n  ): Promise<{ users: User[]; total: number }> {\n    const [users, total] = await prisma.$transaction([\n      prisma.user.findMany({\n        where: { deletedAt: null },\n        skip: (page - 1) * pageSize,\n        take: pageSize,\n      }),\n      prisma.user.count({\n        where: { deletedAt: null },\n      }),\n    ])\n\n    return { users, total }\n  }\n\n  /*\n   * Retrieves a user by their ID.\n   *\n   * @param {string} id - The ID of the user.\n   * @returns {Promise<User>} - The user.\n   * @throws {Error} - If the user is not found.\n   *\n   */\n\n  async getUserProfileById(id: string): Promise<Profile | SellerProfile | null> {\n    const user = await prisma.user.findUnique({\n      where: { id },\n    })\n    if (!user) {\n      throw new Error(`User with id ${id} not found.`)\n    }\n\n    if (user.role === 'SELLER') {\n      const profile = await prisma.sellerProfile.findFirst({\n        where: { userId: id },\n      })\n\n      return profile\n    } else {\n      const profile = await prisma.profile.findFirst({\n        where: { userId: id },\n      })\n\n      return profile ?? null\n    }\n  }\n\n  /**\n   * Updates a user with the specified data.\n   *\n   * @param {string} email - The email of the user to update.\n   * @param {Partial<UserCreationData>} data - The data to update the user with.\n   * @returns {Promise<User>} - The updated user.\n   */\n  async updateUser(email: string, data: Partial<UserCreationData>): Promise<User> {\n    const user = await prisma.user.update({\n      where: { email, deletedAt: null },\n      data,\n    })\n\n    return user\n  }\n\n  /**\n   * Updates a user's profile based on their role.\n   *\n   * @param {string} email - The email of the user whose profile is to be updated.\n   * @param {UserProfileUpdateData} data - The profile data to update.\n   * @returns {Promise<User>} - The updated user.\n   * @throws {Error} - If the user is not found or the role is invalid.\n   */\n  async updateUserProfile(email: string, data: UserProfileUpdateData): Promise<User> {\n    const user = await this.getUserByEmail(email)\n\n    switch (user.role) {\n      case 'USER':\n      case 'MODERATOR':\n      case 'ADMIN':\n        const updatedUser = await prisma.user.update({\n          where: { email },\n          data: { passwordHash: data.password ? await hash(data.password) : undefined },\n        })\n\n        await prisma.profile.update({\n          where: { userId: user.id },\n          data: { name: data.fullname },\n        })\n\n        return updatedUser\n\n      case 'SELLER':\n        await prisma.sellerProfile.update({\n          where: { userId: user.id },\n          data: {\n            businessName: data.businessName,\n            businessAddress: data.businessAddress,\n            businessPhone: data.businessPhone,\n            businessEmail: data.businessEmail,\n          },\n        })\n\n        return user\n\n      default:\n        throw new Error(`Invalid role: ${user.role}`)\n    }\n  }\n\n  /**\n   * Soft deletes a user by their email.\n   *\n   * @param {string} email - The email of the user to soft delete.\n   * @returns {Promise<User>} - The soft deleted user.\n   */\n  async deleteUser(email: string): Promise<User> {\n    const user = await prisma.user.update({\n      where: { email },\n      data: { deletedAt: new Date() },\n    })\n\n    return user\n  }\n\n  /**\n   * Bans a user by setting their status to 'banned' and recording the reason.\n   * Also hides all repositories owned by the user.\n   *\n   * @param {string} email - The email of the user to ban.\n   * @returns {Promise<User>} - The banned user.\n   */\n  async banUser(email: string): Promise<User> {\n    return prisma.$transaction(async (tx) => {\n      // Update user status to banned\n      const user = await tx.user.update({\n        where: { email, deletedAt: null },\n        data: {\n          bannedUntil: new Date(),\n        },\n      })\n\n      // Update all repositories owned by the user to 'bannedUser'\n      await tx.codeRepo.updateMany({\n        where: { userId: user.id },\n        data: { status: 'bannedUser' },\n      })\n\n      return user\n    })\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\services\user_verification_service.ts</source>
<document_content>import { createDate, TimeSpan, isWithinExpirationDate } from 'oslo'\nimport { generateIdFromEntropySize } from 'lucia'\nimport { alphabet, generateRandomString } from 'oslo/crypto'\nimport { prisma } from './prisma_service.js'\nimport type { User } from 'lucia'\nimport mail from '@adonisjs/mail/services/main'\nimport env from '#start/env'\nimport { render } from '@react-email/components'\nimport KortexVerifyEmail from '../../resources/mail-templates/verify-email.mail.js'\n\nexport default class UserVerificationService {\n  async generateEmailVerificationCode(userId: string, email: string): Promise<string> {\n    // delete all previous codes\n    await prisma.emailVerificationCode.deleteMany({\n      where: { userId },\n    })\n\n    const code = generateRandomString(8, alphabet('0-9'))\n    await prisma.emailVerificationCode.create({\n      data: {\n        id: generateIdFromEntropySize(32),\n        userId,\n        email,\n        code,\n        expiresAt: createDate(new TimeSpan(15, 'm')), // 15 minutes\n      },\n    })\n    return code\n  }\n\n  async sendVerificationCode(email: string, code: string, token: string): Promise<void> {\n    await mail.send((message) => {\n      message\n        .to(email)\n        .from(env.get('SMTP_HOST') ?? '')\n        .subject('Verify your email address')\n        .html(render(KortexVerifyEmail({ validationCode: code, authToken: token })))\n    })\n  }\n\n  async verifyVerificationCode(user: User, code: string): Promise<boolean> {\n    const transaction = await prisma.$transaction(async (tx) => {\n      const databaseCode = await tx.emailVerificationCode.findFirstOrThrow({\n        where: { userId: user.id },\n      })\n\n      if (!databaseCode || databaseCode.code !== code) {\n        return false\n      }\n\n      if (!isWithinExpirationDate(databaseCode.expiresAt) || databaseCode.email !== user.email) {\n        return false\n      }\n\n      await tx.emailVerificationCode.delete({ where: { id: databaseCode.id } })\n\n      return true\n    })\n\n    return transaction\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\auth.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { ZodError, z } from 'zod'\n\n/**\n * Schema for validating user registration data.\n */\nexport const registrationSchema = z.object({\n  fullname: z.string().min(1, { message: \"Please enter your full name\" }),\n  email: z\n    .string()\n    .min(1, { message: \"Please enter your email\" })\n    .email({ message: \"Invalid email address\" }),\n  password: z\n    .string()\n    .min(1, { message: \"Please enter your password\" })\n    .min(7, { message: \"Password must be at least 7 characters long\" }),\n  userType: z.enum([\"buyer\", \"seller\"], {\n    required_error: \"Please select whether you're registering as a buyer or seller\",\n  }),\n})\n\n/**\n * Schema for validating user login data.\n */\nexport const loginSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n  password: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n})\n\n/**\n * Schema for validating forgot password request data.\n */\nexport const forgotPasswordSchema = z.object({\n  email: z.string().email({ message: 'Invalid email address' }),\n})\n\n/**\n * Schema for validating reset password data.\n */\nexport const resetPasswordSchema = z\n  .object({\n    token: z.string().min(1, { message: 'Token is required' }),\n    password: z\n      .string()\n      .min(8, { message: 'Password must be at least 8 characters long' })\n      .max(255, { message: 'Password must be at most 255 characters long' })\n      .regex(/[a-zA-Z]/, { message: 'Password must contain at least one letter' })\n      .regex(/\d/, { message: 'Password must contain at least one number' }),\n    confirmPassword: z.string().min(8, { message: 'Password must be at least 8 characters long' }),\n  })\n  .refine((data) => data.password === data.confirmPassword, {\n    message: 'Passwords must match',\n    path: ['confirmPassword'],\n  })\n\n/**\n * Interface for authentication strategies.\n */\nexport interface AuthStrategy {\n  /**\n   * Validates the provided data.\n   * @param data - The data to validate.\n   */\n  validate(data: {\n    email?: string\n    password?: string\n    fullname?: string\n    token?: string\n    confirmPassword?: string\n  }): Promise<void>\n}\n\n/**\n * Strategy for validating user registration data using Zod schema.\n */\nexport class ZodRegistrationAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string; fullname: string }): Promise<void> {\n    try {\n      registrationSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating user login data using Zod schema.\n */\nexport class ZodLoginAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string }): Promise<void> {\n    try {\n      loginSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating forgot password request data using Zod schema.\n */\nexport class ZodForgotPasswordAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    try {\n      forgotPasswordSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n\n/**\n * Strategy for validating reset password data using Zod schema.\n */\nexport class ZodResetPasswordAuthStrategy implements AuthStrategy {\n  async validate(data: {\n    token: string\n    password: string\n    confirmPassword: string\n  }): Promise<void> {\n    try {\n      resetPasswordSchema.parse(data)\n    } catch (error) {\n      if (error instanceof ZodError) {\n        throw error.errors.map((e) => ({\n          code: e.code,\n          path: e.path,\n          message: e.message,\n          fatalError: e.fatal,\n        }))\n      }\n      throw error\n    }\n  }\n}\n/**\n * Strategy for ensuring unique email using Prisma.\n */\nexport class PrismaEmailUniqueAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    const existingUser = await prisma.user.findUnique({ where: { email: data.email } })\n    if (existingUser) {\n      throw new Error('Email is already in use')\n    }\n  }\n}\n\n/**\n * Strategy for checking if an email exists using Prisma.\n */\nexport class PrismaEmailExistsAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string }): Promise<void> {\n    const existingUser = await prisma.user.findUnique({ where: { email: data.email } })\n    if (!existingUser) {\n      throw new Error('Email does not exist')\n    }\n  }\n}\n\nexport class EmptyFieldAuthStrategy implements AuthStrategy {\n  async validate(data: { email: string; password: string; fullname: string }): Promise<void> {\n    if (!data.email || !data.password) {\n      throw new Error('Emtpy fields on request body')\n    }\n  }\n}\n\n/**\n * Class for validating data using multiple authentication strategies.\n */\nexport class AuthValidator {\n  private strategies: AuthStrategy[] = []\n\n  /**\n   * Adds a new authentication strategy to the validator.\n   * @param strategy - The strategy to add.\n   */\n  addStrategy(strategy: AuthStrategy): void {\n    this.strategies.push(strategy)\n  }\n\n  /**\n   * Validates the provided data using all added strategies.\n   * @param data - The data to validate.\n   */\n  async validate(data: { email: string; password: string; fullname?: string }): Promise<void> {\n    for (const strategy of this.strategies) {\n      await strategy.validate(data)\n    }\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\checkout.ts</source>
<document_content></document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\code_check.ts</source>
<document_content>import { z } from 'zod'\nimport { Language } from '@prisma/client'\n\nexport const codeCheckSchema = z.object({\n  // New fields\n  securityScore: z.number().min(0).max(100),\n  maintainabilityScore: z.number().min(0).max(100),\n  readabilityScore: z.number().min(0).max(100),\n  securitySuggestion: z.string(),\n  maintainabilitySuggestion: z.string(),\n  readabilitySuggestion: z.string(),\n  overallDescription: z.string(),\n})\n\nexport const codeCheckRequestSchema = z.object({\n  code: z.string().min(1, 'Code is required'),\n  language: z.enum([Language.JSX, Language.TSX]),\n})\n\nexport type CodeCheckRequest = z.infer<typeof codeCheckRequestSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\order.ts</source>
<document_content>import { z } from 'zod'\n\nexport const CreateOrderSchema = z.object({\n  userId: z.string().uuid(),\n  codeRepoId: z.string().uuid(),\n  totalAmount: z.number().positive(),\n})\n\nexport const UpdateOrderSchema = z.object({\n  status: z.enum(['PENDING', 'COMPLETED', 'CANCELLED']).optional(),\n  totalAmount: z.number().positive().optional(),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\payout_request.ts</source>
<document_content>import { z } from 'zod'\n\nexport const createPayoutRequestSchema = z.object({\n  totalAmount: z.number().positive(),\n})\n\nexport const updatePayoutRequestSchema = z.object({\n  status: z.enum(['PENDING', 'REJECTED', 'PROCESSED']),\n})\n\nexport const processPayoutRequestSchema = z.object({\n  action: z.enum(['approve', 'reject']),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\payout.ts</source>
<document_content>// app/validators/payout.ts\nimport { z } from 'zod'\n\nexport const createPayoutSchema = z.object({\n  sellerProfileId: z.string().cuid(),\n  amount: z.number().positive(),\n  currency: z.string().min(3).max(3),\n  payoutRequestId: z.string(),\n})\n\nexport type CreatePayoutDTO = z.infer<typeof createPayoutSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\profile.ts</source>
<document_content>import { z } from 'zod'\nimport { isValidPhoneNumber } from 'libphonenumber-js'\n\nexport const updateProfileSchema = z.object({\n  name: z.string().optional(),\n  phoneNumber: z.string().optional(),\n  //profileImg: z.string().optional(),\n})\n\nexport const updateSellerProfileSchema = z.object({\n  businessName: z.string().min(1, 'Business name is required'),\n  businessAddress: z.string().min(1, 'Business address is required'),\n  businessPhone: z.string().refine(isValidPhoneNumber, { message: 'Invalid phone number' }),\n  businessEmail: z.string().email('Invalid email address'),\n  accountHolderName: z.string().min(1, 'Account holder name is required'),\n  accountNumber: z.string().min(1, 'Account number is required'),\n  bankName: z.string().min(1, 'Bank name is required'),\n  swiftCode: z.string().min(8).max(11),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\repo.ts</source>
<document_content>import { z } from 'zod'\n\n// Enum for Language\nconst LanguageEnum = z.enum(['JSX', 'TSX'])\n\n// Enum for Visibility\nconst VisibilityEnum = z.enum(['public', 'private'])\n\n// Enum for CodeRepoStatus\nconst CodeRepoStatusEnum = z.enum(['pending', 'active', 'rejected', 'bannedUser'])\n\n// Schema for creating a new repo\nexport const createRepoSchema = z.object({\n  name: z.string().min(1).max(255),\n  description: z.string().nullable(),\n  language: LanguageEnum,\n  price: z.number().nonnegative().default(0.0),\n  tags: z.array(z.string()),\n  visibility: VisibilityEnum.default('public'),\n})\n\n// Schema for updating a repo\nexport const updateRepoSchema = z.object({\n  name: z.string().min(1).max(255).optional(),\n  description: z.string().nullable().optional(),\n  language: LanguageEnum.optional(),\n  price: z.number().nonnegative().optional(),\n  tags: z.array(z.string()).optional(),\n  visibility: VisibilityEnum.optional(),\n  status: CodeRepoStatusEnum.optional(),\n  sourceJs: z.string().optional(),\n  sourceCss: z.string().optional(),\n  //stripeProductId: z.string().nullable().optional(),\n  //stripePriceId: z.string().nullable().optional(),\n})\n\nexport const publishRepoSchema = z.object({\n  id: z.string(),\n  userId: z.string()\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\app\validators\seller.ts</source>
<document_content>import { z } from 'zod'\n\nexport const createSellerProfileSchema = z.object({\n  businessName: z.string().min(1, 'Business name is required'),\n  businessAddress: z.string().min(1, 'Business address is required'),\n  businessPhone: z.string().min(1, 'Business phone is required'),\n  businessEmail: z.string().email('Invalid email address'),\n  accountHolderName: z.string().min(1, 'Account holder name is required'),\n  accountNumber: z.string().min(1, 'Account number is required'),\n  bankName: z.string().min(1, 'Bank name is required'),\n  swiftCode: z.string().min(8).max(11, 'SWIFT code must be 8 or 11 characters'),\n  iban: z.string().optional(),\n  routingNumber: z.string().optional(),\n  verificationStatus: z.enum(['PENDING', 'APPROVED', 'REJECTED', 'IDLE']),\n})\n\nexport const updateSellerProfileSchema = createSellerProfileSchema.partial()\n\nexport const createPayoutRequestSchema = z.object({\n  amount: z.number().positive('Amount must be positive'),\n})\n\nexport const updatePayoutRequestSchema = z.object({\n  status: z.enum(['PENDING', 'APPROVED', 'REJECTED', 'PROCESSED']),\n})\n\nexport type CreateSellerProfileDto = z.infer<typeof createSellerProfileSchema>\nexport type UpdateSellerProfileDto = z.infer<typeof updateSellerProfileSchema>\nexport type CreatePayoutRequestDto = z.infer<typeof createPayoutRequestSchema>\nexport type UpdatePayoutRequestDto = z.infer<typeof updatePayoutRequestSchema>\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\prisma\schema.prisma</source>
<document_content>generator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"driverAdapters\"]\n}\n\ngenerator kysely {\n  provider     = \"prisma-kysely\"\n  output       = \"../database//kysely/\"\n  fileName     = \"types.ts\"\n  enumFileName = \"enums.ts\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel emailVerificationCode {\n  id        String   @id\n  code      String\n  userId    String\n  email     String\n  expiresAt DateTime\n  User      User     @relation(fields: [userId], references: [id])\n}\n\nenum Role {\n  USER\n  ADMIN\n  MODERATOR\n  SELLER\n}\n\nmodel User {\n  id            String    @id @default(cuid())\n  email         String    @unique\n  passwordHash  String\n  sessions      Session[]\n  emailVerified Boolean   @default(false)\n  createdAt     DateTime  @default(now())\n  updatedAt     DateTime  @updatedAt\n  deletedAt     DateTime?\n\n  PasswordResetToken    PasswordResetToken[]\n  CodeRepo              CodeRepo[]\n  emailVerificationCode emailVerificationCode[]\n  orders                Order[]\n\n  bannedUntil DateTime?\n\n  role Role @default(USER)\n\n  sellerProfile SellerProfile?\n  profile       Profile?\n\n  Review         Review[]\n  Comment        Comment[]\n  SearchHistory  SearchHistory[]\n  SalesAggregate SalesAggregate[]\n  Vote           Vote[]\n  repoAccesses   UserRepoAccess[]\n}\n\nmodel Profile {\n  id          String  @id @default(cuid())\n  profileImg  String?\n  name        String?\n  phoneNumber String?\n  user        User    @relation(fields: [userId], references: [id])\n  userId      String  @unique\n}\n\nmodel SellerProfile {\n  id                 String                   @id @default(cuid())\n  user               User                     @relation(fields: [userId], references: [id])\n  userId             String                   @unique\n  profileImg         String?\n  businessName       String\n  businessAddress    String\n  businessPhone      String\n  businessEmail      String\n  identityDoc        String?\n  verificationDate   DateTime?\n  verificationStatus SellerVerificationStatus @default(PENDING)\n  bankAccount        BankAccount?\n  Payout             Payout[]\n  balance            Float                    @default(0)\n  PayoutRequest      PayoutRequest[]\n  lastPayoutDate     DateTime?\n}\n\nenum SellerVerificationStatus {\n  IDLE\n  PENDING\n  APPROVED\n  REJECTED\n}\n\nmodel BankAccount {\n  id                String        @id @default(cuid())\n  sellerProfile     SellerProfile @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId   String        @unique\n  accountHolderName String\n  accountNumber     String\n  bankName          String\n  swiftCode         String\n  iban              String?\n  routingNumber     String?\n  createdAt         DateTime      @default(now())\n  updatedAt         DateTime      @updatedAt\n}\n\nmodel PayoutRequest {\n  id              String              @id @default(cuid())\n  sellerProfile   SellerProfile       @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId String\n  totalAmount     Float\n  status          PayoutRequestStatus @default(PENDING)\n  createdAt       DateTime            @default(now())\n  updatedAt       DateTime            @updatedAt\n  processedAt     DateTime?\n  payout          Payout?\n  lastPayoutDate  DateTime?\n  orders          Order[]\n}\n\nenum PayoutRequestStatus {\n  PENDING\n  REJECTED\n  PROCESSED\n}\n\nmodel Payout {\n  id              String        @id @default(cuid())\n  sellerProfile   SellerProfile @relation(fields: [sellerProfileId], references: [id])\n  sellerProfileId String\n  payoutRequest   PayoutRequest @relation(fields: [payoutRequestId], references: [id])\n  payoutRequestId String        @unique\n  totalAmount     Float\n  currency        String\n  createdAt       DateTime      @default(now())\n  updatedAt       DateTime      @updatedAt\n}\n\nmodel Session {\n  id        String   @id\n  userId    String\n  expiresAt DateTime\n  user      User     @relation(references: [id], fields: [userId], onDelete: Cascade)\n}\n\nmodel PasswordResetToken {\n  id        Int      @id @default(autoincrement())\n  tokenHash String   @unique\n  userId    String\n  expiresAt DateTime\n  user      User     @relation(fields: [userId], references: [id])\n}\n\nmodel CodeRepo {\n  id          String         @id @default(cuid())\n  userId      String\n  user        User           @relation(fields: [userId], references: [id])\n  sourceJs    String         @db.Text\n  sourceCss   String         @db.Text\n  reviews     Review[]\n  createdAt   DateTime       @default(now())\n  updatedAt   DateTime       @updatedAt\n  deletedAt   DateTime?\n  visibility  Visibility     @default(public)\n  status      CodeRepoStatus @default(pending)\n  name        String\n  description String?\n  language    Language\n  price       Float          @default(0.0)\n  tags        TagsOnRepos[]\n  codeChecks  CodeCheck[]\n  orders      Order[]\n  userAccesses UserRepoAccess[]\n}\n\nmodel Tag {\n  id        String        @id @default(cuid())\n  name      String        @unique\n  repos     TagsOnRepos[]\n  createdAt DateTime      @default(now())\n  updatedAt DateTime      @updatedAt\n  deletedAt DateTime?\n}\n\nmodel TagsOnRepos {\n  codeRepo   CodeRepo @relation(fields: [codeRepoId], references: [id])\n  codeRepoId String\n  tag        Tag      @relation(fields: [tagId], references: [id])\n  tagId      String\n\n  @@id([codeRepoId, tagId])\n}\n\nenum CodeRepoStatus {\n  pending\n  active\n  rejected\n  bannedUser\n}\n\nenum Visibility {\n  public\n  private\n}\n\nenum Language {\n  JSX\n  TSX\n}\n\nmodel SearchHistory {\n  id        String   @id @default(cuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id])\n  tag       String\n  createdAt DateTime @default(now())\n}\n\nmodel CodeCheck {\n  id                        String   @id @default(cuid())\n  repoId                    String\n  securityScore             Int\n  maintainabilityScore      Int\n  readabilityScore          Int\n  securitySuggestion        String   @db.Text\n  maintainabilitySuggestion String   @db.Text\n  readabilitySuggestion     String   @db.Text\n  overallDescription        String   @db.Text\n  eslintErrorCount          Int\n  eslintFatalErrorCount     Int\n  createdAt                 DateTime @default(now())\n  updatedAt                 DateTime @updatedAt\n  Repo                      CodeRepo @relation(fields: [repoId], references: [id])\n}\n\nmodel Order {\n  id                    String         @id @default(cuid())\n  userId                String\n  user                  User           @relation(fields: [userId], references: [id])\n  codeRepoId            String\n  codeRepo              CodeRepo       @relation(fields: [codeRepoId], references: [id])\n  createdAt             DateTime       @default(now())\n  updatedAt             DateTime       @updatedAt\n  deletedAt             DateTime?\n  status                OrderStatus    @default(REQUIRESPAYMENTMETHOD)\n  totalAmount           Float\n  stripePaymentIntentId String?\n  stripePaymentMethodId String?\n  payoutRequest         PayoutRequest? @relation(fields: [payoutRequestId], references: [id])\n  payoutRequestId       String?\n  userRepoAccesses      UserRepoAccess[]\n}\n\nenum OrderStatus {\n  REQUIRESPAYMENTMETHOD\n  REQUIRESCONFIRMATION\n  REQUIRESACTION\n  PROCESSING\n  REQUIRESCAPTURE\n  CANCELLED\n  SUCCEEDED\n}\n\nmodel SalesAggregate {\n  id         String   @id @default(cuid())\n  sellerId   String\n  seller     User     @relation(fields: [sellerId], references: [id])\n  date       DateTime\n  revenue    Float\n  salesCount Int\n\n  @@unique([sellerId, date])\n}\n\nenum UserCommentFlag {\n  NONE\n  SPAM\n  INAPPROPRIATE_LANGUAGE\n  HARASSMENT\n  OFF_TOPIC\n  FALSE_INFORMATION\n  OTHER\n}\n\nmodel Review {\n  id        String          @id @default(cuid())\n  content   String\n  userId    String\n  user      User            @relation(fields: [userId], references: [id])\n  repoId    String\n  repo      CodeRepo        @relation(fields: [repoId], references: [id])\n  rating    Int             @default(0)\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt\n  deletedAt DateTime?\n  comments  Comment[]\n  flag      UserCommentFlag @default(NONE)\n\n  upvotes   Int             @default(0)\n  downvotes Int             @default(0)\n  votes     Vote[]\n}\n\nmodel Comment {\n  id        String          @id @default(cuid())\n  content   String\n  userId    String\n  user      User            @relation(fields: [userId], references: [id])\n  reviewId  String\n  review    Review          @relation(fields: [reviewId], references: [id])\n  createdAt DateTime        @default(now())\n  updatedAt DateTime        @updatedAt\n  deletedAt DateTime?\n  flag      UserCommentFlag @default(NONE)\n\n  upvotes   Int             @default(0)\n  downvotes Int             @default(0)\n  votes     Vote[]\n}\n\nmodel Vote {\n  id        String   @id @default(cuid())\n  userId    String\n  type      VoteType\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  user      User     @relation(fields: [userId], references: [id])\n\n  comment   Comment? @relation(fields: [commentId], references: [id])\n  commentId String?\n  Review    Review?  @relation(fields: [reviewId], references: [id])\n  reviewId  String?\n\n  @@unique([userId, commentId])\n  @@unique([userId, reviewId])\n}\n\nenum VoteType {\n  UPVOTE\n  DOWNVOTE\n}\n\nmodel SupportTicket {\n  id        String              @id @default(cuid())\n  email     String\n  title     String\n  content   String\n  status    SupportTicketStatus @default(todo)\n  type      SupportTicketType   @default(general)\n  createdAt DateTime            @default(now())\n  updatedAt DateTime            @updatedAt\n}\n\nenum SupportTicketStatus {\n  inProgress\n  todo\n  backlog\n  done\n}\n\nenum SupportTicketType {\n  general\n  technical\n  payment\n}\n\nmodel Media {\n  id        String   @id @default(cuid())\n  url       String\n  type      String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel UserRepoAccess {\n  id        String   @id @default(cuid())\n  user      User     @relation(fields: [userId], references: [id])\n  userId    String\n  repo      CodeRepo @relation(fields: [repoId], references: [id])\n  repoId    String\n  order     Order    @relation(fields: [orderId], references: [id])\n  orderId   String\n  grantedAt DateTime @default(now())\n  expiresAt DateTime?\n\n  @@unique([userId, repoId])\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\kysely.ts</source>
<document_content>import type { DB } from './kysely/types.js' // this is the Database interface we defined earlier\nimport pg from 'pg'\nimport { Kysely, PostgresDialect } from 'kysely'\nimport env from '#start/env'\n\nconst { Pool } = pg\n\n// const pool = new Pool({ connectionString: env.get(\"DATABASE_URL });\n\nconst dialect = new PostgresDialect({\n  pool: new Pool({\n    connectionString: env.get('DATABASE_URL'),\n    //host: env.get(\"DATABASE_LOCAL_HOST\"),\n    //database: env.get(\"DATABASE_LOCAL_DB\"),\n    //user: env.get(\"DATABASE_LOCAL_USER\"),\n    //password: env.get(\"DATABASE_LOCAL_PASSWORD\"),\n    //port: env.get(\"DATABASE_LOCAL_PORT\"),\n    // ssl: true,\n    // connection: {\n    //   options: `project=${env.get(\"DATABASE_PGPROJECT}`,\n    // },\n  }),\n})\n\n// Database interface is passed to Kysely's constructor, and from now on, Kysely\n// knows your database structure.\n// Dialect is passed to Kysely's constructor, and from now on, Kysely knows how\n// to communicate with your database.\nexport const kyselyDb = new Kysely<DB>({\n  dialect,\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\kysely\enums.ts</source>
<document_content>export const Role = {\n    USER: \"USER\",\n    ADMIN: \"ADMIN\",\n    MODERATOR: \"MODERATOR\",\n    SELLER: \"SELLER\"\n} as const;\nexport type Role = (typeof Role)[keyof typeof Role];\nexport const SellerVerificationStatus = {\n    IDLE: \"IDLE\",\n    PENDING: \"PENDING\",\n    APPROVED: \"APPROVED\",\n    REJECTED: \"REJECTED\"\n} as const;\nexport type SellerVerificationStatus = (typeof SellerVerificationStatus)[keyof typeof SellerVerificationStatus];\nexport const PayoutRequestStatus = {\n    PENDING: \"PENDING\",\n    REJECTED: \"REJECTED\",\n    PROCESSED: \"PROCESSED\"\n} as const;\nexport type PayoutRequestStatus = (typeof PayoutRequestStatus)[keyof typeof PayoutRequestStatus];\nexport const CodeRepoStatus = {\n    pending: \"pending\",\n    active: \"active\",\n    rejected: \"rejected\",\n    bannedUser: \"bannedUser\"\n} as const;\nexport type CodeRepoStatus = (typeof CodeRepoStatus)[keyof typeof CodeRepoStatus];\nexport const Visibility = {\n    public: \"public\",\n    private: \"private\"\n} as const;\nexport type Visibility = (typeof Visibility)[keyof typeof Visibility];\nexport const Language = {\n    JSX: \"JSX\",\n    TSX: \"TSX\"\n} as const;\nexport type Language = (typeof Language)[keyof typeof Language];\nexport const OrderStatus = {\n    REQUIRESPAYMENTMETHOD: \"REQUIRESPAYMENTMETHOD\",\n    REQUIRESCONFIRMATION: \"REQUIRESCONFIRMATION\",\n    REQUIRESACTION: \"REQUIRESACTION\",\n    PROCESSING: \"PROCESSING\",\n    REQUIRESCAPTURE: \"REQUIRESCAPTURE\",\n    CANCELLED: \"CANCELLED\",\n    SUCCEEDED: \"SUCCEEDED\"\n} as const;\nexport type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus];\nexport const UserCommentFlag = {\n    NONE: \"NONE\",\n    SPAM: \"SPAM\",\n    INAPPROPRIATE_LANGUAGE: \"INAPPROPRIATE_LANGUAGE\",\n    HARASSMENT: \"HARASSMENT\",\n    OFF_TOPIC: \"OFF_TOPIC\",\n    FALSE_INFORMATION: \"FALSE_INFORMATION\",\n    OTHER: \"OTHER\"\n} as const;\nexport type UserCommentFlag = (typeof UserCommentFlag)[keyof typeof UserCommentFlag];\nexport const VoteType = {\n    UPVOTE: \"UPVOTE\",\n    DOWNVOTE: \"DOWNVOTE\"\n} as const;\nexport type VoteType = (typeof VoteType)[keyof typeof VoteType];\nexport const SupportTicketStatus = {\n    inProgress: \"inProgress\",\n    todo: \"todo\",\n    backlog: \"backlog\",\n    done: \"done\"\n} as const;\nexport type SupportTicketStatus = (typeof SupportTicketStatus)[keyof typeof SupportTicketStatus];\nexport const SupportTicketType = {\n    general: \"general\",\n    technical: \"technical\",\n    payment: \"payment\"\n} as const;\nexport type SupportTicketType = (typeof SupportTicketType)[keyof typeof SupportTicketType];\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\kysely\types.ts</source>
<document_content>import type { ColumnType } from \"kysely\";\nexport type Generated<T> = T extends ColumnType<infer S, infer I, infer U>\n  ? ColumnType<S, I | undefined, U>\n  : ColumnType<T, T | undefined, T>;\nexport type Timestamp = ColumnType<Date, Date | string, Date | string>;\n\nimport type { Role, SellerVerificationStatus, PayoutRequestStatus, CodeRepoStatus, Visibility, Language, OrderStatus, UserCommentFlag, VoteType, SupportTicketStatus, SupportTicketType } from \"./enums\";\n\nexport type BankAccount = {\n    id: string;\n    sellerProfileId: string;\n    accountHolderName: string;\n    accountNumber: string;\n    bankName: string;\n    swiftCode: string;\n    iban: string | null;\n    routingNumber: string | null;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n};\nexport type CodeCheck = {\n    id: string;\n    repoId: string;\n    securityScore: number;\n    maintainabilityScore: number;\n    readabilityScore: number;\n    securitySuggestion: string;\n    maintainabilitySuggestion: string;\n    readabilitySuggestion: string;\n    overallDescription: string;\n    eslintErrorCount: number;\n    eslintFatalErrorCount: number;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n};\nexport type CodeRepo = {\n    id: string;\n    userId: string;\n    sourceJs: string;\n    sourceCss: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n    visibility: Generated<Visibility>;\n    status: Generated<CodeRepoStatus>;\n    name: string;\n    description: string | null;\n    language: Language;\n    price: Generated<number>;\n};\nexport type Comment = {\n    id: string;\n    content: string;\n    userId: string;\n    reviewId: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n    flag: Generated<UserCommentFlag>;\n    upvotes: Generated<number>;\n    downvotes: Generated<number>;\n};\nexport type emailVerificationCode = {\n    id: string;\n    code: string;\n    userId: string;\n    email: string;\n    expiresAt: Timestamp;\n};\nexport type Media = {\n    id: string;\n    url: string;\n    type: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n};\nexport type Order = {\n    id: string;\n    userId: string;\n    codeRepoId: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n    status: Generated<OrderStatus>;\n    totalAmount: number;\n    stripePaymentIntentId: string | null;\n    stripePaymentMethodId: string | null;\n    payoutRequestId: string | null;\n};\nexport type PasswordResetToken = {\n    id: Generated<number>;\n    tokenHash: string;\n    userId: string;\n    expiresAt: Timestamp;\n};\nexport type Payout = {\n    id: string;\n    sellerProfileId: string;\n    payoutRequestId: string;\n    totalAmount: number;\n    currency: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n};\nexport type PayoutRequest = {\n    id: string;\n    sellerProfileId: string;\n    totalAmount: number;\n    status: Generated<PayoutRequestStatus>;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    processedAt: Timestamp | null;\n    lastPayoutDate: Timestamp | null;\n};\nexport type Profile = {\n    id: string;\n    profileImg: string | null;\n    name: string | null;\n    phoneNumber: string | null;\n    userId: string;\n};\nexport type Review = {\n    id: string;\n    content: string;\n    userId: string;\n    repoId: string;\n    rating: Generated<number>;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n    flag: Generated<UserCommentFlag>;\n    upvotes: Generated<number>;\n    downvotes: Generated<number>;\n};\nexport type SalesAggregate = {\n    id: string;\n    sellerId: string;\n    date: Timestamp;\n    revenue: number;\n    salesCount: number;\n};\nexport type SearchHistory = {\n    id: string;\n    userId: string;\n    tag: string;\n    createdAt: Generated<Timestamp>;\n};\nexport type SellerProfile = {\n    id: string;\n    userId: string;\n    profileImg: string | null;\n    businessName: string;\n    businessAddress: string;\n    businessPhone: string;\n    businessEmail: string;\n    identityDoc: string | null;\n    verificationDate: Timestamp | null;\n    verificationStatus: Generated<SellerVerificationStatus>;\n    balance: Generated<number>;\n    lastPayoutDate: Timestamp | null;\n};\nexport type Session = {\n    id: string;\n    userId: string;\n    expiresAt: Timestamp;\n};\nexport type SupportTicket = {\n    id: string;\n    email: string;\n    title: string;\n    content: string;\n    status: Generated<SupportTicketStatus>;\n    type: Generated<SupportTicketType>;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n};\nexport type Tag = {\n    id: string;\n    name: string;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n};\nexport type TagsOnRepos = {\n    codeRepoId: string;\n    tagId: string;\n};\nexport type User = {\n    id: string;\n    email: string;\n    passwordHash: string;\n    emailVerified: Generated<boolean>;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    deletedAt: Timestamp | null;\n    bannedUntil: Timestamp | null;\n    role: Generated<Role>;\n};\nexport type UserRepoAccess = {\n    id: string;\n    userId: string;\n    repoId: string;\n    orderId: string;\n    grantedAt: Generated<Timestamp>;\n    expiresAt: Timestamp | null;\n};\nexport type Vote = {\n    id: string;\n    userId: string;\n    type: VoteType;\n    createdAt: Generated<Timestamp>;\n    updatedAt: Timestamp;\n    commentId: string | null;\n    reviewId: string | null;\n};\nexport type DB = {\n    BankAccount: BankAccount;\n    CodeCheck: CodeCheck;\n    CodeRepo: CodeRepo;\n    Comment: Comment;\n    emailVerificationCode: emailVerificationCode;\n    Media: Media;\n    Order: Order;\n    PasswordResetToken: PasswordResetToken;\n    Payout: Payout;\n    PayoutRequest: PayoutRequest;\n    Profile: Profile;\n    Review: Review;\n    SalesAggregate: SalesAggregate;\n    SearchHistory: SearchHistory;\n    SellerProfile: SellerProfile;\n    Session: Session;\n    SupportTicket: SupportTicket;\n    Tag: Tag;\n    TagsOnRepos: TagsOnRepos;\n    User: User;\n    UserRepoAccess: UserRepoAccess;\n    Vote: Vote;\n};\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\comment-factory.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { Review, UserCommentFlag, type Comment, VoteType } from '@prisma/client'\nimport { generateIdFromEntropySize } from 'lucia'\nimport { weightedRandomDelete } from './utils.js'\nimport { prisma } from '#services/prisma_service'\n\nconst weightedRandomFlag = (): UserCommentFlag => {\n  if (Math.random() < 0.8) {\n    return 'NONE'\n  } else {\n    return faker.helpers.arrayElement(\n      Object.values(UserCommentFlag).filter((flag) => flag !== 'NONE')\n    )\n  }\n}\n\nconst generateVotes = (\n  userIds: string[],\n  itemId: string,\n  itemType: 'review' | 'comment'\n): {\n  votes: { userId: string; type: VoteType }[]\n  upvotes: number\n  downvotes: number\n} => {\n  const votes: { userId: string; type: VoteType }[] = []\n  let upvotes = 0\n  let downvotes = 0\n\n  // Randomly select users to vote (50% chance for each user)\n  userIds.forEach((userId) => {\n    if (Math.random() < 0.5) {\n      const voteType = Math.random() < 0.6 ? VoteType.UPVOTE : VoteType.DOWNVOTE\n      votes.push({\n        userId,\n        type: voteType,\n      })\n      voteType === VoteType.UPVOTE ? upvotes++ : downvotes++\n    }\n  })\n\n  return { votes, upvotes, downvotes }\n}\n\nexport const generateReviews = async (\n  existingUserIds: string[],\n  count: number\n): Promise<{ reviews: Review[]; votes: any[] }> => {\n  const generatedReviews: Review[] = []\n  const generatedVotes: any[] = []\n  const existingRepoIds = await prisma.codeRepo.findMany({ select: { id: true } })\n\n  for (let i = 0; i < count; i++) {\n    const randomUserId = faker.helpers.arrayElement(existingUserIds)\n    const randomRating = faker.number.int({ min: 1, max: 5 })\n    const randomFlag = weightedRandomFlag()\n    const reviewId = generateIdFromEntropySize(32)\n\n    const { votes, upvotes, downvotes } = generateVotes(existingUserIds, reviewId, 'review')\n\n    const review: Review = {\n      id: reviewId,\n      userId: randomUserId,\n      repoId: faker.helpers.arrayElement(existingRepoIds).id,\n      content: faker.lorem.paragraph(),\n      rating: randomRating,\n      createdAt: faker.date.past(),\n      updatedAt: faker.date.recent(),\n      deletedAt: weightedRandomDelete(),\n      upvotes,\n      downvotes,\n      flag: randomFlag,\n    }\n\n    generatedReviews.push(review)\n    generatedVotes.push(\n      ...votes.map((vote) => ({\n        id: generateIdFromEntropySize(32),\n        reviewId,\n        ...vote,\n      }))\n    )\n  }\n\n  return { reviews: generatedReviews, votes: generatedVotes }\n}\n\nexport const generateComments = async (\n  existingUserIds: string[],\n  existingReviewIds: string[],\n  count: number\n): Promise<{ comments: Comment[]; votes: any[] }> => {\n  const generatedComments: Comment[] = []\n  const generatedVotes: any[] = []\n\n  for (let i = 0; i < count; i++) {\n    const randomUserId = faker.helpers.arrayElement(existingUserIds)\n    const randomReviewId = faker.helpers.arrayElement(existingReviewIds)\n    const randomFlag = weightedRandomFlag()\n    const commentId = generateIdFromEntropySize(32)\n\n    const { votes, upvotes, downvotes } = generateVotes(existingUserIds, commentId, 'comment')\n\n    const comment: Comment = {\n      id: commentId,\n      userId: randomUserId,\n      reviewId: randomReviewId,\n      content: faker.lorem.paragraph(),\n      createdAt: faker.date.past(),\n      updatedAt: faker.date.recent(),\n      deletedAt: weightedRandomDelete(),\n      upvotes,\n      downvotes,\n      flag: randomFlag,\n    }\n\n    generatedComments.push(comment)\n    generatedVotes.push(\n      ...votes.map((vote) => ({\n        id: generateIdFromEntropySize(32),\n        commentId,\n        ...vote,\n      }))\n    )\n  }\n\n  return { comments: generatedComments, votes: generatedVotes }\n}\n\nexport const seedReviewsAndComments = async (count: number): Promise<void> => {\n  const existingUserIds = (await prisma.user.findMany({ select: { id: true } })).map(\n    (user) => user.id\n  )\n  const { reviews, votes: reviewVotes } = await generateReviews(existingUserIds, count)\n  const reviewIds = reviews.map((review) => review.id)\n  const { comments, votes: commentVotes } = await generateComments(\n    existingUserIds,\n    reviewIds,\n    count * 5\n  )\n\n  await prisma.$transaction([\n    prisma.review.createMany({ data: reviews }),\n    prisma.comment.createMany({ data: comments }),\n    prisma.vote.createMany({\n      data: reviewVotes.map((vote) => ({\n        commentId: vote.commentId,\n        id: vote.id,\n        reviewId: vote.reviewId,\n        userId: vote.userId,\n        type: vote.type,\n      })),\n    }),\n    prisma.vote.createMany({\n      data: commentVotes.map((vote) => ({\n        id: vote.id,\n        commentId: vote.commentId,\n        userId: vote.userId,\n        type: vote.type,\n      })),\n    }),\n  ])\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\constants.ts</source>
<document_content>export const REPO_TAGS = [\n  'react',\n  'typescript',\n  'tailwindcss',\n  'react-hooks',\n  'redux',\n  'react-router',\n  'nextjs',\n  'gatsby',\n  'create-react-app',\n  'react-context',\n  'redux-toolkit',\n  'react-redux',\n  'graphql',\n  'apollo-client',\n  'react-testing-library',\n  'jest',\n  'formik',\n  'react-query',\n  'material-ui',\n  'chakra-ui',\n  'ant-design',\n  'emotion',\n  'styled-components',\n  'css-in-js',\n  'eslint',\n  'prettier',\n  'vite',\n  'webpack',\n  'babel',\n  'storybook',\n  'react-spring',\n  'framer-motion',\n  'react-native',\n  'expo',\n  'react-navigation',\n  'react-i18next',\n  'react-dnd',\n  'react-beautiful-dnd',\n  'react-final-form',\n  'react-hook-form',\n  'react-snapshot',\n  'react-window',\n  'react-virtualized',\n  'react-table',\n  'react-data-grid',\n  'react-icons',\n  'react-select',\n  'react-autosuggest',\n  'react-dropzone',\n  'react-toastify',\n  'react-error-boundary',\n  'react-hot-toast',\n  'react-infinite-scroll',\n  'react-intersection-observer',\n  'react-use',\n  'react-swipeable',\n  'react-player',\n  'react-helmet',\n  'react-ga',\n  'react-markdown',\n  'react-slick',\n  'react-stripe-js',\n  'react-use-gesture',\n  'react-three-fiber',\n  'zustand',\n  'recoil',\n  'jotai',\n  'react-query-devtools',\n  'msw',\n  'react-apexcharts',\n  'react-chartjs-2',\n  'nivo',\n  'react-sparklines',\n  'react-leaflet',\n  'react-google-maps',\n  'react-map-gl',\n  'react-geosuggest',\n  'react-rnd',\n  'react-split-pane',\n  'react-pdf',\n  'react-move',\n  'react-use-measure',\n  'react-gsap',\n  'react-icons-kit',\n  'react-vertical-timeline',\n  'react-parallax',\n  'react-transition-group',\n  'react-motion',\n  'react-flip-move',\n  'react-responsive',\n  'react-dates',\n  'react-moment',\n  'react-intl',\n  'react-spring-lightbox',\n  'react-popper',\n  'react-tooltip',\n  'react-lottie',\n  'react-smooth-dnd',\n  'react-slider',\n  'react-datetime',\n  'react-collapse',\n  'react-photo-gallery',\n]\n\nexport const QUIZ_APP_CSS = `\n.quiz-container {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  font-family: Arial, sans-serif;\n  background-color: #1a1a1a;\n  color: #ffffff;\n  border-radius: 10px;\n  box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);\n}\n\nh1 {\n  text-align: center;\n  color: #bb86fc;\n}\n\nh2 {\n  color: #03dac6;\n}\n\n.question {\n  font-size: 1.2em;\n  margin-bottom: 20px;\n}\n\n.options {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 10px;\n}\n\n.option-btn {\n  background-color: #3700b3;\n  color: #ffffff;\n  border: none;\n  padding: 10px;\n  font-size: 1em;\n  cursor: pointer;\n  border-radius: 5px;\n  transition: background-color 0.3s;\n}\n\n.option-btn:hover {\n  background-color: #6200ee;\n}\n\n.option-btn.selected {\n  background-color: #018786;\n}\n\n.next-btn, .restart-btn {\n  background-color: #bb86fc;\n  color: #000000;\n  border: none;\n  padding: 10px 20px;\n  font-size: 1em;\n  cursor: pointer;\n  border-radius: 5px;\n  margin-top: 20px;\n  transition: background-color 0.3s;\n}\n\n.next-btn:hover, .restart-btn:hover {\n  background-color: #3700b3;\n  color: #ffffff;\n}\n\n.next-btn:disabled {\n  background-color: #4f4f4f;\n  cursor: not-allowed;\n}\n\n.score-section {\n  text-align: center;\n}\n\n.score-section p {\n  font-size: 1.2em;\n  margin-bottom: 20px;\n}\n`\n\nexport const QUIZ_APP = `\n\nimport React from \"react\"\nimport render from \"react-dom\"\n\ninterface Question {\n  id: number;\n  question: string;\n  options: string[];\n  correctAnswer: string;\n}\n\nconst QuizApp = () => {\n  const [questions, setQuestions] = React.useState<Question[]>([\n    {\n      id: 1,\n      question: \"What is the capital of France?\",\n      options: [\"London\", \"Berlin\", \"Paris\", \"Madrid\"],\n      correctAnswer: \"Paris\"\n    },\n    {\n      id: 2,\n      question: \"Which planet is known as the Red Planet?\",\n      options: [\"Venus\", \"Mars\", \"Jupiter\", \"Saturn\"],\n      correctAnswer: \"Mars\"\n    },\n    {\n      id: 3,\n      question: \"Who painted the Mona Lisa?\",\n      options: [\"Vincent van Gogh\", \"Leonardo da Vinci\", \"Pablo Picasso\", \"Michelangelo\"],\n      correctAnswer: \"Leonardo da Vinci\"\n    }\n  ]);\n  const [currentQuestion, setCurrentQuestion] = React.useState<number>(0);\n  const [score, setScore] = React.useState<number>(0);\n  const [showScore, setShowScore] = React.useState<boolean>(false);\n  const [selectedAnswer, setSelectedAnswer] = React.useState<string>(\"\");\n\n  const handleAnswerClick = (answer: string): void => {\n    setSelectedAnswer(answer);\n  };\n\n  const handleNextQuestion = (): void => {\n    if (selectedAnswer === questions[currentQuestion].correctAnswer) {\n      setScore(prevScore => prevScore + 1);\n    }\n\n    const nextQuestion = currentQuestion + 1;\n    if (nextQuestion < questions.length) {\n      setCurrentQuestion(nextQuestion);\n      setSelectedAnswer(\"\");\n    } else {\n      setShowScore(true);\n    }\n  };\n\n  const restartQuiz = (): void => {\n    setCurrentQuestion(0);\n    setScore(0);\n    setShowScore(false);\n    setSelectedAnswer(\"\");\n  };\n\n  return (\n    <div className=\"quiz-container\">\n      <h1>Quiz App</h1>\n      {showScore ? (\n        <div className=\"score-section\">\n          <h2>Quiz Completed!</h2>\n          <p>Your score: {score} out of {questions.length}</p>\n          <button onClick={restartQuiz} className=\"restart-btn\">Restart Quiz</button>\n        </div>\n      ) : (\n        <div className=\"question-section\">\n          <h2>Question {currentQuestion + 1}/{questions.length}</h2>\n          <p className=\"question\">{questions[currentQuestion].question}</p>\n          <div className=\"options\">\n            {questions[currentQuestion].options.map((option, index) => (\n              <button\n                key={index}\n                onClick={() => handleAnswerClick(option)}\n                className={\`option-btn \${selectedAnswer === option ? 'selected' : ''}\`}\n              >\n                {option}\n              </button>\n            ))}\n          </div>\n          <button\n            onClick={handleNextQuestion}\n            disabled={!selectedAnswer}\n            className=\"next-btn\"\n          >\n            {currentQuestion === questions.length - 1 ? 'Finish' : 'Next'}\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nrender(<QuizApp />);\n`\n\n// TSX Variant\n\nexport const KANBAN = `\nimport React from \"react\"\nimport render from \"react-dom\"\n\n\ninterface Task {\n  id: number;\n  title: string;\n  description: string;\n  priority: 'Low' | 'Medium' | 'High';\n  status: 'To Do' | 'In Progress' | 'Done';\n  dueDate: string;\n}\n\nconst KanbanBoard = () => {\n  const [tasks, setTasks] = React.useState<Task[]>([]);\n  const [newTask, setNewTask] = React.useState<Omit<Task, 'id' | 'status'>>({\n    title: '',\n    description: '',\n    priority: 'Medium',\n    dueDate: ''\n  });\n\n  const addTask = () => {\n    if (newTask.title && newTask.description && newTask.dueDate) {\n      setTasks([...tasks, { ...newTask, id: Date.now(), status: 'To Do' }]);\n      setNewTask({ title: '', description: '', priority: 'Medium', dueDate: '' });\n    }\n  };\n\n  const moveTask = (taskId: number, newStatus: 'To Do' | 'In Progress' | 'Done') => {\n    setTasks(tasks.map(task =>\n      task.id === taskId ? { ...task, status: newStatus } : task\n    ));\n  };\n\n  const deleteTask = (id: number) => {\n    setTasks(tasks.filter(task => task.id !== id));\n  };\n\n  const getPriorityColor = (priority: 'Low' | 'Medium' | 'High') => {\n    switch (priority) {\n      case 'Low': return 'bg-green-600';\n      case 'Medium': return 'bg-yellow-600';\n      case 'High': return 'bg-red-600';\n    }\n  };\n\n  const renderTaskList = (status: 'To Do' | 'In Progress' | 'Done') => (\n    <div className=\"bg-gray-800 p-4 rounded-lg flex-1\">\n      <h2 className=\"text-xl font-bold mb-4\">{status}</h2>\n      {tasks.filter(task => task.status === status).map(task => (\n        <div key={task.id} className=\"bg-gray-700 p-3 rounded mb-2\">\n          <h3 className=\"font-semibold\">{task.title}</h3>\n          <p className=\"text-sm text-gray-400\">{task.description}</p>\n          <div className=\"flex justify-between items-center mt-2\">\n            <span className={\`px-2 py-1 rounded text-xs \${getPriorityColor(task.priority)}\`}>\n              {task.priority}\n            </span>\n            <span className=\"text-xs text-gray-500\">{task.dueDate}</span>\n          </div>\n          <div className=\"mt-2 flex justify-between\">\n            <select\n              value={task.status}\n              onChange={(e) => moveTask(task.id, e.target.value as 'To Do' | 'In Progress' | 'Done')}\n              className=\"p-1 bg-gray-600 rounded text-sm\"\n            >\n              <option value=\"To Do\">To Do</option>\n              <option value=\"In Progress\">In Progress</option>\n              <option value=\"Done\">Done</option>\n            </select>\n            <button\n              onClick={() => deleteTask(task.id)}\n              className=\"bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-sm\"\n            >\n              Delete\n            </button>\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n\n  return (\n    <div className=\"bg-gray-900 text-white p-8 rounded-xl shadow-2xl\">\n      <h1 className=\"text-3xl font-bold mb-6\">Kanban Board</h1>\n      <div className=\"grid grid-cols-2 gap-4 mb-4\">\n        <input\n          type=\"text\"\n          value={newTask.title}\n          onChange={(e) => setNewTask({ ...newTask, title: e.target.value })}\n          className=\"p-2 bg-gray-800 rounded\"\n          placeholder=\"Task Title\"\n        />\n        <input\n          type=\"date\"\n          value={newTask.dueDate}\n          onChange={(e) => setNewTask({ ...newTask, dueDate: e.target.value })}\n          className=\"p-2 bg-gray-800 rounded\"\n        />\n      </div>\n      <textarea\n        value={newTask.description}\n        onChange={(e) => setNewTask({ ...newTask, description: e.target.value })}\n        className=\"p-2 bg-gray-800 rounded w-full mb-4\"\n        placeholder=\"Task Description\"\n      />\n      <div className=\"flex justify-between items-center mb-4\">\n        <select\n          value={newTask.priority}\n          onChange={(e) => setNewTask({ ...newTask, priority: e.target.value as 'Low' | 'Medium' | 'High' })}\n          className=\"p-2 bg-gray-800 rounded\"\n        >\n          <option value=\"Low\">Low Priority</option>\n          <option value=\"Medium\">Medium Priority</option>\n          <option value=\"High\">High Priority</option>\n        </select>\n        <button\n          onClick={addTask}\n          className=\"bg-green-600 hover:bg-green-700 px-4 py-2 rounded\"\n        >\n          Add Task\n        </button>\n      </div>\n      <div className=\"flex space-x-4\">\n        {renderTaskList('To Do')}\n        {renderTaskList('In Progress')}\n        {renderTaskList('Done')}\n      </div>\n    </div>\n  );\n};\n\nrender(<KanbanBoard />);\n`\n\nexport const KANBAN_CSS = `\n/* No additional CSS needed as styles are handled by Tailwind */\n`\n\nexport const PROJECT_MANAGEMENT = `\nimport React from \"react\"\nimport render from \"react-dom\"\n\n\ninterface Project {\n  id: number;\n  name: string;\n  description: string;\n  status: 'To Do' | 'In Progress' | 'Completed';\n  dueDate: string;\n}\n\nconst ProjectManagement = () => {\n  const [projects, setProjects] = React.useState<Project[]>([]);\n  const [newProject, setNewProject] = React.useState<Omit<Project, 'id'>>({\n    name: '',\n    description: '',\n    status: 'To Do',\n    dueDate: ''\n  });\n  const [filter, setFilter] = React.useState<'To Do' | 'In Progress' | 'Completed' | 'All'>('All');\n\n  const addProject = () => {\n    if (newProject.name && newProject.description && newProject.dueDate) {\n      setProjects([...projects, { ...newProject, id: Date.now() }]);\n      setNewProject({ name: '', description: '', status: 'To Do', dueDate: '' });\n    }\n  };\n\n  const updateProjectStatus = (id: number, newStatus: 'To Do' | 'In Progress' | 'Completed') => {\n    setProjects(projects.map(project =>\n      project.id === id ? { ...project, status: newStatus } : project\n    ));\n  };\n\n  const deleteProject = (id: number) => {\n    setProjects(projects.filter(project => project.id !== id));\n  };\n\n  const filteredProjects = filter === 'All'\n    ? projects\n    : projects.filter(project => project.status === filter);\n\n  const getStatusColor = (status: 'To Do' | 'In Progress' | 'Completed') => {\n    switch (status) {\n      case 'To Do': return 'bg-yellow-600';\n      case 'In Progress': return 'bg-blue-600';\n      case 'Completed': return 'bg-green-600';\n    }\n  };\n\n  return (\n    <div className=\"bg-gray-900 text-white p-8 rounded-xl shadow-2xl\">\n      <h1 className=\"text-3xl font-bold mb-6\">Project Management</h1>\n      <div className=\"grid grid-cols-2 gap-4 mb-4\">\n        <input\n          type=\"text\"\n          value={newProject.name}\n          onChange={(e) => setNewProject({ ...newProject, name: e.target.value })}\n          className=\"p-2 bg-gray-800 rounded\"\n          placeholder=\"Project Name\"\n        />\n        <input\n          type=\"date\"\n          value={newProject.dueDate}\n          onChange={(e) => setNewProject({ ...newProject, dueDate: e.target.value })}\n          className=\"p-2 bg-gray-800 rounded\"\n        />\n      </div>\n      <textarea\n        value={newProject.description}\n        onChange={(e) => setNewProject({ ...newProject, description: e.target.value })}\n        className=\"p-2 bg-gray-800 rounded w-full mb-4\"\n        placeholder=\"Project Description\"\n      />\n      <button\n        onClick={addProject}\n        className=\"bg-green-600 hover:bg-green-700 px-4 py-2 rounded mb-4\"\n      >\n        Add Project\n      </button>\n      <div className=\"mb-4\">\n        <label className=\"mr-2\">Filter by Status:</label>\n        <select\n          value={filter}\n          onChange={(e) => setFilter(e.target.value as 'To Do' | 'In Progress' | 'Completed' | 'All')}\n          className=\"p-2 bg-gray-800 rounded\"\n        >\n          <option value=\"All\">All</option>\n          <option value=\"To Do\">To Do</option>\n          <option value=\"In Progress\">In Progress</option>\n          <option value=\"Completed\">Completed</option>\n        </select>\n      </div>\n      <ul>\n        {filteredProjects.map(project => (\n          <li key={project.id} className=\"mb-4 bg-gray-800 p-4 rounded\">\n            <div className=\"flex justify-between items-center\">\n              <h3 className=\"text-xl font-bold\">{project.name}</h3>\n              <span className={\`px-2 py-1 rounded \${getStatusColor(project.status)}\`}>\n                {project.status}\n              </span>\n            </div>\n            <p className=\"text-gray-400 mt-2\">{project.description}</p>\n            <p className=\"mt-2\"><strong>Due Date:</strong> {project.dueDate}</p>\n            <div className=\"mt-4\">\n              <select\n                value={project.status}\n                onChange={(e) => updateProjectStatus(project.id, e.target.value as 'To Do' | 'In Progress' | 'Completed')}\n                className=\"p-2 bg-gray-700 rounded mr-2\"\n              >\n                <option value=\"To Do\">To Do</option>\n                <option value=\"In Progress\">In Progress</option>\n                <option value=\"Completed\">Completed</option>\n              </select>\n              <button\n                onClick={() => deleteProject(project.id)}\n                className=\"bg-red-600 hover:bg-red-700 px-2 py-1 rounded\"\n              >\n                Delete\n              </button>\n            </div>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nrender(<ProjectManagement />);\n`\n\nexport const PROJECT_MANAGEMENT_CSS = `\n/* No additional CSS needed as styles are handled by Tailwind */\n`\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\order-factory.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { generateIdFromEntropySize } from 'lucia'\nimport { Order, OrderStatus, User, CodeRepo, SellerProfile, UserRepoAccess } from '@prisma/client'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\n\ninterface ExtendedUser extends User {\n  sellerProfile: SellerProfile | null\n}\n\nfunction generateDates() {\n  const now = DateTime.now()\n  const twoMonthsAgo = now.minus({ months: 2 })\n  const createdAt = faker.date.between({ from: twoMonthsAgo.toJSDate(), to: now.toJSDate() })\n  const updatedAt = faker.date.between({ from: createdAt, to: now.toJSDate() })\n  const deletedAt = faker.datatype.boolean(0.1)\n    ? faker.date.between({ from: updatedAt, to: now.toJSDate() })\n    : null\n  return { createdAt, updatedAt, deletedAt }\n}\n\nfunction generateOrder(users: ExtendedUser[], codeRepos: CodeRepo[]): Omit<Order, 'id'> {\n  const user = faker.helpers.arrayElement(users)\n  const codeRepo = faker.helpers.arrayElement(codeRepos)\n  const { createdAt, updatedAt, deletedAt } = generateDates()\n  const status = faker.helpers.arrayElement(Object.values(OrderStatus))\n  const totalAmount = parseFloat(faker.commerce.price({ min: 10, max: 1000 }))\n\n  return {\n    userId: user.id,\n    codeRepoId: codeRepo.id,\n    createdAt,\n    updatedAt,\n    deletedAt,\n    status,\n    totalAmount,\n    stripePaymentIntentId: status === 'SUCCEEDED' ? faker.string.uuid() : null,\n    stripePaymentMethodId: status === 'SUCCEEDED' ? faker.string.uuid() : null,\n    payoutRequestId: null,\n  }\n}\n\nasync function updateSalesAggregateAndSellerBalance(\n  order: Order,\n  sellerId: string,\n  sellerProfile: SellerProfile | null\n) {\n  if (order.status === 'SUCCEEDED') {\n    const aggregateDate = DateTime.fromJSDate(order.createdAt).startOf('month').toJSDate()\n\n    await prisma.$transaction(async (tx) => {\n      // Update sales aggregate\n      await tx.salesAggregate.upsert({\n        where: {\n          sellerId_date: {\n            sellerId: sellerId,\n            date: aggregateDate,\n          },\n        },\n        update: {\n          revenue: { increment: order.totalAmount },\n          salesCount: { increment: 1 },\n        },\n        create: {\n          id: generateIdFromEntropySize(32),\n          sellerId: sellerId,\n          date: aggregateDate,\n          revenue: order.totalAmount,\n          salesCount: 1,\n        },\n      })\n\n      // Update seller balance\n      if (sellerProfile) {\n        await tx.sellerProfile.update({\n          where: { id: sellerProfile.id },\n          data: { balance: { increment: order.totalAmount } },\n        })\n      }\n    })\n  }\n}\n\n//async function processBatch(orders: Omit<Order, 'id'>[], users: ExtendedUser[], codeRepos: CodeRepo[]) {\n//  const createdOrders: Order[] = []\n//  for (const orderData of orders) {\n//    try {\n//      await prisma.$transaction(async (tx) => {\n//        const createdOrder = await tx.order.create({\n//          data: {\n//            ...orderData,\n//            id: generateIdFromEntropySize(32),\n//          },\n//        })\n//\n//        const codeRepo = codeRepos.find(repo => repo.id === createdOrder.codeRepoId)\n//        if (codeRepo) {\n//          const seller = users.find(user => user.id === codeRepo.userId)\n//          if (seller && seller.sellerProfile) {\n//            await updateSalesAggregateAndSellerBalance(createdOrder, seller.id, seller.sellerProfile)\n//          }\n//        }\n//\n//        createdOrders.push(createdOrder)\n//        console.log(`Created order: ${createdOrder.id}`)\n//      })\n//    } catch (error) {\n//      console.error(`Error creating order:`, error)\n//    }\n//  }\n//  return createdOrders\n//}\n\nasync function grantRepoAccess(\n  tx: any,\n  userId: string,\n  repoId: string,\n  orderId: string\n): Promise<UserRepoAccess> {\n  return tx.userRepoAccess.upsert({\n    where: {\n      userId_repoId: {\n        userId,\n        repoId,\n      },\n    },\n    update: {\n      orderId, // Update the orderId if the access already exists\n      grantedAt: new Date(), // Update the grantedAt timestamp\n      // You can update other fields here if needed\n    },\n    create: {\n      id: generateIdFromEntropySize(32),\n      userId,\n      repoId,\n      orderId,\n      grantedAt: new Date(),\n    },\n  })\n}\n\nasync function processBatch(\n  orders: Omit<Order, 'id'>[],\n  users: ExtendedUser[],\n  codeRepos: CodeRepo[]\n) {\n  const createdOrders: Order[] = []\n  for (const orderData of orders) {\n    try {\n      await prisma.$transaction(async (tx) => {\n        const createdOrder = await tx.order.create({\n          data: {\n            ...orderData,\n            id: generateIdFromEntropySize(32),\n          },\n        })\n\n        const codeRepo = codeRepos.find((repo) => repo.id === createdOrder.codeRepoId)\n        if (codeRepo) {\n          const seller = users.find((user) => user.id === codeRepo.userId)\n          if (seller && seller.sellerProfile) {\n            await updateSalesAggregateAndSellerBalance(\n              createdOrder,\n              seller.id,\n              seller.sellerProfile\n            )\n          }\n\n          // Grant repo access if the order status is SUCCEEDED\n          if (createdOrder.status === OrderStatus.SUCCEEDED) {\n            await grantRepoAccess(tx, createdOrder.userId, createdOrder.codeRepoId, createdOrder.id)\n            console.log(\n              `Granted access to repo ${createdOrder.codeRepoId} for user ${createdOrder.userId}`\n            )\n          }\n        }\n\n        createdOrders.push(createdOrder)\n        console.log(`Created order: ${createdOrder.id}`)\n      })\n    } catch (error) {\n      console.error(`Error creating order:`, error)\n    }\n  }\n  return createdOrders\n}\n\nexport async function seedOrders(count: number = 100) {\n  let successfullyCreated = 0\n  const batchSize = 10 // Adjust this value based on your needs\n  try {\n    const users = (await prisma.user.findMany({\n      include: { sellerProfile: true },\n    })) as ExtendedUser[]\n    const codeRepos = await prisma.codeRepo.findMany()\n    if (users.length === 0 || codeRepos.length === 0) {\n      throw new Error('No users or code repos found. Please seed users and code repos first.')\n    }\n    for (let i = 0; i < count; i += batchSize) {\n      const batchCount = Math.min(batchSize, count - i)\n      const orderBatch = Array.from({ length: batchCount }, () => generateOrder(users, codeRepos))\n      const createdOrders = await processBatch(orderBatch, users, codeRepos)\n      successfullyCreated += createdOrders.length\n    }\n    console.log(`Successfully seeded ${successfullyCreated} out of ${count} requested orders`)\n  } catch (error) {\n    console.error('Error seeding orders:', error)\n  } finally {\n    await prisma.$disconnect()\n  }\n  return { successfullyCreated }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\payout-seeder.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { generateIdFromEntropySize } from 'lucia'\nimport {\n  PayoutRequest,\n  PayoutRequestStatus,\n  Payout,\n  SellerProfile,\n  SellerVerificationStatus,\n} from '@prisma/client'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\n\nfunction generateDates(status: PayoutRequestStatus) {\n  const now = DateTime.now()\n  const twoMonthsAgo = now.minus({ months: 2 })\n\n  const createdAt = faker.date.between({ from: twoMonthsAgo.toJSDate(), to: now.toJSDate() })\n  const updatedAt = faker.date.between({ from: createdAt, to: now.toJSDate() })\n\n  // Only generate processedAt for APPROVED or PROCESSED status\n  const processedAt =\n    status === PayoutRequestStatus.PROCESSED\n      ? faker.date.between({ from: updatedAt, to: now.toJSDate() })\n      : null\n\n  return { createdAt, updatedAt, processedAt }\n}\n\nfunction generatePayoutRequest(sellerProfile: SellerProfile): Omit<PayoutRequest, 'id'> {\n  const status = faker.helpers.arrayElement(Object.values(PayoutRequestStatus))\n  const { createdAt, updatedAt, processedAt } = generateDates(status)\n\n  return {\n    sellerProfileId: sellerProfile.id,\n    totalAmount: parseFloat(faker.finance.amount({ min: 100, max: 10000, dec: 2 })),\n    status,\n    createdAt,\n    updatedAt,\n    processedAt,\n    lastPayoutDate: processedAt,\n  }\n}\n\nfunction generatePayout(payoutRequest: PayoutRequest): Omit<Payout, 'id'> {\n  const { createdAt, updatedAt } = generateDates(payoutRequest.status)\n\n  return {\n    sellerProfileId: payoutRequest.sellerProfileId,\n    payoutRequestId: payoutRequest.id,\n    totalAmount: payoutRequest.totalAmount,\n    currency: 'USD',\n    createdAt,\n    updatedAt,\n  }\n}\n\nasync function processBatch(payoutRequests: Omit<PayoutRequest, 'id'>[]) {\n  const createdPayoutRequests: PayoutRequest[] = []\n  const createdPayouts: Payout[] = []\n\n  for (const payoutRequestData of payoutRequests) {\n    try {\n      const createdPayoutRequest = await prisma.payoutRequest.create({\n        data: {\n          ...payoutRequestData,\n          id: generateIdFromEntropySize(32),\n        },\n      })\n\n      createdPayoutRequests.push(createdPayoutRequest)\n      console.log(`Created payout request: ${createdPayoutRequest.id}`)\n\n      if (createdPayoutRequest.status === PayoutRequestStatus.PROCESSED) {\n        const payoutData = generatePayout(createdPayoutRequest)\n        const createdPayout = await prisma.payout.create({\n          data: {\n            ...payoutData,\n            id: generateIdFromEntropySize(32),\n          },\n        })\n\n        createdPayouts.push(createdPayout)\n        console.log(`Created payout: ${createdPayout.id}`)\n      }\n\n      // Update related orders\n      await prisma.order.updateMany({\n        where: {\n          codeRepo: {\n            userId: createdPayoutRequest.sellerProfileId,\n          },\n          status: 'SUCCEEDED',\n          payoutRequestId: null,\n        },\n        data: {\n          payoutRequestId: createdPayoutRequest.id,\n        },\n      })\n    } catch (error) {\n      console.error(`Error creating payout request or payout:`, error)\n    }\n  }\n\n  return { createdPayoutRequests, createdPayouts }\n}\n\nexport async function seedPayoutsAndRequests(count: number = 50) {\n  let successfullyCreatedRequests = 0\n  let successfullyCreatedPayouts = 0\n  const batchSize = 10 // Adjust this value based on your needs\n\n  try {\n    const verifiedSellerProfiles = await prisma.sellerProfile.findMany({\n      where: {\n        verificationStatus: SellerVerificationStatus.APPROVED,\n      },\n    })\n\n    if (verifiedSellerProfiles.length === 0) {\n      throw new Error(\n        'No verified seller profiles found. Please seed verified seller profiles first.'\n      )\n    }\n\n    for (let i = 0; i < count; i += batchSize) {\n      const batchCount = Math.min(batchSize, count - i)\n      const payoutRequestBatch = Array.from({ length: batchCount }, () =>\n        generatePayoutRequest(faker.helpers.arrayElement(verifiedSellerProfiles))\n      )\n      const { createdPayoutRequests, createdPayouts } = await processBatch(payoutRequestBatch)\n      successfullyCreatedRequests += createdPayoutRequests.length\n      successfullyCreatedPayouts += createdPayouts.length\n    }\n\n    console.log(\n      `Successfully seeded ${successfullyCreatedRequests} payout requests and ${successfullyCreatedPayouts} payouts for verified sellers`\n    )\n  } catch (error) {\n    console.error('Error seeding payouts and requests:', error)\n  } finally {\n    await prisma.$disconnect()\n  }\n\n  return { successfullyCreatedRequests, successfullyCreatedPayouts }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\repo-factory.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { generateIdFromEntropySize } from 'lucia'\nimport type { CodeRepo, User, Profile, SellerProfile, CodeRepoStatus } from '@prisma/client'\nimport { prisma } from '#services/prisma_service'\nimport { generateDates, weightedRandomTrueBoolean } from './utils.js'\nimport {\n  REPO_TAGS,\n  PROJECT_MANAGEMENT,\n  PROJECT_MANAGEMENT_CSS,\n  KANBAN,\n  KANBAN_CSS,\n  QUIZ_APP,\n  QUIZ_APP_CSS,\n} from './constants.js'\n\ninterface SeederConfig {\n  verifiedSellerProbability: number;\n  maxReposPerUser: number;\n  activeRepoProbability: number;\n}\n\nconst defaultConfig: SeederConfig = {\n  verifiedSellerProbability: 0.8,\n  maxReposPerUser: 5,\n  activeRepoProbability: 0.8,\n}\n\n// Function to generate a unique name\nfunction generateUniqueName(\n  user: User & { profile: Profile | null; sellerProfile: SellerProfile | null },\n  existingNames: Set<string>\n): string {\n  const maxAttempts = 100\n  let attempt = 0\n\n  while (attempt < maxAttempts) {\n    const userName = user.profile?.name ?? user.sellerProfile?.businessName ?? 'seller'\n    const companyName = faker.company.name()\n    let name = `${userName} - ${companyName}`.replace(/\s+/g, '_').toLowerCase()\n\n    if (!existingNames.has(name)) {\n      existingNames.add(name)\n      return name\n    }\n\n    attempt++\n  }\n\n  throw new Error('Unable to generate a unique name after maximum attempts')\n}\n\n// Function to select a seller with higher chance of selecting a verified seller\nfunction selectSeller(\n  verifiedSellers: (User & { sellerProfile: SellerProfile; profile: Profile | null })[],\n  unverifiedSellers: (User & { sellerProfile: SellerProfile; profile: Profile | null })[],\n  sellerRepoCounts: Map<string, number>,\n  config: SeederConfig\n) {\n  const eligibleVerifiedSellers = verifiedSellers.filter(seller => (sellerRepoCounts.get(seller.id) || 0) < config.maxReposPerUser)\n  const eligibleUnverifiedSellers = unverifiedSellers.filter(seller => (sellerRepoCounts.get(seller.id) || 0) < config.maxReposPerUser)\n\n  if (eligibleVerifiedSellers.length > 0 && Math.random() < config.verifiedSellerProbability) {\n    return faker.helpers.arrayElement(eligibleVerifiedSellers)\n  }\n\n  const allEligibleSellers = [...eligibleVerifiedSellers, ...eligibleUnverifiedSellers]\n  if (allEligibleSellers.length === 0) {\n    throw new Error('No eligible sellers available to create more repos')\n  }\n\n  return faker.helpers.arrayElement(allEligibleSellers)\n}\n\nasync function generateCodeRepos(count: number = 10, config: SeederConfig) {\n  const codeRepos: { repo: Omit<CodeRepo, 'id'>; tags: string[] }[] = []\n  const allSellers = await prisma.user.findMany({\n    where: {\n      sellerProfile: {\n        isNot: null,\n      },\n    },\n    include: { sellerProfile: true, profile: true },\n  })\n\n  if (allSellers.length === 0) {\n    throw new Error('No sellers found in the database. Please seed sellers first.')\n  }\n\n  const verifiedSellers = allSellers.filter(seller =>\n    seller.sellerProfile && seller.sellerProfile.verificationStatus === 'APPROVED'\n  ) as (User & { sellerProfile: SellerProfile; profile: Profile | null })[]\n\n  const unverifiedSellers = allSellers.filter(seller =>\n    seller.sellerProfile && seller.sellerProfile.verificationStatus !== 'APPROVED'\n  ) as (User & { sellerProfile: SellerProfile; profile: Profile | null })[]\n\n  const existingNames = new Set<string>()\n  const dbNames = await prisma.codeRepo.findMany({ select: { name: true } })\n  dbNames.forEach((r) => existingNames.add(r.name))\n\n  const sellerRepoCounts = new Map<string, number>()\n\n  for (let i = 0; i < count; i++) {\n    try {\n      const seller = selectSeller(verifiedSellers, unverifiedSellers, sellerRepoCounts, config)\n      sellerRepoCounts.set(seller.id, (sellerRepoCounts.get(seller.id) || 0) + 1)\n\n      const selectedRepo = faker.helpers.arrayElement([PROJECT_MANAGEMENT, KANBAN, QUIZ_APP])\n      const selectedRepoCss = {\n        [PROJECT_MANAGEMENT]: PROJECT_MANAGEMENT_CSS,\n        [KANBAN]: KANBAN_CSS,\n        [QUIZ_APP]: QUIZ_APP_CSS,\n      }\n\n      const priceAmount = Math.floor(\n        parseFloat(faker.commerce.price({ min: 100, max: 10000, dec: 2 }))\n      )\n      const { createdAt, updatedAt, deletedAt } = generateDates()\n      const status: CodeRepoStatus = Math.random() < config.activeRepoProbability ? 'active' : faker.helpers.arrayElement(['pending', 'rejected'])\n\n      const codeRepo: Omit<CodeRepo, 'id'> = {\n        userId: seller.id,\n        sourceJs: selectedRepo,\n        sourceCss: selectedRepoCss[selectedRepo as keyof typeof selectedRepoCss],\n        createdAt,\n        updatedAt,\n        deletedAt,\n        visibility: weightedRandomTrueBoolean() ? 'public' : 'private',\n        status: status,\n        name: generateUniqueName(seller, existingNames),\n        description: faker.lorem.sentences(),\n        language: faker.helpers.arrayElement(['JSX', 'TSX']),\n        price: priceAmount,\n      }\n\n      codeRepos.push({\n        repo: codeRepo,\n        tags: faker.helpers.arrayElements(REPO_TAGS, faker.number.int({ min: 1, max: 8 })),\n      })\n    } catch (error) {\n      console.error('Error generating code repo:', error)\n    }\n  }\n\n  return codeRepos\n}\n\nexport async function seedCodeRepos(count: number = 50, customConfig?: Partial<SeederConfig>) {\n  const config = { ...defaultConfig, ...customConfig }\n  let successfullyCreated = 0\n  const errors: Error[] = []\n  const distributionStats = {\n    verifiedSellers: 0,\n    unverifiedSellers: 0,\n  }\n\n\n  try {\n    const codeReposWithTags = await generateCodeRepos(count, config)\n\n    for (const { repo, tags } of codeReposWithTags) {\n      try {\n        await prisma.$transaction(async (tx) => {\n          const createdRepo = await tx.codeRepo.create({\n            data: {\n              ...repo,\n              id: generateIdFromEntropySize(32),\n              tags: {\n                create: tags.map((tagName) => ({\n                  tag: {\n                    connectOrCreate: {\n                      where: { name: tagName },\n                      create: { name: tagName },\n                    },\n                  },\n                })),\n              },\n            },\n            include: { user: { include: { sellerProfile: true } } },\n          })\n          console.log(`Created code repo: ${createdRepo.name} with ${tags.length} tags`)\n          successfullyCreated++\n\n          // Update distribution stats\n          if (createdRepo.user.sellerProfile?.verificationStatus === 'APPROVED') {\n            distributionStats.verifiedSellers++\n          } else {\n            distributionStats.unverifiedSellers++\n          }\n        })\n      } catch (error) {\n        console.error(`Error creating repo ${repo.name}:`, error)\n        errors.push(error)\n      }\n    }\n\n    console.log(`Successfully seeded ${successfullyCreated} out of ${count} requested code repos`)\n    console.log('Distribution of created repos:')\n    console.log(`Verified Sellers: ${distributionStats.verifiedSellers}`)\n    console.log(`Unverified Sellers: ${distributionStats.unverifiedSellers}`)\n    if (errors.length > 0) {\n      console.log(`Encountered ${errors.length} errors during seeding`)\n    }\n  } catch (error) {\n    console.error('Error generating code repos:', error)\n  } finally {\n    await prisma.$disconnect()\n  }\n\n  return { successfullyCreated, errors, distributionStats }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\seed.ts</source>
<document_content>import { prisma } from '#services/prisma_service'\nimport { seedCodeRepos } from './repo-factory.js'\nimport { seedOrders } from './order-factory.js'\nimport { generateUsers } from './user-factory.js'\nimport { seedReviewsAndComments } from './comment-factory.js'\nimport { seedPayoutsAndRequests } from './payout-seeder.js'\nimport { seedSupportTickets } from './support-seeder.js'\n\nasync function main() {\n  await generateUsers(100)\n  console.log('Users generated')\n  await seedCodeRepos(400)\n  await seedReviewsAndComments(300)\n  await seedOrders(2000)\n  await seedPayoutsAndRequests(50)\n  console.log('Orders generated')\n  await seedSupportTickets(200)\n}\n\nmain()\n  .catch((e) => {\n    console.error(e)\n    process.exit(1)\n  })\n  .finally(async () => {\n    await prisma.$disconnect()\n  })\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\seller-profile-factory.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport type { SellerProfile, User } from '@prisma/client'\nimport { generateIdFromEntropySize } from 'lucia'\n\nexport const generateSellerProfiles = (users: User[], count: number): SellerProfile[] => {\n  const sellerProfiles: SellerProfile[] = []\n\n  // Shuffle users array to randomly select users to become sellers\n  const sellerUsers = users.filter((user) => user.role === 'SELLER')\n  const shuffledUsers = sellerUsers.sort(() => 0.5 - Math.random())\n\n  for (let i = 0; i < count && i < users.length; i++) {\n    const user = shuffledUsers[i]\n    const sellerProfile: SellerProfile = {\n      id: generateIdFromEntropySize(32),\n      userId: user.id,\n      profileImg: faker.image.avatar(),\n      businessName: faker.company.name(),\n      businessAddress: faker.location.streetAddress(),\n      businessPhone: faker.phone.number(),\n      businessEmail: faker.internet.email(),\n      identityDoc: faker.system.filePath(),\n      verificationDate: faker.date.past(),\n    }\n    console.log('sellerProfile', sellerProfile)\n    sellerProfiles.push(sellerProfile)\n  }\n\n  return sellerProfiles\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\support-seeder.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { generateIdFromEntropySize } from 'lucia'\nimport { SupportTicket, SupportTicketStatus, SupportTicketType } from '@prisma/client'\nimport { prisma } from '#services/prisma_service'\nimport { DateTime } from 'luxon'\n\nfunction generateDates() {\n  const now = DateTime.now()\n  const oneMonthAgo = now.minus({ months: 1 })\n  const createdAt = faker.date.between({ from: oneMonthAgo.toJSDate(), to: now.toJSDate() })\n  const updatedAt = faker.date.between({ from: createdAt, to: now.toJSDate() })\n  return { createdAt, updatedAt }\n}\n\nfunction generateSupportTicket(): Omit<SupportTicket, 'id'> {\n  const { createdAt, updatedAt } = generateDates()\n  const status = faker.helpers.arrayElement(Object.values(SupportTicketStatus))\n  const type = faker.helpers.arrayElement(Object.values(SupportTicketType))\n\n  const titlePrefixes = {\n    [SupportTicketType.general]: ['Question about', 'Issue with', 'Feedback on'],\n    [SupportTicketType.technical]: ['Bug in', 'Error when', 'Problem with'],\n    [SupportTicketType.payment]: ['Payment failed for', 'Refund request for', 'Billing issue with'],\n  }\n\n  const titlePrefix = faker.helpers.arrayElement(titlePrefixes[type])\n  const title = `${titlePrefix} ${faker.lorem.words(3)}`\n\n  return {\n    email: faker.internet.email(),\n    title,\n    content: faker.lorem.paragraphs(2),\n    status,\n    type,\n    createdAt,\n    updatedAt,\n  }\n}\n\nasync function processBatch(tickets: Omit<SupportTicket, 'id'>[]) {\n  const createdTickets: SupportTicket[] = []\n  for (const ticketData of tickets) {\n    try {\n      const createdTicket = await prisma.supportTicket.create({\n        data: {\n          ...ticketData,\n          id: generateIdFromEntropySize(32),\n        },\n      })\n      createdTickets.push(createdTicket)\n      console.log(`Created support ticket: ${createdTicket.id}`)\n    } catch (error) {\n      console.error(`Error creating support ticket:`, error)\n    }\n  }\n  return createdTickets\n}\n\nexport async function seedSupportTickets(count: number = 50) {\n  let successfullyCreated = 0\n  const batchSize = 10 // Adjust this value based on your needs\n\n  try {\n    for (let i = 0; i < count; i += batchSize) {\n      const batchCount = Math.min(batchSize, count - i)\n      const ticketBatch = Array.from({ length: batchCount }, generateSupportTicket)\n      const createdTickets = await processBatch(ticketBatch)\n      successfullyCreated += createdTickets.length\n    }\n    console.log(\n      `Successfully seeded ${successfullyCreated} out of ${count} requested support tickets`\n    )\n  } catch (error) {\n    console.error('Error seeding support tickets:', error)\n  } finally {\n    await prisma.$disconnect()\n  }\n\n  return { successfullyCreated }\n}\n\n// Optional: Add a function to delete all support tickets (useful for testing)\nexport async function deleteAllSupportTickets() {\n  try {\n    const { count } = await prisma.supportTicket.deleteMany()\n    console.log(`Deleted ${count} support tickets`)\n    return count\n  } catch (error) {\n    console.error('Error deleting support tickets:', error)\n  } finally {\n    await prisma.$disconnect()\n  }\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\user-factory.ts</source>
<document_content>import { faker } from '@faker-js/faker'\nimport { prisma } from '#services/prisma_service'\nimport { Role, User, Profile, SellerProfile, SellerVerificationStatus } from '@prisma/client'\nimport { UserFactory } from '#factories/user_factory'\n\ntype UserWithProfile = {\n  user: User\n  profile?: Profile\n  sellerProfile?: SellerProfile\n}\n\n/**\n * Generates a list of fake users and their profiles using the UserFactory.\n *\n * @param {number} [count=50] - The number of additional random users to generate.\n * @returns {Promise<UserWithProfile[]>} - An array of generated users and their profiles.\n */\nexport const generateUsers = async (count: number = 50): Promise<UserWithProfile[]> => {\n  const users: UserWithProfile[] = []\n\n  // Generate forced test users\n  users.push(...(await generateForcedTestUsers()))\n\n  // Define role weights\n  const roleWeights = {\n    USER: 50, // 50% chance\n    SELLER: 40, // 40% chance\n    ADMIN: 5, // 5% chance\n    MODERATOR: 5, // 5% chance\n  }\n\n  // Generate additional random users\n  for (let i = 0; i < count; i++) {\n    const email = faker.internet.email()\n    const password = 'password'\n    const fullname = faker.person.fullName()\n    const role = weightedRandomRole(roleWeights)\n\n    try {\n      let userWithProfile: UserWithProfile\n\n      switch (role) {\n        case 'USER':\n          userWithProfile = await createUserWithSpecialCases(i, { email, password, fullname })\n          break\n        case 'SELLER':\n          userWithProfile = await createSellerWithSpecialCases(i, { email, password, fullname })\n          break\n        case 'ADMIN':\n          userWithProfile = await UserFactory.createAdmin({ email, password, fullname })\n          break\n        case 'MODERATOR':\n          userWithProfile = await UserFactory.createModerator({ email, password, fullname })\n          break\n      }\n\n      users.push(userWithProfile)\n      console.log(`Generated user ${i + 1}/${count} with role ${role}.`)\n    } catch (error) {\n      console.error(`Failed to create user with role ${role}:`, error)\n    }\n  }\n\n  console.log(`Successfully generated ${users.length} users.`)\n  return users\n}\n\n/**\n * Selects a random role based on the provided weights.\n *\n * @param {Record<Role, number>} weights - The weights for each role.\n * @returns {Role} - The selected role.\n */\nfunction weightedRandomRole(weights: Record<Role, number>): Role {\n  const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0)\n  let random = Math.random() * totalWeight\n\n  for (const [role, weight] of Object.entries(weights)) {\n    if (random < weight) {\n      return role as Role\n    }\n    random -= weight\n  }\n\n  return 'USER' // Fallback to USER if something goes wrong\n}\n\nasync function generateForcedTestUsers(): Promise<UserWithProfile[]> {\n  const forcedUsers: UserWithProfile[] = []\n  const password = 'password'\n\n  await prisma.$transaction(async (px) => {\n    // Admin\n    forcedUsers.push(\n      await UserFactory.createAdmin(\n        { email: 'admin@example.com', password, fullname: 'Admin User' },\n        prisma\n      )\n    )\n\n    // Normal user\n    forcedUsers.push(\n      await UserFactory.createUser(\n        {\n          email: 'normalUser@example.com',\n          password,\n          fullname: 'Normal User',\n        },\n        prisma\n      )\n    )\n\n    // Banned user\n    const bannedUser = await UserFactory.createUser(\n      {\n        email: 'bannedUser@example.com',\n        password,\n        fullname: 'Banned User',\n      },\n      prisma\n    )\n    await prisma.user.update({\n      where: { id: bannedUser.user.id },\n      data: { bannedUntil: faker.date.future() },\n    })\n    forcedUsers.push(bannedUser)\n\n    // Unverified email user (we'll verify it later in this function)\n    forcedUsers.push(\n      await UserFactory.createUser(\n        {\n          email: 'unverifiedEmailUser@example.com',\n          password,\n          fullname: 'Unverified Email User',\n        },\n        prisma\n      )\n    )\n\n    // Deleted user\n    const deletedUser = await UserFactory.createUser(\n      {\n        email: 'deletedUser@example.com',\n        password,\n        fullname: 'Deleted User',\n      },\n      prisma\n    )\n    await prisma.user.update({\n      where: { id: deletedUser.user.id },\n      data: { deletedAt: new Date() },\n    })\n    forcedUsers.push(deletedUser)\n\n    // Verified Seller\n    const verifiedSeller = await UserFactory.createSeller(\n      {\n        email: 'verifiedSeller@example.com',\n        password,\n        fullname: 'Verified Seller',\n        businessName: faker.company.name(),\n        businessAddress: faker.location.streetAddress(),\n        businessPhone: faker.phone.number(),\n      },\n      prisma\n    )\n\n    await UserFactory.addBankAccount(\n      verifiedSeller.user.id,\n      {\n        bankName: faker.finance.accountName(),\n        accountHolderName: faker.person.fullName(),\n        accountNumber: faker.finance.accountNumber(),\n        routingNumber: faker.finance.routingNumber(),\n        swiftCode: faker.finance.bic(),\n      },\n      prisma\n    )\n\n    await prisma.sellerProfile.update({\n      where: { userId: verifiedSeller.user.id },\n      data: {\n        verificationStatus: SellerVerificationStatus.APPROVED,\n        verificationDate: new Date(),\n      },\n    })\n    forcedUsers.push(verifiedSeller)\n\n    // Unverified Seller (we'll verify the email later in this function)\n    forcedUsers.push(\n      await UserFactory.createSeller(\n        {\n          email: 'unverifiedSeller@example.com',\n          password,\n          fullname: 'Unverified Seller',\n          businessName: faker.company.name(),\n          businessAddress: faker.location.streetAddress(),\n          businessPhone: faker.phone.number(),\n        },\n        prisma\n      )\n    )\n\n    // Moderator\n    forcedUsers.push(\n      await UserFactory.createModerator(\n        {\n          email: 'moderator@example.com',\n          password,\n          fullname: 'Moderator User',\n        },\n        prisma\n      )\n    )\n\n    // Verify all users' emails (except the deleted user)\n    for (const userWithProfile of forcedUsers) {\n      if (!userWithProfile.user.deletedAt) {\n        await prisma.user.update({\n          where: { id: userWithProfile.user.id },\n          data: { emailVerified: true },\n        })\n      }\n    }\n  })\n\n  return forcedUsers\n}\n\nasync function createUserWithSpecialCases(\n  index: number,\n  userData: { email: string; password: string; fullname: string }\n): Promise<UserWithProfile> {\n  let userWithProfile: UserWithProfile\n\n  if (index % 10 === 0) {\n    // Every 10th user is banned\n    userWithProfile = await UserFactory.createUser(userData)\n    await prisma.user.update({\n      where: { id: userWithProfile.user.id },\n      data: { bannedUntil: faker.date.future() },\n    })\n  } else if (index % 7 === 0) {\n    // Every 7th user is deleted\n    userWithProfile = await UserFactory.createUser(userData)\n    await prisma.user.update({\n      where: { id: userWithProfile.user.id },\n      data: { deletedAt: new Date() },\n    })\n  } else if (index % 5 === 0) {\n    // Every 5th user has a verified email\n    userWithProfile = await UserFactory.createUser(userData)\n    await prisma.user.update({\n      where: { id: userWithProfile.user.id },\n      data: { emailVerified: true },\n    })\n  } else {\n    userWithProfile = await UserFactory.createUser(userData)\n  }\n\n  return userWithProfile\n}\n\nasync function createSellerWithSpecialCases(\n  index: number,\n  userData: { email: string; password: string; fullname: string }\n): Promise<UserWithProfile> {\n  const sellerData = {\n    ...userData,\n    businessName: 'example business name',\n    businessAddress: 'example business address',\n    businessPhone: '+1 234 567 8901',\n  }\n\n  let userWithProfile: UserWithProfile = await UserFactory.createSeller(sellerData)\n\n  if (index % 2 === 0) {\n    // Every 2rd seller is verified\n    await prisma.user.update({\n      where: { id: userWithProfile.user.id },\n      data: {\n        emailVerified: true,\n      },\n    })\n    await prisma.sellerProfile.update({\n      where: { userId: userWithProfile.user.id },\n      data: {\n        verificationStatus: SellerVerificationStatus.APPROVED,\n        verificationDate: new Date(),\n        businessName: faker.company.name(),\n        businessAddress: faker.location.streetAddress(),\n        businessPhone: faker.phone.number(),\n      },\n    })\n    // Add bank account for verified sellers\n    await prisma.bankAccount.create({\n      data: {\n        sellerProfileId: userWithProfile.sellerProfile!.id,\n        accountHolderName: userData.fullname,\n        accountNumber: faker.finance.accountNumber(),\n        bankName: faker.company.name(),\n        swiftCode: faker.finance.bic(),\n      },\n    })\n  } else if (index % 5 === 0) {\n    // Every 5th seller is rejected\n    await prisma.sellerProfile.update({\n      where: { userId: userWithProfile.user.id },\n      data: {\n        verificationStatus: SellerVerificationStatus.REJECTED,\n      },\n    })\n  }\n  // All other sellers remain in PENDING status\n\n  return userWithProfile\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\database\seeders\utils.ts</source>
<document_content>import { faker } from '@faker-js/faker'\n\nexport const randomBoolean = () => Math.random() < 0.5\n\n/**\n * Interface representing the generated dates.\n */\ninterface GeneratedDates {\n  createdAt: Date\n  updatedAt: Date\n  deletedAt: Date | null\n}\n\n/**\n * Generates creation, update, and optional deletion dates.\n *\n * @returns {GeneratedDates} - An object containing createdAt, updatedAt, and optionally deletedAt dates.\n */\nexport const generateDates = (): GeneratedDates => {\n  const createdAt = faker.date.anytime()\n  const updatedAt = new Date(\n    createdAt.getTime() + faker.number.int({ min: 1000, max: 1000000 }) * 60 * 60 * 24 * 30\n  )\n  const deletedAt = randomBoolean()\n    ? new Date(\n        createdAt.getTime() +\n          faker.number.int({\n            min: 1000,\n            max: (updatedAt.getTime() - createdAt.getTime()) / 60000,\n          }) *\n            60 *\n            1000\n      )\n    : null\n\n  return { createdAt, updatedAt, deletedAt }\n}\n/**\n * Generates a weighted random date for deletion.\n *\n * @returns {Date | null} - A date for deletion or null.\n */\nexport const weightedRandomDelete = (): Date | null => {\n  const random = Math.random()\n  if (random < 0.1) {\n    return new Date()\n  }\n  return null\n}\n\nexport const weightedRandomTrueBoolean = () => Math.random() < 0.9;\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\app.ts</source>
<document_content>import env from '#start/env'\nimport app from '@adonisjs/core/services/app'\nimport { Secret } from '@adonisjs/core/helpers'\nimport { defineConfig } from '@adonisjs/core/http'\n\n/**\n * The app key is used for encrypting cookies, generating signed URLs,\n * and by the \"encryption\" module.\n *\n * The encryption module will fail to decrypt data if the key is lost or\n * changed. Therefore it is recommended to keep the app key secure.\n */\nexport const appKey = new Secret(env.get('APP_KEY'))\n\n/**\n * The configuration settings used by the HTTP server\n */\nexport const http = defineConfig({\n  generateRequestId: true,\n  allowMethodSpoofing: false,\n\n  /**\n   * Enabling async local storage will let you access HTTP context\n   * from anywhere inside your application.\n   */\n  useAsyncLocalStorage: false,\n\n  /**\n   * Manage cookies configuration. The settings for the session id cookie are\n   * defined inside the \"config/session.ts\" file.\n   */\n  cookie: {\n    domain: '',\n    path: '/',\n    maxAge: '2h',\n    httpOnly: true,\n    secure: app.inProduction,\n    sameSite: 'lax',\n  },\n})\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\bodyparser.ts</source>
<document_content>import { defineConfig } from '@adonisjs/core/bodyparser'\n\nconst bodyParserConfig = defineConfig({\n  /**\n   * The bodyparser middleware will parse the request body\n   * for the following HTTP methods.\n   */\n  allowedMethods: ['POST', 'PUT', 'PATCH', 'DELETE'],\n\n  /**\n   * Config for the \"application/x-www-form-urlencoded\"\n   * content-type parser\n   */\n  form: {\n    convertEmptyStringsToNull: true,\n    types: ['application/x-www-form-urlencoded'],\n  },\n\n  /**\n   * Config for the JSON parser\n   */\n  json: {\n    convertEmptyStringsToNull: true,\n    types: [\n      'application/json',\n      'application/json-patch+json',\n      'application/vnd.api+json',\n      'application/csp-report',\n    ],\n  },\n\n  /**\n   * Config for the \"multipart/form-data\" content-type parser.\n   * File uploads are handled by the multipart parser.\n   */\n  multipart: {\n    /**\n     * Enabling auto process allows bodyparser middleware to\n     * move all uploaded files inside the tmp folder of your\n     * operating system\n     */\n    autoProcess: false,\n    convertEmptyStringsToNull: true,\n    processManually: [],\n    encoding: 'utf-8',\n    /**\n     * Maximum limit of data to parse including all files\n     * and fields\n     */\n    limit: '20mb',\n    types: ['multipart/form-data'],\n  },\n})\n\nexport default bodyParserConfig\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\cors.ts</source>
<document_content>import { defineConfig } from '@adonisjs/cors'\n\n/**\n * Configuration options to tweak the CORS policy. The following\n * options are documented on the official documentation website.\n *\n * https://docs.adonisjs.com/guides/security/cors\n */\nconst corsConfig = defineConfig({\n  enabled: true,\n  origin: '*',\n  methods: ['GET', 'HEAD', 'POST', 'PUT', 'DELETE'],\n  headers: true,\n  exposeHeaders: [],\n  credentials: true,\n  maxAge: 90,\n})\n\nexport default corsConfig\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\hash.ts</source>
<document_content>import { defineConfig, drivers } from '@adonisjs/core/hash'\n\nconst hashConfig = defineConfig({\n  default: 'scrypt',\n\n  list: {\n    scrypt: drivers.scrypt({\n      cost: 16384,\n      blockSize: 8,\n      parallelization: 1,\n      maxMemory: 33554432,\n    }),\n  },\n})\n\nexport default hashConfig\n\n/**\n * Inferring types for the list of hashers you have configured\n * in your application.\n */\ndeclare module '@adonisjs/core/types' {\n  export interface HashersList extends InferHashers<typeof hashConfig> {}\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\limiter.ts</source>
<document_content>import env from '#start/env'\nimport { defineConfig, stores } from '@adonisjs/limiter'\n\nconst limiterConfig = defineConfig({\n  default: env.get('LIMITER_STORE'),\n  stores: {\n    /**\n     * Database store to save rate limiting data inside a\n     * MYSQL or PostgreSQL database.\n     */\n    database: stores.database({\n      tableName: 'rate_limits',\n    }),\n\n    /**\n     * Memory store could be used during\n     * testing\n     */\n    memory: stores.memory({}),\n  },\n})\n\nexport default limiterConfig\n\ndeclare module '@adonisjs/limiter/types' {\n  export interface LimitersList extends InferLimiters<typeof limiterConfig> {}\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\logger.ts</source>
<document_content>import env from '#start/env'\nimport app from '@adonisjs/core/services/app'\nimport { defineConfig, targets } from '@adonisjs/core/logger'\n\nconst loggerConfig = defineConfig({\n  default: 'app',\n\n  /**\n   * The loggers object can be used to define multiple loggers.\n   * By default, we configure only one logger (named \"app\").\n   */\n  loggers: {\n    app: {\n      enabled: true,\n      name: env.get('APP_NAME'),\n      level: env.get('LOG_LEVEL'),\n      transport: {\n        targets: targets()\n          .pushIf(!app.inProduction, targets.pretty())\n          .pushIf(app.inProduction, targets.file({ destination: 1 }))\n          .toArray(),\n      },\n    },\n  },\n})\n\nexport default loggerConfig\n\n/**\n * Inferring types for the list of loggers you have configured\n * in your application.\n */\ndeclare module '@adonisjs/core/types' {\n  export interface LoggersList extends InferLoggers<typeof loggerConfig> {}\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\mail.ts</source>
<document_content>import env from '#start/env'\nimport { defineConfig, transports } from '@adonisjs/mail'\n\nconst mailConfig = defineConfig({\n  default: 'smtp',\n\n  /**\n   * The mailers object can be used to configure multiple mailers\n   * each using a different transport or same transport with different\n   * options.\n   */\n  mailers: {\n    smtp: transports.smtp({\n      host: env.get('SMTP_HOST'),\n      port: env.get('SMTP_PORT') ?? 2525,\n      /**\n       * Uncomment the auth block if your SMTP\n       * server needs authentication\n       */\n      auth: {\n        type: 'login',\n        user: env.get('SMTP_USER') ?? '',\n        pass: env.get('SMTP_PASS') ?? '',\n      },\n    }),\n  },\n})\n\nexport default mailConfig\n\ndeclare module '@adonisjs/mail/types' {\n  export interface MailersList extends InferMailers<typeof mailConfig> {}\n}\n</document_content>
</document>
<document>
<source>C:\Users\aaron\OneDrive - Asia Pacific University\deg sem 3\FYP\project\fyp-back\config\swagger.ts</source>
<document_content>// for AdonisJS v6\nimport path from 'node:path'\nimport url from 'node:url'\n// ---\n\nexport default {\n  // path: __dirname + \"/../\", for AdonisJS v5\n  path: path.dirname(url.fileURLToPath(import.meta.url)) + '/../', // for AdonisJS v6\n  title: 'Foo', // use info instead\n  version: '1.0.0', // use info instead\n  description: '', // use info instead\n  tagIndex: 3,\n  info: {\n    title: 'title',\n    version: '1.0.0',\n    description: '',\n  },\n  snakeCase: true,\n\n  debug: false, // set to true, to get some useful debug output\n  ignore: ['/swagger', '/docs'],\n  preferredPutPatch: 'PUT', // if PUT/PATCH are provided for the same route, prefer PUT\n  common: {\n    parameters: {}, // OpenAPI conform parameters that are commonly used\n    headers: {}, // OpenAPI conform headers that are commonly used\n  },\n  securitySchemes: {}, // optional\n  authMiddlewares: ['auth', 'auth:api'], // optional\n  defaultSecurityScheme: 'Cookie', // optional\n  persistAuthorization: true, // persist authorization between reloads on the swagger page\n  showFullPath: false, // the path displayed after endpoint summary\n}\n</document_content>
</document>
